<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2025-10-09T00:24:03+00:00</updated><id>/feed.xml</id><title type="html">Chew’s Everyday Blog</title><subtitle>A blog of a CS student.</subtitle><author><name>Chew Y. Feng</name></author><entry><title type="html">A Note on LLVM</title><link href="/pl/2025/10/09/LLVM-note.html" rel="alternate" type="text/html" title="A Note on LLVM" /><published>2025-10-09T00:00:00+00:00</published><updated>2025-10-09T09:29:51+00:00</updated><id>/pl/2025/10/09/LLVM-note</id><content type="html" xml:base="/pl/2025/10/09/LLVM-note.html"><![CDATA[<p>This is a note for Lopes’ <em>Getting Started with LLVM Core Libraries</em>. n.d. Accessed October 2, 2025. <a href="https://learning.oreilly.com/library/view/getting-started-with/9781782166924/">https://learning.oreilly.com/library/view/getting-started-with/9781782166924/</a>.</p>
<h2 id="tools-and-design">Tools and Design</h2>

<p>LLVM IR:</p>
<ul>
  <li>Single Static Assignment form (SSA)</li>
  <li>Infinite number of Registers</li>
  <li>Easy link-time optimizations by storing entire programs in an on-disk IR representation</li>
</ul>

<p>Apart from IR, other forms of program representations are:</p>
<ul>
  <li><a href="https://clang.llvm.org/doxygen/classclang_1_1TranslationUnitDecl.html">Abstract Syntax Tree (AST)</a>, immediate result from parsing</li>
  <li><a href="https://llvm.org/doxygen/classllvm_1_1SelectionDAG.html">Directed Acyclic Gragh (DAG)</a> , after generation</li>
  <li><a href="https://llvm.org/doxygen/classllvm_1_1Module.html">Modules</a></li>
</ul>

<p>Fun fact that LLVM is originally aims for a vm runtime, like JVM. I’m glad they do not go this direction:</p>
<blockquote>
  <p>As the project matured, the design decision of maintaining an on-disk representation of the compiler IR remained as an enabler of link-time optimizations, giving less attention to the original idea of lifelong program optimizations. Eventually, LLVM’s core libraries formalized their lack of interest in becoming a platform by renouncing the acronym Low Level Virtual Machine, adopting just the name LLVM for historical reasons, making it clear that the LLVM project is geared to being a strong and practical C/C++ compiler rather than a Java platform competitor.</p>
</blockquote>

<p>How LLVM works:
<img src="Pasted%20image%2020251007142158.png" alt="" /></p>

<p>Actually, “clang” is a driver of many llvm tools and platform tools.  For example:</p>
<ul>
  <li>“clang -cc1” The llvm C frontend for IR generation</li>
  <li>“ld”: linux linker</li>
  <li>“opt”: IR level optimisation tool</li>
</ul>

<p>Use <code class="language-plaintext highlighter-rouge">clang -###</code> to view what tools are driving by clang</p>

<p>Those tools can be used individually:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>clang <span class="nt">-emit-llvm</span> –S <span class="nt">-c</span> main.c <span class="nt">-o</span> main.ll
<span class="nv">$ </span>clang <span class="nt">-emit-llvm</span> –S <span class="nt">-c</span> sum.c <span class="nt">-o</span> sum.ll

</code></pre></div></div>

<h2 id="llvm-ir">LLVM IR</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>define i32 @sum(i32 %a, i32 %b) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  store i32 %b, i32* %b.addr, align 4
  %0 = load i32* %a.addr, align 4
  %1 = load i32* %b.addr, align 4
  %add = add nsw i32 %0, %1
  ret i32 %add
}

  
attributes #0 = { nounwind ssp uwtable ... }
</code></pre></div></div>

<ul>
  <li>Local Values are analogs of the registers in the assembly language.</li>
  <li>Local identifiers are with <code class="language-plaintext highlighter-rouge">%</code> and globals are with <code class="language-plaintext highlighter-rouge">@</code></li>
  <li>An array is written as <code class="language-plaintext highlighter-rouge">[&lt;number of elements&gt; x &lt;element type&gt;]</code></li>
  <li><code class="language-plaintext highlighter-rouge">attributes</code> are translation of C/C++ function decorators such as no throwing exceptions (<code class="language-plaintext highlighter-rouge">nounwind</code>, use stack smash protector <code class="language-plaintext highlighter-rouge">ssp</code>)</li>
  <li>function body is divided into basic blocks (BBs)</li>
  <li>Each instruction is in the form of three address code</li>
  <li><code class="language-plaintext highlighter-rouge">alloca</code> instruction reserves space on the stack frame</li>
</ul>

<h2 id="optimisation-on-llvm-ir">Optimisation on LLVM IR</h2>

<p>The optimisation tool <a href="https://llvm.org/docs/NewPassManager.html#invoking-opt">opt</a> supports optimisation flags <code class="language-plaintext highlighter-rouge">-Ox</code>. <code class="language-plaintext highlighter-rouge">O0</code> means no optimisation, <code class="language-plaintext highlighter-rouge">O2</code> includes most optimisation and <code class="language-plaintext highlighter-rouge">Oz</code> is the highest level of optimisation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang -emit-llvm -O0 -S ./sum.c -o ./sum.ll
opt -Oz ./sum.ll -o ./sum.oz.ll -S
</code></pre></div></div>

<p>One can also use <code class="language-plaintext highlighter-rouge">--passes</code> to select specific optimisation pass. See <a href="https://llvm.org/docs/NewPassManager.html#invoking-opt">Invoke OPT</a></p>

<p><code class="language-plaintext highlighter-rouge">opt</code> operates on the llvm IR level.</p>

<h2 id="clang-static-analyzer">Clang Static Analyzer</h2>

<p>The clang static analyzer , also known as the <code class="language-plaintext highlighter-rouge">scan-build</code> tool leverages a set of <strong>checkers</strong> to build elaborate bug reports.</p>

<p>It relies on symbolic execution engine and thus it has exponential time complexity.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⬢ [qfeng@toolbx ❱ llvm-experiment code]$ cat ./scan-test2.c 
#include &lt;stdio.h&gt;

int main() { return 0; }

void my_function(int unknownvalue) {
    int schroedinger_integer;
    if (unknownvalue)
        schroedinger_integer = 5;
    printf("hi");
    if (!unknownvalue)
        printf("%d", schroedinger_integer);
}
⬢ [qfeng@toolbx ❱ llvm-experiment code]$ scan-build clang ./scan-test2.c 
scan-build: Using '/usr/local/bin/clang-19' for static analysis
./scan-test2.c:11:9: warning: 2nd function call argument is an uninitialized value [core.CallAndMessage]
   11 |         printf("%d", schroedinger_integer);
      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1 warning generated.
scan-build: 1 bug found.
</code></pre></div></div>

<p>The analysis is path-sensitive but no sound or complete guarantee.</p>]]></content><author><name>Chew Y. Feng</name></author><category term="PL" /><category term="PL" /><summary type="html"><![CDATA[A reading note of LLVM Core Libraries book]]></summary></entry><entry><title type="html">Theory of Abstract Interpretation</title><link href="/pl/2025/09/17/theory-of-AE.html" rel="alternate" type="text/html" title="Theory of Abstract Interpretation" /><published>2025-09-17T00:00:00+00:00</published><updated>2025-09-17T02:11:57+00:00</updated><id>/pl/2025/09/17/theory-of-AE</id><content type="html" xml:base="/pl/2025/09/17/theory-of-AE.html"><![CDATA[<p>This note is created for the Cousot POPL77 paper about <em>abstract interpretation</em>^[1] .</p>
<h2 id="syntax-and-semantics-of-programs">Syntax And Semantics of Programs</h2>

<h3 id="syntax">Syntax</h3>

<p>Programs are represented as finite flowcharts, also known as <em>control flow graphs</em>. 
The graph is built by a set “Nodes”. A node $n \in \text{Nodes}$ is</p>
<ul>
  <li>An Entry. nodes with no predecessors and one successor</li>
  <li>An Assignment. id(n) := expr(n)</li>
  <li>A Test. A test node has two successors. <code class="language-plaintext highlighter-rouge">forall n in Tests, n-succ(n) = { n-succ-t(n), n-succ-f(n) }</code></li>
  <li>A Junction node has more than 1 predecessor and one successor</li>
  <li>An Exit node has one predecessor and no successor</li>
</ul>

<p>The set “Arcs” are edges in the graph, that is
<code class="language-plaintext highlighter-rouge">Arcs = {&lt;n,m&gt; | (n in Nodes) and (m in n-succ(n))}</code></p>
<h3 id="operational-semantics">Operational Semantics</h3>
<p>Let’s define the constructive or operational semantics.</p>

<p>The set “States” are all the information that can occur during computation<br />
<code class="language-plaintext highlighter-rouge">States = Arcs^0 times Env</code>
<code class="language-plaintext highlighter-rouge">Env = Ident^0 -&gt; Values</code>
Where Values are concrete program values. 
So a <code class="language-plaintext highlighter-rouge">state in States = &lt;r, e&gt;</code> records that for program point <code class="language-plaintext highlighter-rouge">r</code>, the mapping of each variable id to its value.</p>

<p>The initial state is defined as
<code class="language-plaintext highlighter-rouge">I-States = {&lt;a-succ(m), bottom | m in Entries &gt;}</code>
i.e. for all entry nodes <code class="language-plaintext highlighter-rouge">m</code>, get its successor arc <code class="language-plaintext highlighter-rouge">m</code> and set all the variables to empty (bottom, in lattice language).</p>

<p>The state transfer function are defined as equation systems
<code class="language-plaintext highlighter-rouge">n-state: States -&gt; States</code>
Its implementation is forward computation. i.e. computing the state of next arc using current arc.</p>
<ul>
  <li>For test node, the semantics uses <code class="language-plaintext highlighter-rouge">val[test(n)](env)</code> to pick the branch</li>
  <li>For assignment node, the semantics uses replacement <code class="language-plaintext highlighter-rouge">env’ = env[val(expr(n))/id(n)]</code>.</li>
  <li>…</li>
</ul>

<p>Finally, a computation sequence is repeatedly apply the state transfer function on the initial state <code class="language-plaintext highlighter-rouge">i_s in I-states</code> 
<code class="language-plaintext highlighter-rouge">s_n = n-state^n(i_s) for n = 0, 1, ...</code></p>

<p>Consequently, the final state is a the least fixpoint of the functional.
<code class="language-plaintext highlighter-rouge">λF.(n-state ∘ F)</code>
i.e. An equation systems is derived by the cfg and the state transfer function, and <code class="language-plaintext highlighter-rouge">F in State</code> is a state that no longer change under the equation system :
<code class="language-plaintext highlighter-rouge">λF.(n-state ∘ F) (F) = F</code></p>
<h3 id="static-semantics">Static Semantics</h3>

<p>The operational semantics require analysis of every program execution, which is practically impossible for building a realistic verification tool. By Floyd^[2], to prove static properties of program, it is often sufficient to consider the <em>sets</em> of states associated with each program point.</p>

<p>The context is the set of all environments which may be associated in any computation sequences.  <code class="language-plaintext highlighter-rouge">Context = Pow(Env)</code></p>

<p>Define the context vector as</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cv: Arcs^0 -&gt; Context
Cv = λq.{e | (exists n &gt;= 0, exists i_s in I-states | &lt;q, e&gt; = n-state^n(i_s))}
</code></pre></div></div>
<p>Naturally, this represents all the possible program states at program point <code class="language-plaintext highlighter-rouge">q</code>. Notice how it is different from the “States” set in operational semantics: it does not care about the execution trace anymore.</p>

<p>It is proved that the context vector is equal to the operational semantics: For all q in Arcs,</p>
<ol>
  <li>Cv(q) contains <em>at least</em> the environment e which is associated to q during any execution</li>
  <li>Cv(q) contains <em>only</em> the environment e which is associated to q during an execution.</li>
</ol>

<p>This static view is more suitable for analysis to be performed, which forms the foundation of abstract interpretation: replace sthe concrete <code class="language-plaintext highlighter-rouge">Context</code> with <em>abstract</em> context  that over-approximates it.</p>
<h3 id="abstract-interpretation">Abstract Interpretation</h3>

<h3 id="general-framework">General Framework</h3>

<p>We use <code class="language-plaintext highlighter-rouge">A-Cont</code> to as the abstract context which soundly over-approximates the concrete <code class="language-plaintext highlighter-rouge">Context</code>.
The set of abstract context vector can be defined as 
<code class="language-plaintext highlighter-rouge">A-CV = Arcs^0 -&gt; A-Cont</code>
(Note that the paper use <code class="language-plaintext highlighter-rouge">\tilde(A-Cont)</code> to represent abstract context but i don’t find it appealing)</p>

<p>We then can find an interpretation that works on the abstract context:
`Int: Arcs^0 times A-CV -&gt; A-Cont</p>

<p><code class="language-plaintext highlighter-rouge">Int</code> is supposed to be other-preserving. 
Using <code class="language-plaintext highlighter-rouge">Int</code>, we can find a system of equations with the program. 
<code class="language-plaintext highlighter-rouge">Int-CV :: A-CV -&gt; A-CV</code>
<code class="language-plaintext highlighter-rouge">Int-CV(CV: A-CV) = λr.Int(r,Cv)</code></p>

<p>Finally putting everything together, an general abstract interpretation of a program P is a tuple <code class="language-plaintext highlighter-rouge">I = &lt;A-Cont, ⊔, ≤, Top, Bottom, Int&gt;</code> where</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">⊔</code> The join operator on abstract context</li>
  <li><code class="language-plaintext highlighter-rouge">≤</code> The partial ordering on the abstract context</li>
</ul>

<p>What is implicit here is that the abstract context is typically designed as a complete lattice, That is, <code class="language-plaintext highlighter-rouge">x ≤ y ⇔ x ⊔ y = y</code>. This is a not drastic requirement and proved to be very handy in designing analysis. Typically in ensuring termination and efficient merge contexts by joining.</p>
<h3 id="example-data-flow-analysis">Example: Data Flow Analysis</h3>
<p><em>Available Expression</em> problem is that asks whether an expression <code class="language-plaintext highlighter-rouge">e</code> is available on arc <code class="language-plaintext highlighter-rouge">r</code>. Specifically, we want to know if <code class="language-plaintext highlighter-rouge">e</code> has been previously computed and since last computation, no argument of the expression has had its value changed.</p>

<p>The abstract context of this problem is a vector that maps all expressions to a boolean value:
<code class="language-plaintext highlighter-rouge">B-vect: Expr -&gt; { true, false }</code>
Where <code class="language-plaintext highlighter-rouge">Expr</code> is the set of expressions occurring in a program <code class="language-plaintext highlighter-rouge">P</code>.</p>

<p>The Int function follows</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>avail(r, Bv)
  let n be origin(r) within
    case n in
      Entries =&gt; λe . false
      Assignments ∪ Tests ∪ Junctions =&gt;
        λe. (generated(n)(e) 
             or ( ( ∀ p ∈ a-pred(n). Bv(p)(e) )
                  and transparent(n)(e) ))
    esac
</code></pre></div></div>

<ul>
  <li>Nothing is available at the entry nodes.</li>
  <li>An expression <code class="language-plaintext highlighter-rouge">e</code> is available if
    <ul>
      <li>e is generated on node <code class="language-plaintext highlighter-rouge">n</code> (<code class="language-plaintext highlighter-rouge">r</code> is the exit of node <code class="language-plaintext highlighter-rouge">n</code>)</li>
      <li>e is available at the predecessors of <code class="language-plaintext highlighter-rouge">n</code>  and does not been modified on node <code class="language-plaintext highlighter-rouge">n</code>.</li>
    </ul>
  </li>
</ul>

<p>The analysis is forward reasoning and terminates at the <em>maximal solution</em> of the equation systems generated by <code class="language-plaintext highlighter-rouge">avail</code>.
Maximal solution = Starts with every expression to be true.</p>
<blockquote>
  <p>But more fundamentally: maximality is <strong>with respect to the lattice ordering</strong> (here: <code class="language-plaintext highlighter-rouge">false ≤ true</code>). So the maximal solution means: among all fixpoints, we take the greatest in that ordering. It’s not just “we want precision”—it’s mathematically required by the chosen ordering.</p>
</blockquote>

<p>Why we go for the maximal solution? Considering variables in a loop. if we take the minimal solution, which starts the analysis from all variables to bottom, the variables in the loop might be always “not available”, which is sound but too preservative and not very precise. Rather, the maximum fixpoint is also sound but more precise.</p>
<h3 id="typology-of-abstract-interpretation">Typology of Abstract Interpretation</h3>

<p>There are three dimensions for abstract interpretation according to Cousot:</p>
<ul>
  <li>Using join (∪) or meet (∩) for junctions</li>
  <li>Forward (→) or backward (←) analysis</li>
  <li>Computing Maximum (↑) or Minimum (↓) fixpoints</li>
</ul>

<h2 id="consistent-abstract-interpretation">Consistent Abstract Interpretation</h2>

<p>Let $C_v$ as the concrete context vector and $C_v’$ as the abstract context vector. 
(A context vector is $Arc \times Cont$)</p>

<p>We can define two functions $\alpha: C_v \to C_v’, \gamma: C_v’ \to C_v$ as the abstraction &amp; concretization function respectively. We typically requires that:</p>
<ul>
  <li>$\forall x \in \text{A-Cont}, x=\alpha(\gamma(x))$. Concretization losses no information</li>
  <li>$\forall x\in \text{C-Cont}, x \leq \gamma(\alpha(x))$. Allowing abstraction to be only an approximation</li>
</ul>

<p>In addition, we requires following local hypothesis on the interpretation function:
\(\forall(a, x) \in Arcs \times \text{A-Cont}, \gamma(Int(a,x)) \geq Int(a, \gamma(x))\)
Which is equivalent to
\(\forall(a, x) \in Arcs \times \text{C-Cont}, Int(a, \alpha{(x)}) \geq \alpha(Int(a, x))\)
Or, is equivalent to following picture:</p>

<p><img src="/assets/images/Pasted%20image%2020250916142333.png" alt="" /></p>

<p>This allows the interpretation to be sound. i.e. The abstract context always over-approximates the concrete one.</p>

<h2 id="the-lattice-of-abstract-interpretation">The lattice of Abstract Interpretation</h2>
<p>For the concrete context of integers. $I_{SS} = Pow(\mathbb{Z})$, we might have abstract interpretations:</p>
<ul>
  <li>(Intervals $I_I$) $\alpha(S) = [min(a), max(b)]$
Which can be further abstracted as</li>
  <li>(Constant Propagation a $I_{CP}$) $\alpha([a, b]) =$  if $a=b$ then $a$ else $\top$; or</li>
  <li>(Rules of Signs $I_{RS}$) $\alpha([a, b]) =$ if $a \gt 0$ then $+$ elif $b \lt 0$ then $-$ else $\pm$; or</li>
  <li>(Constants + Signs $I_{CS}$) $\alpha([a, b]) =$ if $a = b$ then a elif $a \geq 0$ then $+$ elif $b \leq 0$ then $-$ else $\pm$</li>
  <li>(Reachability $I_R$) $\alpha(i)=$ if $i \neq \bot$ then $\top$ else $\bot$</li>
</ul>

<p>The context of $I_{CS}$ looks like this:
<img src="/assets/images/IMG_2390.jpeg" alt="" /></p>

<p>These interpretation forms a lattice themselves. For example, the interpretations we mentioned can formed a lattice like this: 
<img src="/assets/images/IMG_2391.jpeg" alt="" />
(Actually, $I_R$ is not the bottom as we can find a trivial interpretation that the context lattice is only a single bottom)</p>

<p>If $I_a \gt I_b$, it is generally that $I_a$ is more precise but more computationally expensive.
For example, $I_R$ can only detects if a variable is reachable, but would it’s pretty fast on detect unused variables. 
So the choice of abstraction level really depends on the analysis task.</p>

<h2 id="abstract-evaluation-of-programs">Abstract Evaluation of Programs</h2>

<p>This section briefly mentions the correctness, termination and efficiency proofs of abstract interpretations in related works. If I’m going to do formal correctness proofs then I might go back to this section but now it is interested to me.</p>

<h2 id="fixpoints-approximation-methods">Fixpoints Approximation Methods</h2>

<p>The sequence of a program’s context is modeled as an ascending Kleen’s sequence:
\(Int^n(\bot)\)
We typically require $Int$ is designed in such a way this sequence to be not strictly increasing. In particular, through making it order-preserving on the lattice of context. 
Then an AE terminates when one fixpoint is reached. But this can be slow.</p>

<p>Techniques to approximate the fixpoint can improve. By <em>approximate</em> we mean the AE should satisfies this correctness property:
\(\forall n \geq 0,\;
C = \widetilde{\text{Int}}^{\,n}(\bot)
\;\wedge\;
\neg\bigl(\text{Int}(C) \sqsubseteq C \bigr)
\;\;\Longrightarrow\;\;
C \circ \text{Int}(C) \;\sqsubseteq\; \widetilde{\text{Int}}(C).\)
Where $\widetilde{\text{Int}}$ is the approximated interpretation and $\text{Int}$ is the original interpretation. The $\circ$ is the join operator $\sqcup$.</p>

<p>Note: I would argue the condition <code class="language-plaintext highlighter-rouge">not (Int(C) &lt;= C)</code> is not necessary. But it is rather used for loosen the condition: it only put requirement on the approximated interpretation <em>when the fixpoint has not been reached</em>. Because after a fixpoint is reached, AE stops naturally.</p>
<h3 id="widening">Widening</h3>
<p><em>Widening</em> is a technique that accelerates the convergence by approximation.
A widening $\nabla: ACont \times ACont \to ACont$ is a binary operator such that</p>
<ul>
  <li>$\forall (C, C’) \in ACont^2, C \nabla C’ \ge C \sqcup C’$</li>
  <li>With arbitrary sequence $C_i$ of $ACont$, The sequence is not strictly increasing:
  $x_{0}, \quad x_{1} = x_0 \nabla C_0, \quad x_{2} = x_1 \nabla C_1, \quad \dots$</li>
</ul>

<p>The first one ensures widening “goes up” on the lattice. I found it more intuitive to explain why is that going “up” in the context lattice always safely over-approximates the concrete context but goes “down” might lose soundness.</p>

<p>The second one is also for termination of course.</p>

<p>We also labels the arc which has been performed widening by adding them into the $\text{W-Arcs}$ set.</p>

<p>Finally, the approximated interpretation is:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A-Int q, Cv = if q in W-Arcs then
  Cv(q) ∇ Int(q, Cv)
else
  Int(q, Cv)
fi
</code></pre></div></div>

<p>They proved that the correctness property (at the beginning of this section) is satisfied.</p>

<p>Note that the two requirements of widening does not limit how precise the operator ∇ is designed. An extreme but valid one is simply <code class="language-plaintext highlighter-rouge">∇ _ _ = top</code>, but this will produce very imprecise over-approximation. So also we try to be as precise as possible.</p>
<h3 id="narrowing">Narrowing</h3>
<p>Widening produces an upper bound $S_m = \widetilde{\text{A-Int}}^m(\bot)$ of the least fixpoint of the (un-approximated) interpretation $C_v = \widetilde{\text{Int}}^n(\bot)$. i.e. $S_m \ge C_v$. If $S_m$ is not a fixpoint of $\text{Int}$, we might want to find a better approximation $C_v \leq S’_m \leq S_m$. 
(For notation: $\widetilde{\text{Int}}$ is the whole program interpretation and $\widetilde{\text{A-Int}}$ is modified from  $\widetilde{\text{Int}}$  by adding widening)</p>

<p>A binary operator <code class="language-plaintext highlighter-rouge">△: A-Cont × A-Cont → A-Cont</code> is a <em>narrowing</em> if it satisfies two requirements:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">∀ (C, C') ⋿ A-Cont ⨉ A-Cont, { C ≥ C} → { C ≥ C △ C' ≥ C' } </code></li>
  <li>For any arbitrary sequence <code class="language-plaintext highlighter-rouge">C0, C1, ... Cn, ...</code>, the infinite sequence <code class="language-plaintext highlighter-rouge">S(0) = C0, S(n) = S(n-1) △ Cn</code> is not strictly decreasing.</li>
</ul>

<p>And we can modify the interpretation as:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>D-Int q Cv = 
	if q in W-arcs then
		Cv(q) △ Int(q, Cv)
	else
		Int(q, Cv)
	fi
</code></pre></div></div>

<h4 id="mathematical-intuition-of-narrowing">Mathematical Intuition of Narrowing</h4>
<p>The second requirement of narrowing is straightforward: we want to ensure termination of the <code class="language-plaintext highlighter-rouge">D-Int</code> function. But the first one is a bit random at the first glance. I want to take a note here to explain it.</p>

<p>Remember $S_m$ is produced by the approximated interpretation ($\widetilde{\text{Int}}$ with widening), then $S_m$ is no less than  $C_v$, the least fixpoint of  $\widetilde{\text{Int}}$. We have $\widetilde{\text{Int}}(S_m) \leq S_m$ since  $\widetilde{\text{Int}}$ is required to be order-preserving.
And therefore we can construct a descending sequence:
\(\text{DKS}: S_m \ge \widetilde{\text{Int}}(S_m) \ge \widetilde{\text{Int}}^2(S_m) \ge \dots \ge \widetilde{\text{Int}}^n(S_m) \ge C_v\)
So the limit of $\widetilde{\text{Int}^i}(S_m), \forall i \in \mathbb{N}$ is sure a better approximation of $C_v$. A naive approach is to repeatedly applying $\widetilde{\text{Int}}$. But we face a same problem as widening: DKS can be computationally expensive to converge; Or it might be an infinite sequence. So it is practical to soundly truncate the sequence.</p>

<p>From step n, the most ideal truncate point <code class="language-plaintext highlighter-rouge">D</code> might satisfies
\(\widetilde{\text{Int}}^{n+1}(S_m) \gt D \ge C_v \tag{CoT'}\)
However, we do not know $C_v$ in the practice. Hence this condition gives little information about how to choose a $D$. 
So we have to modify the correctness of truncate as
\(\widetilde{\text{Int}}^{n+1}(S_m) \gt D \ge \widetilde{\text{Int}}(D) \tag{CoT}\)
It is sound to replace $C_v$ because it is the least fixpoint and interpretation is order-preserving.<br />
This is where the first condition comes from: The <code class="language-plaintext highlighter-rouge">D-Int</code> satisfies CoT by case analysis: when <code class="language-plaintext highlighter-rouge">q ⋿ W-arcs</code>, applying the first requirement get us CoT; otherwise, CoT trivially holds because interpretation is order-preserving.</p>

<h2 id="references">References</h2>

<p>^[1]: Cousot, Patrick, and Radhia Cousot. “Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints.” <em>Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages  - POPL ’77</em>, ACM Press, 1977, 238–52. <a href="https://doi.org/10.1145/512950.512973">https://doi.org/10.1145/512950.512973</a></p>

<p>^[2]: Floyd, Robert W. “Assigning meanings to programs.” <em>Program Verification: Fundamental Issues in Computer Science</em>. Dordrecht: Springer Netherlands, 1993. 65-81.</p>]]></content><author><name>Chew Y. Feng</name></author><category term="PL" /><category term="PL" /><summary type="html"><![CDATA[A note on Cousot POPL'77 Foundational Paper.]]></summary></entry><entry><title type="html">An Abstract Interpretor Based on Compositional Semantics</title><link href="/pl/2025/06/18/an-abstract-interpreter.html" rel="alternate" type="text/html" title="An Abstract Interpretor Based on Compositional Semantics" /><published>2025-06-18T00:00:00+00:00</published><updated>2025-06-20T06:16:08+00:00</updated><id>/pl/2025/06/18/an-abstract-interpreter</id><content type="html" xml:base="/pl/2025/06/18/an-abstract-interpreter.html"><![CDATA[<object data="/pdfs/abstract-interpreter-compositional-semantics/main.pdf" width="1000" height="1000" type="application/pdf"></object>]]></content><author><name>Chew Y. Feng</name></author><category term="PL" /><category term="PL" /><summary type="html"><![CDATA[A study note on Rival's Textbook.]]></summary></entry><entry><title type="html">WSL – File System, Networking, Configuration</title><link href="/os/2025/02/22/WSL-FS-Network-Conf.html" rel="alternate" type="text/html" title="WSL – File System, Networking, Configuration" /><published>2025-02-22T00:00:00+00:00</published><updated>2025-02-25T00:37:25+00:00</updated><id>/os/2025/02/22/WSL-FS-Network-Conf</id><content type="html" xml:base="/os/2025/02/22/WSL-FS-Network-Conf.html"><![CDATA[<h2 id="background">Background</h2>

<p>I’m a Windows user, and Windows Subsystem Linux (WSL) is the most frequent tool I need to use. 
I use WSL primarily for coding and dev, while Windows for entertaining.
My goal is <strong>not installing anything related to coding in Windows</strong>.
However, I find that I have little knowledge about how it works.
It sometimes makes me confused. 
So I decided to spend sometime and take a note about it.</p>

<h2 id="overview">Overview</h2>

<p>WSL 2 uses virtualization to run a Linux kernel inside a VM.
WSL 2 features</p>
<ul>
  <li>Faster File IO</li>
  <li>Full System Call Compatibility
      This allows full access to Linux apps like Docker (why)</li>
</ul>

<p>Architecture Change from WSL 1</p>
<ul>
  <li>WSLv1 uses a translation-based approach, which translates a Linux system call to Windows kernel. 
      This approach can be less compatible because system calls in win and Linux can have different semantics. 
      It also slows down the IO speed somehow.</li>
  <li>WSLv2 is VM-based approach. It has a full Linux kernel.</li>
</ul>

<h2 id="working-with-file-system">Working with File System</h2>

<p>You can run Linux tools from a Windows Command Line</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#powershell</span>
wsl <span class="nb">ls</span> <span class="nt">-la</span>
wsl <span class="nb">ls</span> <span class="nt">-la</span> <span class="s2">"/mnt/c/Program Files"</span> <span class="c"># note that you need to use linux file path  </span>
</code></pre></div></div>

<p>You can also run Windows tools in WSL by <code class="language-plaintext highlighter-rouge">[tool-name].exe</code></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#bash</span>
ipconfig.exe | <span class="nb">grep </span>IPv4 | <span class="nb">cut</span> <span class="nt">-d</span>: <span class="nt">-f2</span>
</code></pre></div></div>

<h2 id="configuration">Configuration</h2>

<p>WSL allows user providing a configuration file <code class="language-plaintext highlighter-rouge">%UserProfile%/.wslconfig</code>. 
See <a href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config#main-wsl-settings">Main WSL Settings</a> for the full configuration table.</p>

<p>By the way, I prefer using WSL setting app for config.</p>

<h2 id="networking-consideration">Networking Consideration</h2>

<p>Currently, WSL2 offers two modes of networking: NAT and Mirrored.</p>

<h3 id="nat-mode">NAT Mode</h3>

<p>NAT Mode means that WSL is running in a <strong>virtualized network environment</strong> where it is assigned with a <strong>private IP address</strong>, and Windows serves as the adapter.</p>

<p><strong>Accessing Internet from WSL</strong></p>

<p>WSL runs on NAT mode implies that Windows serves as the adapter, rewriting request from WSL with its IP.</p>

<p>Try this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; wsl curl 'https://api.ipify.org?format=json'
&gt; curl 'https://api.ipify.org?format=json'
</code></pre></div></div>

<p>The API simply returns the IP of the client. 
You can see that both are identical and is the IP address of the Windows.</p>

<p>Another experiment is that, you can trace network packets:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>traceroute google.com <span class="c"># On wsl</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tracert google.com <span class="c"># On wsl</span>
</code></pre></div></div>

<p>You will find that both are identical <strong>except there is one more jump from WSL to Windows</strong></p>

<p><strong>Accessing WSL from Windows</strong></p>

<p>On Windows, you can access networking apps in WSL using localhost. There is an auto-forwarding feature working:</p>

<p><img src="/assets/images/Pasted%20image%2020250222170500.png" alt="Experiment: Accessing WSL Networking application " /></p>

<p>You can also access networking apps by using the assigned IP address of WSL.</p>

<p>The Windows host can use this command to query the IP address</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">&gt;</span><span class="w"> </span><span class="n">wsl</span><span class="w"> </span><span class="nt">-d</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">DistributionName</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">hostname</span><span class="w"> </span><span class="nt">-I</span><span class="w">
</span></code></pre></div></div>

<p><strong>Accessing WSL from LAN</strong></p>

<p>To enable devices on your LAN to access WSL, it needs proper proxy setup. See <a href="https://learn.microsoft.com/en-us/windows/wsl/networking#accessing-a-wsl-2-distribution-from-your-local-area-network-lan">Accessing a WSL 2 distribution from your local area network (LAN)</a></p>

<h3 id="mirrored-networking-mode">Mirrored Networking Mode</h3>

<p>In mirrored mode, WSL works as <strong>if they are the same machine in network</strong>. Benefits are:</p>
<ul>
  <li>IPv6 Support</li>
  <li>Connect to Windows servers from within Linux using the localhost address <code class="language-plaintext highlighter-rouge">127.0.0.1</code>.</li>
  <li>Improved networking compatibility for VPNs</li>
  <li>Connect to WSL directly from your local area network (LAN)</li>
</ul>

<p>It implies that both Windows and WSL Apps connect to the same physical network of the Windows host.</p>

<p>The VM “mirrors” all network settings from Windows.</p>

<p>This can be validate by tracing network parcels:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># on WSL
traceroute google.com
</code></pre></div></div>

<p>You will find there is not a jump to Windows host.</p>

<p>The only thing we know about the implementation is that it utilizes Hyper-V virtual switch feature. 
MS do not share more detailed information about it.</p>

<h2 id="mounting-a-device">Mounting a Device</h2>

<blockquote>
  <p>Shout out to [https://askubuntu.com/questions/1116200/how-can-i-access-my-usb-drive-from-my-windows-subsystem-for-linux-ubuntu-dist]</p>
</blockquote>

<p>Suppose there is a new USB device mounted on G: on windows. 
To access it on WSL:</p>

<ol>
  <li>Create the mount point: <code class="language-plaintext highlighter-rouge">mkdir /mnt/g</code></li>
  <li>Mount the drive to the directory using <code class="language-plaintext highlighter-rouge">sudo mount -t drvfs G: /mnt/g</code></li>
</ol>

<h1 id="references">References</h1>
<ol>
  <li>MS WSL Doc https://learn.microsoft.com/en-us/windows/wsl/about</li>
  <li>Intro to WSL2 Video https://youtu.be/MrZolfGm8Zk?si=pRhVjzF84i49Zoqi</li>
</ol>]]></content><author><name>Chew Y. Feng</name></author><category term="OS" /><category term="OS" /><summary type="html"><![CDATA[My story with Linux subsystem.]]></summary></entry><entry><title type="html">Simply Typed Lambda-Calculus</title><link href="/software-foundations/2024/07/18/Simple-Typed-Lambda-Calculus.html" rel="alternate" type="text/html" title="Simply Typed Lambda-Calculus" /><published>2024-07-18T00:00:00+00:00</published><updated>2024-07-18T07:28:57+00:00</updated><id>/software-foundations/2024/07/18/Simple-Typed-Lambda-Calculus</id><content type="html" xml:base="/software-foundations/2024/07/18/Simple-Typed-Lambda-Calculus.html"><![CDATA[<p>This article is a study note of <a href="https://softwarefoundations.cis.upenn.edu/plf-current/Stlc.html">Programming Language Foundation</a></p>

<h2 id="overview">Overview</h2>

<p>The simply typed lambda calculus (STLC) is a wonderful study target which represents many intriguing language features among modern programming language.</p>

<p>Lambda calculus (also written as λ-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution (From Wikipedia).</p>

<p>Consider a lambda-calculus system that only contains Boolean values, which can be expressed by following BNF notation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>t ::= x                      (variable)
 | \x:T,t                    (abstraction)
 | t t                       (application)
 | true                      (constant true)
 | false                     (constant false)
 | if t then t else t        (conditional)
</code></pre></div></div>

<p>Examples:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">\</span><span class="n">x</span><span class="o">:</span> <span class="n">Bool</span><span class="p">,</span> <span class="n">x</span> <span class="c1">// identity function</span>
<span class="p">(</span><span class="err">\</span><span class="n">x</span><span class="o">:</span> <span class="n">Bool</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="nb">true</span> <span class="c1">// apply the identity function to value true</span>
<span class="err">\</span><span class="n">x</span><span class="o">:</span><span class="n">Bool</span><span class="p">,</span><span class="err"> </span><span class="k">if</span><span class="err"> </span><span class="n">x</span><span class="err"> </span><span class="n">then</span><span class="err"> </span><span class="nb">false</span><span class="err"> </span><span class="k">else</span><span class="err"> </span><span class="nb">true</span> <span class="c1">// function 'not'</span>
<span class="err">\</span><span class="n">f</span><span class="o">:</span><span class="n">Bool</span><span class="err">→</span><span class="n">Bool</span><span class="p">,</span><span class="err"> </span><span class="n">f</span><span class="err"> </span><span class="p">(</span><span class="n">f</span><span class="err"> </span><span class="nb">true</span><span class="p">)</span> <span class="c1">// a higher order function</span>
</code></pre></div></div>

<p>Although it only contains Boolean values, it processes the computation ability that equivalent any modern programming languages. It even supports higher order function that some “modern” languages don’t support well, like C and C++.</p>

<p>Note that there are variables involved in the definition. A <em>complete</em> program is a program that never refer to any undefined variables. In most time, we want the program to be complete and we can simply fail there are free variables (which doesn’t bind to any terms and types).</p>
<h2 id="operational-semantics">Operational Semantics</h2>

<h3 id="values">Values</h3>

<p>To decide what are the <em>values</em> of STLC, a little discussion is needed on the case of abstraction. An abstraction (similar to a “function” in imperative programming language) is of such form</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\x:T, t
</code></pre></div></div>

<p>There are two choices:</p>
<ol>
  <li>An abstraction is always a value</li>
  <li>An abstraction is a value if <code class="language-plaintext highlighter-rouge">t</code> is a value</li>
</ol>

<p>I would say I prefer option 1, and that is the choice in the textbook, because it makes things a lot easier. But option 2 is also the choice for some language, for some reasons like compile-time optimization.</p>

<h3 id="substitution">Substitution</h3>

<p>The heart of lambda calculus is substitution. For example, we reduce</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> (\x:Bool, if x then true else x) false
</code></pre></div></div>

<p>to</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if false then true else false
</code></pre></div></div>

<p>The application works by substitute <code class="language-plaintext highlighter-rouge">\x</code> into the bind value <code class="language-plaintext highlighter-rouge">false</code>. We mark the substitution as <code class="language-plaintext highlighter-rouge">[x:=s]t</code>, which literally says “substitute all occurrences of <code class="language-plaintext highlighter-rouge">x</code> into <code class="language-plaintext highlighter-rouge">s</code> in the term <code class="language-plaintext highlighter-rouge">t</code>”.</p>

<p>More example:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">[x:=true] (if x then x else y)</code> yields <code class="language-plaintext highlighter-rouge">if true then true else y</code></li>
  <li><code class="language-plaintext highlighter-rouge">[x:=true](\y:Bool,x)</code> yields <code class="language-plaintext highlighter-rouge">\y:Bool,true</code></li>
</ul>

<p>Substitution is a deterministic and easy problem (i.e. not a NP-hard one). So the textbook simply encoded substitution into a fixpoint function <code class="language-plaintext highlighter-rouge">subst</code>. It’s very interesting to think how a powerful computation model is just such a small substitution machine.</p>

<p>Exercise: 3 stars, standard (substi_correct)
This Exercise asks us to define substitution as a inductive relation <code class="language-plaintext highlighter-rouge">substi</code> , and prove the relation is equivalent to the fixpoint version.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">substi</span><span class="w"> </span><span class="o">(</span><span class="no">s</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kr">Prop</span><span class="w">

</span><span class="k">Theorem</span><span class="w"> </span><span class="no">substi_correct</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="no">t'</span><span class="o">,</span><span class="w">
  </span><span class="o">&lt;{</span><span class="w"> </span><span class="o">[</span><span class="no">x</span><span class="p">:</span><span class="o">=</span><span class="no">s</span><span class="o">]</span><span class="no">t</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">t'</span><span class="w"> </span><span class="o">&lt;-&gt;</span><span class="w"> </span><span class="no">substi</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="no">t'</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>For direction <code class="language-plaintext highlighter-rouge">-&gt;</code>, it can be proved by induction on term <code class="language-plaintext highlighter-rouge">t</code></li>
  <li>For direction <code class="language-plaintext highlighter-rouge">&lt;-</code>, it can be proved by induction on relation <code class="language-plaintext highlighter-rouge">substi</code></li>
</ul>

<h3 id="reduction">Reduction</h3>

<p>Based on substitution, we can define how an expression is <em>reduced</em> to value. The core of reduction is the application rule, which says</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(\x:T,t) v --&gt; [x:=v] t
</code></pre></div></div>

<p>To make the process of reduction to be deterministic, we made a design: 
<strong>Apply reduction of application expression only if both the left-hand side (the abstraction) and the right-hand side (the argument) is a value.</strong></p>

<h2 id="typing">Typing</h2>

<p>The STLC has a powerful feature – typing, which becomes more and more important in programming language design. For some reasons, computer scientists write typing relation as following form:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|-- t \in T
</code></pre></div></div>

<p>which says that “term t has type T”.</p>

<p>An obvious problem is typing abstractions. Consider such abstraction:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\x:T1, t2
</code></pre></div></div>

<p>which has type <code class="language-plaintext highlighter-rouge">T1 -&gt; T2</code>. If we want to typecheck it, we need to make sure term <code class="language-plaintext highlighter-rouge">t2</code> has type <code class="language-plaintext highlighter-rouge">T2</code> <strong>under the context that <code class="language-plaintext highlighter-rouge">x</code> has type <code class="language-plaintext highlighter-rouge">T1</code>.</strong></p>

<p>Context can be represented as a single global information, which adds to the typing relation. A map (partial-map) is capable of representing such information, which we name it <em>Gamma</em>. The new typing judgment is written <code class="language-plaintext highlighter-rouge">Gamma |-- t \in T</code> and informally read as “term t has type T, given the types of free variables in t as specified by Gamma”.</p>

<p>Examples:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Example</span><span class="w"> </span><span class="no">typing_example_1</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="no">empty</span><span class="w"> </span><span class="o">|--</span><span class="w"> </span><span class="err">\</span><span class="no">x</span><span class="p">:</span><span class="no">Bool</span><span class="o">,</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="err">\</span><span class="kr">in</span><span class="w"> </span><span class="o">(</span><span class="no">Bool</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">Bool</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>Finally, we present the typing rule of abstraction:</p>

<p>\(\frac{x \mapsto T2 ; \Gamma \vdash t1 \in T1}{
\Gamma \vdash \backslash x:T2,t1 \in T2\to T1
}\)
Other rules can be found in the textbook as well.</p>

<p>Talking about variables, a term is <em>closed</em> if all variables in it are well typed (contain no free variables).</p>

<h2 id="properties-of-stlc">Properties of STLC</h2>

<p>We discuss what makes the language to be “well and sound”.</p>

<h3 id="canonical-form">Canonical Form</h3>

<p>We can establish the relation between well-typed values (canonical form)  and their type. For example, if a value has type <code class="language-plaintext highlighter-rouge">Bool</code>, it must be a <code class="language-plaintext highlighter-rouge">false</code> or <code class="language-plaintext highlighter-rouge">true</code>.</p>
<h3 id="progress">Progress</h3>

<p>The progress theorem tells us that closed, well-typed terms are not stuck: either a well-typed term is a value, or it can take a reduction step.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">progress</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="no">T</span><span class="o">,</span><span class="w">
  </span><span class="no">empty</span><span class="w"> </span><span class="o">|--</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="err">\</span><span class="kr">in</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="p">→</span><span class="w">
  </span><span class="no">value</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="o">\/</span><span class="w"> </span><span class="p">∃</span><span class="w"> </span><span class="no">t'</span><span class="o">,</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="no">t'</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>Exercise: 3 stars, advanced (progress_from_term_ind).</p>

<p>It asks us to prove theorem <code class="language-plaintext highlighter-rouge">progess</code> by induction on terms. The proof is a bit long but not complicated. Just follow the reduction rules to see if it can make a step, or it is a value, or there is a contradiction in hypothesis.</p>

<h3 id="preservation">Preservation</h3>

<p>The preservation theorem says reduction doesn’t change the type of a term (so it <em>preserves</em> the type). This property shows our typing is indeed sound and well-fitted into the operational semantics.</p>

<p>To establish the preservation property on STLC, we take a few steps:</p>
<ol>
  <li>The Weakening Lemma, which says if <code class="language-plaintext highlighter-rouge">t</code> has type <code class="language-plaintext highlighter-rouge">T</code> in some context <code class="language-plaintext highlighter-rouge">Gamma</code>and  <code class="language-plaintext highlighter-rouge">Gamma</code> is included in a bigger context <code class="language-plaintext highlighter-rouge">Gamma'</code>, t also has type <code class="language-plaintext highlighter-rouge">T</code> in <code class="language-plaintext highlighter-rouge">Gamma'</code>.
 To prove this, one need to consider what “a context is included in other context” means. But it’s fairly straightforward.</li>
  <li>The Substitution Lemma, which says substitution preserves the type.</li>
  <li>The main theorem. With the help of substitution lemma, it can be proved with ease.</li>
</ol>

<p>Exercise: 3 stars, advanced (substitution_preserves_typing_from_typing_ind)
It asks us to prove the substitution lemma, which lies at the heart of this proof chain. A few tips:</p>
<ul>
  <li>Read carefully about the informal proof provided by the author.</li>
  <li>When encounter <code class="language-plaintext highlighter-rouge">(x =? y)%string</code> (string equality), use <code class="language-plaintext highlighter-rouge">destruct eqb_spec</code> to perform case analysis.</li>
  <li>When the goal is the form <code class="language-plaintext highlighter-rouge">Gamma |-- t \in T</code>, you can use the weakening lemma to transform it to <code class="language-plaintext highlighter-rouge">empty |-- t \in t</code>.</li>
</ul>

<p>Exercise: 2 stars, standard, especially useful (subject_expansion_stlc)
Show that the reverse to preservation theorem does not hold. That is, if <code class="language-plaintext highlighter-rouge">t --&gt; t'</code> and <code class="language-plaintext highlighter-rouge">t' \in T</code>, we can not make sure <code class="language-plaintext highlighter-rouge">t \in T</code>.
I exploit the fact that reduction doesn’t type check.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(* t *) exists &lt;{ (\x: Bool -&gt; Bool, x) true }&gt;.
(* t'*) exists &lt;{ true }&gt;.
(* T *) exists &lt;{ Bool }&gt;.
</code></pre></div></div>
<p>It’s a little bit cheating, I admit. But I can’t find a better one.</p>
<h3 id="type-soundness">Type Soundness</h3>

<p>Put progress and preservation together, we can show that a well-typed term can <em>never</em> reach a stuck state.</p>

<p>Exercise: 2 stars, standard, optional (type_soundness)
Type soundness can be proved by induction on Hmulti (<code class="language-plaintext highlighter-rouge">t --&gt;* t'</code>).</p>

<h3 id="uniqueness-of-types">Uniqueness of Types</h3>

<p>Another nice property of the STLC is that types are unique: a given term (in a given context) has at most one type.</p>

<p>Exercise: 3 stars, standard (unique_types)
This exercise can be solved by induction on term <code class="language-plaintext highlighter-rouge">e</code>. The whole proof heavily use inversion to do case analysis.</p>

<h2 id="extension-to-stlc">Extension to STLC</h2>

<p>One might argue that the current STLC is still too simple and cannot match a real modern programming language. Well, there are a lot of extensions to STLC in the textbook to show the possibility of the language.</p>

<ul>
  <li>Numbers.</li>
  <li>Let bindings, which adds the let expression like those in Haskell.</li>
  <li>Pairs, which are popular in many languages. For example, I can have a pair of <code class="language-plaintext highlighter-rouge">(1, false)</code> of type <code class="language-plaintext highlighter-rouge">(Nat, Bool)</code></li>
  <li>Unit. A unit type is a type that only has one value. It can be quite helpful to express things like <code class="language-plaintext highlighter-rouge">null</code>, <code class="language-plaintext highlighter-rouge">nullptr</code></li>
  <li>Sums. A sum is like the <code class="language-plaintext highlighter-rouge">Either</code> monads In Haskell.</li>
  <li>Lists.</li>
  <li>Recursion (Recursive Abstraction)</li>
  <li>Records. Like dictionary in python.</li>
</ul>

<p>The exercises in this chapter is to formalize these features, including the substitution, reduction and typing. I would say it is quite straightforward to follow the informal definition given by the author, and satisfying to see how it works.</p>]]></content><author><name>Chew Y. Feng</name></author><category term="Software-Foundations" /><category term="Coq" /><category term="PLT" /><summary type="html"><![CDATA[A small yet powerful language]]></summary></entry><entry><title type="html">Small-Step Operational Semantics</title><link href="/software-foundations/2024/06/22/Small-Steps.html" rel="alternate" type="text/html" title="Small-Step Operational Semantics" /><published>2024-06-22T00:00:00+00:00</published><updated>2024-06-22T05:27:12+00:00</updated><id>/software-foundations/2024/06/22/Small-Steps</id><content type="html" xml:base="/software-foundations/2024/06/22/Small-Steps.html"><![CDATA[<p>Even if I have walked through all the content and practices in the <a href="https://softwarefoundations.cis.upenn.edu/plf-current/Smallstep.html">textbook</a>, it still confuses me about what “Small-Step Operational Semantics” is. It is partly because the study of the chapter is segmented into pieces because I have to only use my free time to do it. It also because this chapter is way too long such that one can’t get to the important points immediately.</p>

<h2 id="small-step-semantics">Small-step Semantics</h2>

<p><em>Small-step</em> means the evaluation of the semantics from the program can be carried out step-by-step. Some would also describe it as “structural operational semantics” because the the method usually follows the structure of programs. It might takes multiple steps to get the final semantics of a statement. Conversely, <em>natural semantics</em> directly evaluate a statement to the final state, which can be steadily implemented in a evaluation function.</p>

<p>For example, given the statement</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(1 + 3) + (2 + 4)
</code></pre></div></div>

<p>It might takes multiple steps to get the semantics:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(4) + (2 + 4)
(4) + (6)
10 &lt;-- final semantics
</code></pre></div></div>

<p>There are two reasons (the textbook gives) to recommend small-step semantics instead of natural semantics.</p>
<ul>
  <li>We includes the intermediate states that it passes through along the way. Observable execution is critical in many situation.</li>
  <li>By only define one-step evaluation, we allow <em>undefined behaviours</em> in the program.</li>
</ul>

<h2 id="implementation-comparison">Implementation Comparison</h2>

<p>Compared to natural semantics, the implementation of small-step would be more complicated – a single function can’t suffice. Fortunately we are doing this in Coq, which has a very power tool  – Inductive type.</p>

<p>In the most naïve language where there are only constant (denotes by C) and addition (denotes by P), the informal semantics are:</p>

\[\frac{}{C~n \to n}\]

\[\frac{t_1 \to n_1,~t_2\to n_2}{P~t_1~t_2 \to n_1 + n_2}\]

<p>The formal semantics can be encoded in Coq:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">C</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="c">(* Constant *)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">tm</span><span class="pi">.</span><span class="w"> </span><span class="c">(* Plus *)</span><span class="w">
</span></code></pre></div></div>

<p>The natural semantics is a function defined in a very straightforward way</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Fixpoint</span><span class="w"> </span><span class="no">evalF</span><span class="w"> </span><span class="o">(</span><span class="no">t</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">C</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">n</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="no">t2</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">evalF</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">evalF</span><span class="w"> </span><span class="no">t2</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>This evaluation function can easily handle statement such as:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">C 3</code></li>
  <li><code class="language-plaintext highlighter-rouge">P (C 3) (C 5)</code></li>
  <li><code class="language-plaintext highlighter-rouge">P (C 3) (P (C 2) (C 3))</code></li>
</ul>

<p>Conversely, the small step semantics involves a inductive relation describing how to take a step forward:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">step</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">ST_PlusConstConst</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">n1</span><span class="w"> </span><span class="no">n2</span><span class="o">,</span><span class="w">
      </span><span class="no">P</span><span class="w"> </span><span class="o">(</span><span class="no">C</span><span class="w"> </span><span class="no">n1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">C</span><span class="w"> </span><span class="no">n2</span><span class="o">)</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="no">C</span><span class="w"> </span><span class="o">(</span><span class="no">n1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">n2</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">ST_Plus1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="no">t1'</span><span class="w"> </span><span class="no">t2</span><span class="o">,</span><span class="w">
      </span><span class="no">t1</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="no">t1'</span><span class="w"> </span><span class="p">→</span><span class="w">
      </span><span class="no">P</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="no">t2</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">t1'</span><span class="w"> </span><span class="no">t2</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">ST_Plus2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">n1</span><span class="w"> </span><span class="no">t2</span><span class="w"> </span><span class="no">t2'</span><span class="o">,</span><span class="w">
      </span><span class="no">t2</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="no">t2'</span><span class="w"> </span><span class="p">→</span><span class="w">
      </span><span class="no">P</span><span class="w"> </span><span class="o">(</span><span class="no">C</span><span class="w"> </span><span class="no">n1</span><span class="o">)</span><span class="w"> </span><span class="no">t2</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="o">(</span><span class="no">C</span><span class="w"> </span><span class="no">n1</span><span class="o">)</span><span class="w"> </span><span class="no">t2'</span><span class="w">

  </span><span class="no">where</span><span class="w"> </span><span class="s2">" t '--&gt;' t' "</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">step</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="no">t'</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>And another inductive relation which defines a multi step evaluation as multiple consecutive single-step evaluations:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">multi</span><span class="w"> </span><span class="o">{</span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">R</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">relation</span><span class="w"> </span><span class="no">X</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">relation</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">multi_refl</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">X</span><span class="o">),</span><span class="w"> </span><span class="no">multi</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">x</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">multi_step</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">X</span><span class="o">),</span><span class="w">
                    </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="p">→</span><span class="w">
                    </span><span class="no">multi</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="w"> </span><span class="p">→</span><span class="w">
                    </span><span class="no">multi</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">z</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>This example shows the difference. You can clearly see that small-step semantics is quite complicated compared to natural semantics, which is only a function.</p>

<h2 id="properties-of-small-step-semantics">Properties of Small-step Semantics</h2>

<h3 id="deterministic">Deterministic</h3>

<p>Firstly, given two same programs, the semantics that we found should be identical. In other word, there should be no randomness get in the way for this tiny toy language. This property is called <em>deterministic</em>.</p>

<p><strong>Deterministic Property</strong>: “for each t, there is at most one t’ such that t steps to t’ (t –&gt; t’ is provable).”</p>

<p>It sounds intuitive but the proof is not so straightforward. Readers can check the textbook <code class="language-plaintext highlighter-rouge">Theorem step_deterministic</code> if interested.</p>
<h3 id="values">Values</h3>

<p>There is a slight problem. When dealing with expressions such as</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P (P (C 1) (C 3)) (P (C 2) (C 4))
</code></pre></div></div>

<p>There are actually two directions to step forward: – either handle 1 + 3 or 2 + 4, which results in different intermediate states. This is not we typically want and sometimes causes trouble.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">P</span> <span class="p">(</span><span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">4</span><span class="p">))</span>
<span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">4</span><span class="p">))</span>
<span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">6</span><span class="p">)</span>
<span class="kt">C</span> <span class="mi">10</span>
<span class="c1">-- or</span>
<span class="kt">P</span> <span class="p">(</span><span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">4</span><span class="p">))</span>
<span class="kt">P</span> <span class="p">(</span><span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">6</span><span class="p">)</span>
<span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">6</span><span class="p">)</span>
<span class="kt">C</span> <span class="mi">10</span>
</code></pre></div></div>

<p>This problem can be solved by defining <em>values</em>. We always want the final term to be some special forms, which we called <em>values</em>. In this language, we expect the final semantics to some constant terms.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">v_const</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">n</span><span class="o">,</span><span class="w"> </span><span class="no">value</span><span class="w"> </span><span class="o">(</span><span class="no">C</span><span class="w"> </span><span class="no">n</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>With the concepts of value, we revise the definition of steps:</p>

\[\frac{t_1 \to t_1',}{P~t_1~t_2 \to P~t_1'~t_2}\]

\[\frac{\text{value}~t_1,~t_2\to t_2'}{P~t_1~t_2 \to P~t_1~t_2'}\]

<p>The second one is crucial. It says we take the step of $t_2$ only when t1 is a value. This definition ensures we always evaluate the first argument (t1) until it reaches the form of value.</p>

<p>The usage of values doesn’t limit to this. In fact, they are very important and critical in small-step semantics.</p>

<h3 id="progress-and-normal-forms">Progress and Normal Forms</h3>

<p>In a large language, sometimes people can easily forget one or more rules, which results in a incomplete definition. One should prove its semantics to be <em>strong progress</em> to show there is nothing left.</p>

<p><strong>Theorem Strong Progress</strong>: If t is a term, then either t is a value or else there exists a term t’ such that t–&gt;t’.</p>

<p>When there are statement that doesn’t make sense, we don’t want to define every possible combination of terms. For example, if there are lists in the language, how could <code class="language-plaintext highlighter-rouge">1 + []</code> proceeds? The solution is called <em>typed progress</em>, which involves defining type systems to distinguish what statement doesn’t make sense, and only well-typed terms are progress. We don’t discuss more about types in this article.</p>

<p>Terms that cannot make progress are called <em>normal forms</em>. In this language, only values cannot make a further step. This is quite something that suggests our definition tend to be correct. Why? Because value is a syntactic concept – it is defined by looking at the way a term is written – while normal form is a semantic one – it is defined by looking at how the term steps.</p>

<h2 id="multi-step-reduction">Multi-Step Reduction</h2>

<p>Recall how multi-step evaluation relation is defined:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">multi</span><span class="w"> </span><span class="o">{</span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">R</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">relation</span><span class="w"> </span><span class="no">X</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">relation</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">multi_refl</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">X</span><span class="o">),</span><span class="w"> </span><span class="no">multi</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">x</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">multi_step</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">X</span><span class="o">),</span><span class="w">
                    </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="p">→</span><span class="w">
                    </span><span class="no">multi</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="w"> </span><span class="p">→</span><span class="w">
                    </span><span class="no">multi</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">z</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>This relation has a few properties</p>
<ul>
  <li>It is obviously <em>reflexive</em> (from the rule <code class="language-plaintext highlighter-rouge">multi_refl</code>).</li>
  <li>In the second rule, it takes a step relation $R$ to define what is multi-step evaluation of $R$. This is called <em>closure</em> of <em>R</em>.</li>
  <li>Third, it is <em>transitive</em>. i.e. If <code class="language-plaintext highlighter-rouge">multi t1 t2</code> and <code class="language-plaintext highlighter-rouge">multi t2 t3</code>, we have <code class="language-plaintext highlighter-rouge">multi t1 t3</code></li>
</ul>

<h3 id="normal-forms-in-multi-steps">Normal Forms in Multi-Steps</h3>

<p>If t reduces to t’ in zero or more steps and t’ is a normal form, we say that “t’ is a normal form of t.”</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">normal_form_of</span><span class="w"> </span><span class="o">(</span><span class="no">t</span><span class="w"> </span><span class="no">t'</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">(</span><span class="no">t</span><span class="w"> </span><span class="o">--&gt;*</span><span class="w"> </span><span class="no">t'</span><span class="w"> </span><span class="p">∧</span><span class="w"> </span><span class="no">step_normal_form</span><span class="w"> </span><span class="no">t'</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>This definition is important because it define what is typically the end of the evaluation.</p>

<p>We have seen single-step evaluation is deterministic. Following that, we also want to ensure that if t can reach a normal form, then this normal form is unique.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This article explains what is small-step operational semantics and what are the properties that developers should be aware of.</p>]]></content><author><name>Chew Y. Feng</name></author><category term="Software-Foundations" /><category term="Coq" /><category term="PLT" /><summary type="html"><![CDATA[Finding the meaning of a program]]></summary></entry><entry><title type="html">Distributed Transactions</title><link href="/coursenote/2024/05/11/Distributed-Transactions.html" rel="alternate" type="text/html" title="Distributed Transactions" /><published>2024-05-11T00:00:00+00:00</published><updated>2024-05-11T06:45:56+00:00</updated><id>/coursenote/2024/05/11/Distributed-Transactions</id><content type="html" xml:base="/coursenote/2024/05/11/Distributed-Transactions.html"><![CDATA[<p>In a distributed DBMS, a transaction usually involves multiple servers. Consider a transaction that a client transfers 10 dollars from account A to C and then transfers 20 dollars from B to D, and each of these accounts is stored in different servers as shown in the graph. If any one server in this transaction fails, the whole transaction needs to abort.</p>

<p><img src="/assets/images/Pasted image 20240511143920.png" alt="DistributedTransaction" /></p>

<p>A client transaction becomes distributed if it invokes operations in several different servers. This document talks about the main strategies to achieve ACID properties for distributed transactions.</p>

<h2 id="two-phase-commit-protocol">Two-Phase Commit Protocol</h2>

<p>The two-phase commit protocol (2PC) was devised to ensure the atomicity property in a distributed DBMS. where the atomicity property requires that when a distributed transaction comes to an end, <strong>either all of its operations are carried out or none of them</strong>.</p>

<!-- ![[Pasted image 20240511143920.png]] -->

<p>In 2PC, firstly, a server is selected to be the coordinator, which communicates with the client and coordinate the work on all servers.</p>

<p><img src="/assets/images/Pasted image 20240511144355.png" alt="DistributedTransaction" />
<!-- ![[Pasted image 20240511144355.png]] --></p>

<p>In the first phase of 2PC, each participant votes for the transaction to be committed or aborted. Once a participant has voted to commit a transaction, it is not allowed to abort it. Therefore, before a participant votes to commit a transaction, <strong>it must ensure that it will eventually be able to carry out its part of the commit protocol</strong>, even if it fails. A participant to said to be in a <em>prepared</em> state if it votes to commit.</p>

<p>In the second phase of the protocol, the coordinator decides the final decision (either abort or commit), every participant in the transaction carries out the joint decision.</p>

<p>To formally define the protocol, we first list the operations (interfaces) in the protocol:</p>
<ul>
  <li><em>canCommit</em>(trans) Yes / No
    <ul>
      <li>Call from coordinator to participant to ask whether it can commit a transaction. Participant replies with its vote.</li>
    </ul>
  </li>
  <li>*doCommit(trans)
    <ul>
      <li>Call from coordinator to participant to commit its part of a transaction.</li>
    </ul>
  </li>
  <li><em>doAbort</em>(trans)
    <ul>
      <li>Call from coordinator to participant to abort its part of a transaction.</li>
    </ul>
  </li>
  <li><em>haveCommitted</em>(trans, participant)
    <ul>
      <li>Call from participant to coordinator to confirm that it has committed the transaction.</li>
      <li>Just for deleting stale information on the coordinator.</li>
    </ul>
  </li>
  <li><em>getDecision</em>(trans) -&gt; Yes / No
    <ul>
      <li>Call from participant to coordinator to ask for the decision on a transaction after it has voted Yes but has still had no reply after some delay. Used to recover from server crash or delayed messages.</li>
    </ul>
  </li>
</ul>

<p>Phase 1</p>
<ol>
  <li>The coordinator sends a <em>canCommit</em>? request to each of the participants in the transaction.</li>
  <li>When a participant receives a <em>canCommit</em>? request it replies with its vote (Yes or No) to the coordinator. Before voting Yes, it prepares to commit by saving objects in permanent storage. If the vote is No, the participant aborts immediately.</li>
</ol>

<p>Phase 2</p>
<ol>
  <li>The coordinator collects the votes (including its own).
    <ol>
      <li>If there are no failures and all the votes are Yes, the coordinator decides to commit the transaction and sends a <em>doCommit</em> request to each of the participants.</li>
      <li>Otherwise, the coordinator decides to abort the transaction and sends <em>doAbort</em> requests to all participants that voted Yes.</li>
    </ol>
  </li>
  <li>Participants that voted Yes are waiting for a <em>doCommit</em> or <em>doAbort</em> request from the coordinator. When a participant receives one of these messages it acts accordingly and, in the case of commit, makes a <em>haveCommitted</em> call as confirmation to the coordinator.</li>
</ol>

<p><img src="/assets/images/Pasted image 20240511145431.png" alt="DistributedTransaction" />
<!-- ![[Pasted image 20240511145431.png]] --></p>

<p>Timeout is employed in 2PC.</p>
<ul>
  <li>If a participant votes yes, but not receiving any reply from the coordinator after a certain time, it enters the <em>uncertain</em> state. It can make a <em>getDecision</em> request to the coordinator to determine the outcome.</li>
  <li>Since after a participant votes yes, it can’t do anything until receive a decision from the coordinator. Thus, if a coordinator fails, it must be replaced.</li>
  <li>Conversely, if a participant can’t vote in a certain time, the coordinator must announce <em>doAbort</em> to all participants.</li>
</ul>

<h2 id="timestamp-ordering">Timestamp Ordering</h2>

<p>Similarly, the isolation property needs to be preserved in distributed transactions. There are two meanings behind isolation in distributed DBMSs:</p>
<ol>
  <li>Each server needs to be responsible for applying concurrency control to its own objects.</li>
  <li>All members of a distributed transactions are jointly responsible for ensuring that they are performed in a serially equivalent manner.</li>
</ol>

<p>We mainly talk about 2 in this article, where “serially equivalent manner” or “serializability” means if transaction T is before transaction U in their conflicting access to objects at one of the servers, then they must be in that order at all of the servers whose objects are accessed in a conflicting manner by both T and U.</p>

<p>The most common protocol is the timestamp ordering. in the protocol, similarly, a central coordinator is selected.</p>
<ul>
  <li>The coordinator issues a timestamp – the globally unique transaction timestamps – to each transaction when it starts to participants. All members are responsible for ensuring that transactions execute in the order of timestamp.</li>
  <li>The transaction timestamp is passed to the coordinator at each server whose objects perform an operation in the transaction. In this way, the coordinator can find the potential inconsistency</li>
</ul>

<h2 id="one-copy-serializability">One-copy Serializability</h2>

<p>There is a final concerns of distributed transactions. Usually, for increasing data availability, there are replicas for objects. From a client’s viewpoint, a transaction on replicated objects should appear the same as one with non-replicated objects. This property is named <em>one-copy serializability</em>. It is similar to, but not to be confused with, sequential consistency or sequential serializability.</p>

<p>The simplest protocol to achieve one-copy serializability is <strong>read-one/write-all</strong>. As its name suggests, when it reads, it can read from any one of the replicas. But a write requests must be performed on all replicas by the replica manager.</p>

<p><img src="/assets/images/Pasted image 20240511161255.png" alt="DistributedTransaction" />
<!-- ![[Pasted image 20240511161255.png]] --></p>

<p>Simple read-one/write-all replication is not a realistic scheme, because it cannot be carried out if some of the replica managers are unavailable. This deficiency essentially contradicts with the purpose of replicas because replicas scheme is designed to allow for some replica managers being temporarily unavailable.</p>

<p>A more realistic protocol is local validation. It allows a transaction to write only to available replicas. However, before a transaction commits it checks for any failures (and recoveries) of replica managers of objects it has accessed. A transaction can only commits if there is no failure and recovery of replicas which stores the object used in the transaction.</p>

<h2 id="reference">Reference</h2>

<p>Coulouris, George F., Jean Dollimore, and Tim Kindberg. Distributed systems: concepts and design. pearson education, 2005.</p>]]></content><author><name>Chew Y. Feng</name></author><category term="CourseNote" /><category term="Database" /><summary type="html"><![CDATA[Deal with the complexity in distributed systems.]]></summary></entry><entry><title type="html">Transaction Management</title><link href="/coursenote/2024/04/19/Transaction-Management.html" rel="alternate" type="text/html" title="Transaction Management" /><published>2024-04-19T00:00:00+00:00</published><updated>2024-05-11T06:41:14+00:00</updated><id>/coursenote/2024/04/19/Transaction-Management</id><content type="html" xml:base="/coursenote/2024/04/19/Transaction-Management.html"><![CDATA[<p>The document summarize transaction management in database.</p>

<p>Content from Unimelb Master Subject <a href="https://handbook.unimelb.edu.au/subjects/comp90050">COMP90050</a></p>

<h2 id="background">Background</h2>

<p>Some cliché here:
Transaction is a <strong>unit of work</strong> in a database
Properties of transaction: <strong>ACID</strong></p>
<ul>
  <li><strong>Atomicity</strong>. Either all operations of the transaction are reflected properly in the database, or none are</li>
  <li><strong>Consistency</strong>. Execution of a transaction in isolation (i.e., with no other transaction executing concurrently) preserves the consistency of the database.
    <ul>
      <li>What is “consistent” often depends on applications</li>
      <li>Not easily computable in general</li>
    </ul>
  </li>
  <li><strong>Isolation</strong>. Even though multiple transactions may execute concurrently, the system guarantees that, for every pair of transactions, it appears that one is unaware of another
    <ul>
      <li>mainly about concurrency control</li>
    </ul>
  </li>
  <li><strong>Durability</strong>. After a transaction completes successfully, the changes it has made to the database persist, even if there are system failures.</li>
</ul>

<p>Not all operations can have ACID. Three types of operations in DBMS</p>
<ul>
  <li>Unprotected actions. actions with no ACID. e.g. low level read and write from memory / disk</li>
  <li><strong>Protected actions</strong></li>
  <li>Real actions. These actions affect the real, physical world in a way that is hard or impossible to reverse. theoretically impossible to implement ACID. e.g. printing a report, sending a SMS message…</li>
</ul>

<h2 id="transaction-from-programmers-perspective">Transaction from Programmers Perspective</h2>

<p>Not all queries can be expressed in SQL, so a transaction often works with a general purpose language such as C and Java</p>

<p>Two approaches to accessing SQL: Dynamic SQL and Embedded SQL</p>
<ul>
  <li>Dynamic SQL ← construct and submit SQL queries at <strong>runtime</strong>. e.g. JDBC</li>
  <li>Embedded SQL ← compile SQL statement at <strong>compile time</strong>. e.g. C Embedded SQL</li>
</ul>

<p>The main distinction between Dynamic SQL and Embedded SQL is the existence of <strong>Pre-processing</strong>. Preprocessing can catch errors in the compile stage e.g. type error, SQL syntax error, but it complicates debugging of the program and even causes ambiguity because it, actually creates a new host language. As a result, most modern systems use dynamic SQL.</p>

<p>Finally, note that nondeclarative actions in programs – printing to terminal, sending result to UI – cannot be undone by DB</p>
<h3 id="c-embedded-sql">C Embedded SQL</h3>
<p>Example a flat transaction.</p>

<p>First, create a function with no transaction</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">BEGIN</span> <span class="n">DECLARE</span> <span class="n">SECTION</span><span class="p">;</span>
	<span class="cm">/* The following variables are used for communicating between SQL and C */</span>
	<span class="kt">int</span> <span class="n">OrderID</span><span class="p">;</span> 		<span class="cm">/* Employee ID (from user) */</span> 
	<span class="kt">int</span> <span class="n">CustID</span><span class="p">;</span>	 	<span class="cm">/* Retrieved customer ID */</span> 
	<span class="kt">char</span> <span class="n">SalesPerson</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="cm">/* Retrieved salesperson name */</span> 
	<span class="kt">char</span> <span class="n">Status</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> 	<span class="cm">/* Retrieved order status */</span> 
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">END</span> <span class="n">DECLARE</span> <span class="n">SECTION</span><span class="p">;</span> 
	
	<span class="cm">/* Set up error processing */</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">WHENEVER</span> <span class="n">SQLERROR</span> <span class="n">GOTO</span> <span class="n">query_error</span><span class="p">;</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">WHENEVER</span> <span class="n">NOTFOUND</span> <span class="n">GOTO</span> <span class="n">bad_number</span><span class="p">;</span>
	
	<span class="cm">/* Prompt the user for order number */</span>
	<span class="n">printf</span> <span class="p">(</span><span class="s">"Enter order number: "</span><span class="p">);</span>
	<span class="n">scanf_s</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">OrderID</span><span class="p">);</span>
	
	<span class="cm">/* Execute the SQL query, simple query no transaction definition */</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">SELECT</span> <span class="n">CustID</span><span class="p">,</span> <span class="n">SalesPerson</span><span class="p">,</span> <span class="n">Status</span>
	<span class="n">FROM</span> <span class="n">Orders</span>
	<span class="n">WHERE</span> <span class="n">OrderID</span> <span class="o">=</span> <span class="o">:</span><span class="n">OrderID</span><span class="p">;</span><span class="c1">// ”:” indicates to refer to  C variable</span>
	<span class="n">INTO</span> <span class="o">:</span><span class="n">CustID</span><span class="p">,</span> <span class="o">:</span><span class="n">SalesPerson</span><span class="p">,</span> <span class="o">:</span><span class="n">Status</span><span class="p">;</span>
	
	<span class="n">printf</span> <span class="p">(</span><span class="s">"Customer number: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">CustID</span><span class="p">);</span>
	<span class="n">printf</span> <span class="p">(</span><span class="s">"Salesperson: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">SalesPerson</span><span class="p">);</span>
	<span class="n">printf</span> <span class="p">(</span><span class="s">"Status: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Status</span><span class="p">);</span>
	
	<span class="n">exit</span><span class="p">();</span>
	
	<span class="nl">query_error:</span>
	<span class="n">printf</span> <span class="p">(</span><span class="s">"SQL error: %ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sqlca</span><span class="o">-&gt;</span><span class="n">sqlcode</span><span class="p">);</span> <span class="n">exit</span><span class="p">();</span>
	
	<span class="nl">bad_number:</span>
	<span class="n">printf</span> <span class="p">(</span><span class="s">"Invalid order number.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="n">exit</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>Then, put transaction into the example: Everything between</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">exec</span> <span class="n">sql</span> <span class="n">BEGIN</span> <span class="n">WORK</span><span class="p">;</span>
</code></pre></div></div>
<p>and</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">exec</span> <span class="n">sql</span> <span class="n">COMMIT</span> <span class="n">WORK</span><span class="p">;</span>
</code></pre></div></div>
<p>is seen as transaction.</p>

<p>e.g.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DCApplication</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">BEGIN</span> <span class="n">WORK</span><span class="p">;</span>
	<span class="n">AccBalance</span> <span class="o">=</span> <span class="n">DodebitCredit</span><span class="p">(</span><span class="n">BranchId</span><span class="p">,</span> <span class="n">TellerId</span><span class="p">,</span> <span class="n">AccId</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
	<span class="c1">// Consistency Check</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AccBalance</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Inconsistent</span>
	<span class="c1">// Let dbms undo whatever it has done</span>
		<span class="n">exec</span> <span class="n">sql</span> <span class="n">ROLLBACK</span> <span class="n">WORK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> 
		<span class="n">send</span> <span class="n">output</span> <span class="n">msg</span><span class="p">;</span>
		<span class="n">exec</span> <span class="n">sql</span> <span class="n">COMMIT</span> <span class="n">WORK</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">Long</span> <span class="nf">DoDebitCredit</span><span class="p">(</span><span class="kt">long</span> <span class="n">BranchId</span><span class="p">,</span> <span class="kt">long</span> <span class="n">TellerId</span><span class="p">,</span> <span class="kt">long</span> <span class="n">AccId</span><span class="p">,</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">UPDATE</span> <span class="n">accounts</span>
	<span class="n">SET</span> <span class="n">AccBalance</span> <span class="o">=</span><span class="n">AccBalance</span> <span class="o">+</span> <span class="o">:</span><span class="n">delta</span>
	<span class="n">WHERE</span> <span class="n">AccId</span> <span class="o">=</span> <span class="o">:</span><span class="n">AccId</span><span class="p">;</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">SELECT</span> <span class="n">AccBalance</span> <span class="n">INTO</span>  <span class="o">:</span><span class="n">AccBalance</span>
	<span class="n">FROM</span> <span class="n">accounts</span> <span class="n">WHERE</span> <span class="n">AccId</span> <span class="o">=</span> <span class="o">:</span><span class="n">AccId</span><span class="p">;</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">UPDATE</span> <span class="n">tellers</span>
	<span class="n">SET</span> <span class="n">TellerBalance</span> <span class="o">=</span> <span class="n">TellerBalance</span> <span class="o">+</span> <span class="o">:</span><span class="n">delta</span>
	<span class="n">WHERE</span> <span class="n">TellerId</span> <span class="o">=</span> <span class="o">:</span><span class="n">TellerId</span><span class="p">;</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">UPDATE</span> <span class="n">branches</span>
	<span class="n">SET</span> <span class="n">BranchBalance</span> <span class="o">=</span> <span class="n">BranchBalance</span> <span class="o">+</span> <span class="o">:</span><span class="n">delta</span>
	<span class="n">WHERE</span> <span class="n">BranchId</span> <span class="o">=</span> <span class="o">:</span><span class="n">BranchId</span><span class="p">;</span>
	
	<span class="n">Exec</span> <span class="n">sql</span> <span class="n">INSERT</span> <span class="n">INTO</span> <span class="n">history</span><span class="p">(</span><span class="n">TellerId</span><span class="p">,</span> <span class="n">BranchId</span><span class="p">,</span> <span class="n">AccId</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
	<span class="n">VALUES</span><span class="p">(</span> <span class="o">:</span><span class="n">TellerId</span><span class="p">,</span> <span class="o">:</span><span class="n">BranchId</span><span class="p">,</span> <span class="o">:</span><span class="n">AccId</span><span class="p">,</span> <span class="o">:</span><span class="n">delta</span><span class="p">,</span> <span class="n">CURRENT</span><span class="p">);</span>
	
	<span class="k">return</span><span class="p">(</span><span class="n">AccBalance</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>the transaction will either survive together with everything from BEGIN WORK to COMMIT WORD, or it will be rolled back with everything (abort).</p>

<h3 id="dynamic-sql">Dynamic SQL</h3>

<p>Take JDBC as an example.</p>

<p>Mainly four steps:</p>
<ul>
  <li>Open a connection</li>
  <li>Create a statement object</li>
  <li>Execute queries using the statement object to send queries and fetch results</li>
  <li>Exception mechanism to handle errors</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">JDBCexample</span><span class="o">(</span><span class="nc">String</span> <span class="n">userid</span><span class="o">,</span> <span class="nc">String</span> <span class="n">passwd</span><span class="o">)</span>
<span class="o">{</span>
	<span class="k">try</span> <span class="o">(</span>
		<span class="c1">// Open a connection</span>
		<span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span>
			<span class="s">"jdbc:oracle:thin:@db.yale.edu:1521:univdb"</span><span class="o">,</span>
			<span class="n">userid</span><span class="o">,</span> <span class="n">passwd</span><span class="o">);</span>
		<span class="c1">// Create a statement object</span>
		<span class="nc">Statement</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">createStatement</span><span class="o">();</span>
	<span class="o">)</span> <span class="o">{</span>
		<span class="k">try</span> <span class="o">{</span>
			<span class="c1">// Execute queries using the statement object</span>
			<span class="n">stmt</span><span class="o">.</span><span class="na">executeUpdate</span><span class="o">(</span>
			<span class="s">"insert into instructor values(’77987’,’Kim’,’Physics’,98000)"</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="k">catch</span> <span class="o">(</span><span class="nc">SQLException</span> <span class="n">sqle</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Could not insert tuple. "</span> <span class="o">+</span> <span class="n">sqle</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="c1">// Execute queries using the statement object</span>
		<span class="nc">ResultSet</span> <span class="n">rset</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">(</span>
			<span class="s">"select dept_name, avg (salary) "</span><span class="o">+</span>
			<span class="s">" from instructor "</span><span class="o">+</span>
			<span class="s">" group by dept_name"</span><span class="o">);</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">rset</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">rset</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"dept_name"</span><span class="o">)</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span>
			<span class="n">rset</span><span class="o">.</span><span class="na">getFloat</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
		<span class="o">}</span>
	<span class="o">}</span>
	<span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">sqle</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">// handle exception</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Exception : "</span> <span class="o">+</span> <span class="n">sqle</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><em>Automatic Commit</em>. Most DBs treats each SQL statement as a transaction by default.</p>

<p>To create a transaction, automatic commit must be turn off.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">assert</span> <span class="n">conn</span> <span class="k">instanceof</span> <span class="nc">Connection</span><span class="o">;</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setAutoCommit</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
</code></pre></div></div>

<p>A transaction can be put between</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">conn</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span> 
<span class="n">stmt</span><span class="o">.</span><span class="na">executeUpdate</span><span class="o">(...);</span>
<span class="n">conn</span><span class="o">.</span><span class="na">rollback</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="savepoints-and-nested-transactions">Savepoints And Nested Transactions</h2>

<p>The examples above are flat transactions.</p>

<p>A <em>flat transaction</em> typically refers to a transaction that doesn’t involve multiple steps or subtransactions. It’s a simple, single-operation transaction where a database operation is executed as a single unit of work.</p>

<p>A typical flat transaction:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BEGIN WORK
S1: book flight from Melbourne to Singapore
S2: book flight from Singapore to London
S3: book flight from London to Dublin
COMMIT WORK
</code></pre></div></div>

<p>The semantic of flat transaction is <strong><em>“all-or-nothing”</em></strong></p>
<ul>
  <li>A naïve implementation: giving up everything that has been done (invoke <code class="language-plaintext highlighter-rouge">ROLLBACK WORK</code>)</li>
  <li>Good at short applications such as debit/credit</li>
  <li>Problem: waste of computation power</li>
</ul>

<p>A better solution: stepping back to an earlier state <em>inside the same transaction</em> by <strong><em>savepoints</em></strong></p>

<p><img src="/assets/images/Pasted image 20240407110700.png" alt="SavePoints" /></p>

<p>Savepoints are explicitly established by the application program and can be reestablished by invoking a modified ROLLBACK function, which is aimed at an internal savepoint rather than at the beginning of the transaction.</p>

<p>An alternative to savepoints is nested transactions (or subtransactions)</p>

<p>Nested transactions are a generalization of savepoints. Whereas savepoints allow organizing a transaction into a <em>sequence</em> of actions that can be rolled back individually, nested transactions form a <em>hierarchy</em> of pieces of work.</p>

<p><img src="/assets/images/Pasted image 20240407111000.png" alt="NestedTransaction" /></p>

<p>Definition of nested Transaction:</p>

<ul>
  <li>A nested transaction is a tree of transactions, the sub-trees of which are either nested or flat transactions.</li>
  <li>A subtransaction can either commit or roll back; its commit will not take effect, though, unless the parent transaction commits. By induction, therefore, any subtransaction can finally commit only if the root transaction commits.</li>
</ul>

<p>Rules of subtransactions:</p>
<ul>
  <li><strong>Commit rule.</strong> The commit of a subtransaction makes its results accessible only to the parent transaction. Any subtransaction can finally commit only if the root transaction commits.</li>
  <li><strong>Rollback rule.</strong> If a transaction at any level is rolled back, all its subtransactions are also  rolled back</li>
  <li><strong>Visibility rule.</strong> All changes done by a subtransaction become visible to the parent transaction upon the subtransaction’s commit. All objects held by a parent transaction can be made accessible to its subtransactions. Changes made by a subtransaction are not visible to its siblings, in case they execute concurrently. Siblings cannot view each other.</li>
</ul>

<p>subtransactions are more capable than savepoints + flat transaction:</p>
<ul>
  <li>subtransactions can run in parallel so more effecient.</li>
  <li>the code will be more organizable</li>
</ul>

<p>Conclusion: subtransactions have ACI, but no D (The changes are made durable only after the whole transaction has committed)</p>

<h2 id="transaction-processing-monitors">Transaction Processing Monitors</h2>

<p><em>TP monitors</em> are the least well-defined software term. They function differently in different DBMS.</p>

<p>The main function of a TP monitor is <strong>to <em>integrate</em> other system components and manage resources</strong>.</p>

<p>The TP monitor integrates different system components to provide a uniform applications and operations interface with the same failure semantics (ACID properties).</p>

<p>In this subject, TP monitors are defined to be</p>
<ul>
  <li>TP monitors manage the <strong>transfer of data between clients and servers</strong></li>
  <li>Breaks down applications or code <strong>into transactions and ensures that all the database(s) are updated properly</strong></li>
  <li>It also takes appropriate <strong>actions if any error occurs</strong></li>
</ul>

<p>Services:</p>
<ul>
  <li><strong>Terminal(clients) management</strong>. manage connections, deliver and receive message by users</li>
  <li><strong>Presentation services</strong>. dealt with different UI software, similar to the previous one</li>
  <li><strong>Context management.</strong>  context such as “Current authenticated userid at that terminal,” “Default terminal for that user,” “Account number for that user,” “Current user role.”…</li>
  <li><strong>Start/restart</strong>. handle the restart after any failure</li>
</ul>

<h3 id="structures-of-tp-monitors">Structures of TP Monitors</h3>

<p><strong>One process per terminal</strong></p>

<p>Each process can run all applications. Each process may have to access any one of the databases. This design is typical of time-sharing systems. It has many processes and many control blocks.</p>

<p>Very memory expensive, context switching causes problems too..</p>

<p><strong>Only one terminal process</strong></p>

<p>In this solution, there is just one process in the entire system. It talks to all terminals, does presentation handling, receives the requests, contains the code for all services of all applications, can access any database, and creates dynamic threads to multiplex itself among the incoming request</p>

<p>This would work under a multithreaded environment but cannot do proper parallel processing, one error leads to large scale problems, not really distributed and rather monolithic</p>

<p><strong>Many Servers, One Scheduler</strong></p>

<p>Multiple processes have one requester, which is the process handling the communication with the clients.</p>

<p><strong>Multiple communication processes and servers</strong></p>

<p><strong>Generalization of the coexistence approach: multiple application servers invoked by multiple requesters.</strong> The association between these groups of functionally distinct processes, load control, activation/deactivation of processes, and so on, must now be coordinated by a separate instance, the monitor process.</p>

<h2 id="transaction-concurrency-control">Transaction Concurrency Control</h2>

<p>Concurrency control guarantee the <strong>isolation</strong> properties</p>

<p>Idea: impose exclusive access to shared variables on different threads.</p>

<p>Approaches:</p>
<ul>
  <li>Dekker’s Algorithm – needs almost no hardware support. but high complexity</li>
  <li>OS support primitives – simple to use, expensive, dependent on OS</li>
  <li>Spin locks – the most common mechanism in DBMS
  Atomic lock/unlock instructions</li>
</ul>

<p><strong>Dekker’s Algorithm</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="kt">int</span> <span class="n">wants</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> 		<span class="c1">// both should be initially 0</span>
<span class="err">…</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">wants</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> 		<span class="c1">// claim desire</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">wants</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">turn</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wants</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">==</span> <span class="n">j</span><span class="p">);</span>
			<span class="n">wants</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="o">:</span> 	<span class="c1">// resource we want mutex on</span>
	<span class="n">turn</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> 			<span class="c1">// assign turn</span>
	<span class="n">wants</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span><span class="err">…</span>
</code></pre></div></div>

<ul>
  <li>Manage <em>desire</em> by arrays</li>
  <li>Use loop statement to wait (busy waiting) → waste of computation power</li>
  <li>Transfer turn to others when task is done</li>
</ul>

<p><strong>OS Exclusive Access</strong></p>

<p>OS support primitives as lock and unlock</p>
<ul>
  <li>Do not use busy waiting, but also very expensive</li>
  <li>also OS dependent</li>
</ul>

<p><strong>Spin Locks</strong></p>

<ul>
  <li>Executed using atomic machine instructions such as test and set or swap</li>
  <li>Need hardware support ← need to lock bus</li>
  <li>uses busy waiting</li>
  <li>very efficient for low lock contentions, commonly used in DBMS</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// lock granted</span>
<span class="n">acquire</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">testAndSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">));</span> <span class="c1">// busy waiting</span>
<span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
<span class="c1">// release lock</span>
<span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">testAndSet</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Assume this line runs in atomic</span>
	<span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">lock</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">return</span> <span class="nb">true</span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="k">return</span> <span class="nb">false</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Yet another spin lock – compare and swap</p>

<p>more generic lock mechanism in programming languages:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lock</span><span class="o">(</span><span class="kt">var</span><span class="o">);</span>
<span class="n">unlock</span><span class="o">(</span><span class="kt">var</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="semaphore">Semaphore</h3>
<p>Definition: A bit, token, fragment of code, or some other mechanism which is used to restrict access to a shared function or device to a single process at a time, or to synchronize and coordinate events in different processes.</p>

<p>Semaphores derive from the <strong>trains</strong>: a train may proceed through a section of track only if there is no other train on the track. Else, it waits</p>

<p>Implement in computers:</p>
<ul>
  <li>A general <code class="language-plaintext highlighter-rouge">get</code> subroutine to acquire access, and a <code class="language-plaintext highlighter-rouge">give</code> to give access to others</li>
  <li>Put waiting processes into a queue to let them wait (simplest: a linked list)</li>
  <li>After a process release the access, give it to the very next process</li>
</ul>

<p>Semaphores are simple locks; no deadlock detection, no conversion, no escalation…</p>

<p>Exclusive Semaphores. An exclusive semaphore is a pointer to a linked list of processes, indicating the exclusive ownership of resources. The process at the end of the list own the semaphore.</p>

<p>To acquire a semaphore, a process needs to call <code class="language-plaintext highlighter-rouge">get()</code></p>

<p>An example <code class="language-plaintext highlighter-rouge">get()</code> of an exclusive semaphore
<img src="/assets/images/Pasted image 20240417095100.png" alt="Semaphore-Get" /></p>

<p>Note that <code class="language-plaintext highlighter-rouge">CS</code> stands for “compare-and-swap“ (a spin lock)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">boolean</span> <span class="nf">cs</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span><span class="cm">/* the following is executed atomically*/</span>
<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cell</span> <span class="o">==</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="n">cell</span> <span class="o">=</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span> <span class="k">return</span> <span class="n">TRUE</span><span class="p">;}</span>
<span class="k">else</span> <span class="p">{</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">cell</span><span class="p">;</span> <span class="k">return</span> <span class="n">FALSE</span><span class="p">;}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>After finishing all things, a process call <code class="language-plaintext highlighter-rouge">give()</code> to wake up the first process in the waiting list</p>

<p>An example <code class="language-plaintext highlighter-rouge">give()</code> of an exclusive semaphore
<img src="/assets/images/Pasted image 20240417095419.png" alt="Semaphore-Give" /></p>

<p>Problem of Exclusive Semaphore: Dead Locks</p>

<p>Solution to dead locks:</p>
<ul>
  <li>Have enough resources – not practical</li>
  <li>don’t allow a process to wait permanently. simply <strong>rollback</strong> after a certain time
  bad idea too. causing resources waste and repeated deadlocks. 
  it causes <em>live locks</em> → constantly change the state of processes but with no actual progress</li>
  <li>Linearly order the resources and request of resources should follow this order – practical
  guarantees that no cyclic dependencies among the transactions.
  i.e. a transaction after requesting ith resource can request jth resource if j &gt; i.
  it applies to statis resources such as printers, but it generally can’t apply to db in general because you don’t know how to order things until runtime</li>
  <li>pre-declare all necessary resources and allocate at once</li>
  <li>Periodically check cycles in graphs
  if a cycle exists, rollback one or more transaction
  not common in practical:
    <ul>
      <li>check if there is a cycle in distributed states is impossible to be absolutely correct</li>
      <li>how to decide which transaction to sacrifice?</li>
    </ul>
  </li>
  <li>Allow waiting for a maximum time on a lock then force Rollback: Many successful systems (IBM, etc) have chosen this approach…</li>
  <li>Most practical approach: allow a transaction waiting for a maximum time on a lock then force rollback</li>
</ul>

<h3 id="concurrency-control-for-isolation">Concurrency Control For Isolation</h3>

<p>The relation between concurrency control and isolation can be described in two aspects:</p>
<ul>
  <li>Concurrent transaction leaves the database in the same state as if the transactions were executed separately</li>
  <li>Isolation guarantees consistency, provided each transaction itself is consistent
  No inconsistency arise from allowing concurrency</li>
</ul>

<p>By the way, why not just achieve isolation by sequentially processing each transaction? Because <strong>efficiency is also important</strong> in DBMS.</p>

<p>Therefore, we need to use concurrency control to support properties of concurrent transactions:</p>
<ul>
  <li>concurrent execution should not cause programs to malfunction</li>
  <li>concurrent execution should have higher throughput (otherwise abandon it)</li>
</ul>

<h3 id="achieve-concurrency-control-in-db">Achieve Concurrency Control in DB</h3>

<p>The tool: dependency graphs</p>

<p><img src="/assets/images/Pasted image 20240417154210.png" alt="DependencyGraphs" /></p>

<p><strong>The dependencies induced by history fragments.</strong> Each graph shows the two transaction nodes <em>T1</em> and <em>T2</em> and the arcs labeled with the object 〈name,version〉 pairs.</p>

<p>A simple observation: read doesn’t cause concurrency issue</p>

<p>Possible Issues:</p>
<ul>
  <li>Lost Update: Write after write</li>
  <li>Dirty Read: Read after write</li>
  <li>Unrepeatable Read: READ→WRITE→READ</li>
</ul>]]></content><author><name>Chew Y. Feng</name></author><category term="CourseNote" /><category term="Database" /><summary type="html"><![CDATA[What is under the hood of DB magic]]></summary></entry><entry><title type="html">Note of Alloy Analyzer</title><link href="/coursenote/2024/03/31/Alloy-Analyser.html" rel="alternate" type="text/html" title="Note of Alloy Analyzer" /><published>2024-03-31T00:00:00+00:00</published><updated>2024-03-31T11:30:03+00:00</updated><id>/coursenote/2024/03/31/Alloy-Analyser</id><content type="html" xml:base="/coursenote/2024/03/31/Alloy-Analyser.html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#propositional-logic" id="markdown-toc-propositional-logic">Propositional Logic</a>    <ul>
      <li><a href="#relation-and-predicates" id="markdown-toc-relation-and-predicates">Relation and Predicates</a></li>
      <li><a href="#operators" id="markdown-toc-operators">Operators</a></li>
    </ul>
  </li>
  <li><a href="#temporal-logic" id="markdown-toc-temporal-logic">Temporal Logic</a>    <ul>
      <li><a href="#temporal-logic-1" id="markdown-toc-temporal-logic-1">Temporal Logic</a></li>
      <li><a href="#language" id="markdown-toc-language">Language</a></li>
    </ul>
  </li>
  <li><a href="#alloy-language" id="markdown-toc-alloy-language">Alloy Language</a></li>
  <li><a href="#model-checking" id="markdown-toc-model-checking">Model Checking</a></li>
</ul>

<blockquote>
  <ul>
    <li>Author: chew.y.feng@outlook.com</li>
    <li>Date: 03/29/2024</li>
  </ul>
</blockquote>

<h2 id="introduction">Introduction</h2>
<p>This note is a brief summary of <a href="https://alloytools.org/tutorials/online/">Alloy</a> for SWEN90010, Unimelb.</p>

<p>Alloy is an analyzer for software modeling. This subject mainly uses Alloy to find holes in security mechanisms. To be more specific, we use Alloy to <em>prove</em> properties about the software specification, such as safety and security.</p>
<h2 id="propositional-logic">Propositional Logic</h2>
<p>Alloy support basic propositional Logic:</p>
<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">all</span><span class="w"> </span><span class="no">city</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">AustralianCities</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">Raining</span><span class="o">[</span><span class="no">city</span><span class="o">]</span><span class="w">
</span></code></pre></div></div>
<p>It says “for all cities in Australia, they are raining”</p>
<h3 id="relation-and-predicates">Relation and Predicates</h3>
<p>Everything is a relation in Alloy. Sets are just unary relations. e.g.</p>
<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Username</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{(</span><span class="no">U0</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="no">U1</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="no">U2</span><span class="o">)}</span><span class="w"> 
</span><span class="no">URL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{(</span><span class="no">UR0</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="no">UR1</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="no">UR2</span><span class="o">)}</span><span class="w"> 
</span><span class="no">Password</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{(</span><span class="no">P0</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="no">P1</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="no">P2</span><span class="o">)}</span><span class="w">
</span></code></pre></div></div>

<p>For arity &gt; 1, relations are also sets e.g.</p>
<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Factor</span><span class="o">(</span><span class="no">x</span><span class="o">,</span><span class="no">y</span><span class="o">,</span><span class="no">z</span><span class="o">)</span><span class="w"> </span><span class="err">—</span><span class="w"> </span><span class="o">{(</span><span class="no">x</span><span class="o">,</span><span class="no">y</span><span class="o">,</span><span class="no">z</span><span class="o">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">z</span><span class="o">}</span><span class="w">
</span></code></pre></div></div>

<p>In summary, we have Sets = Relations = Predicates in alloy</p>
<h3 id="operators">Operators</h3>
<p><strong>Set operators</strong></p>

<p><img src="/assets/images/20240331-alloy-setop.png" alt="setops" /></p>

<p><strong>Relation operators</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Username = {(U0, U1, U2)} 
Password = {(P0, P1, P2)} 
// cross product
Username-&gt;Password = { (U0, P0), (U0, P1), (U0, P2),
					   (U1, P0), (U1, P1), (U1, P2), 
					   (U2, P0), (U2, P1), (U2, P2)}

urlPasswords = {(U0, UR0, P1), (U0, UR1, P2), (U1, UR0, P2)}
myUsername = {(U0)}
myUrl = {(UR1)}
myPassword = {(P2)}

// dot join
myUsername.urlPasswords = { (UR0, P1), (UR1, P2) }

// box join
myUsername.urlPasswords[myUrl] = {(P2)}

// domain restriction
urlPasswords &lt;: myUsername = {(U0, UR0, P1), (U0, UR1, P2) }

// range restriction
urlPasswords :&gt; myPassword = {(U0, UR1, P2), (U1, UR0, P2)}

// override is defined as A ++ B = (A - (domain[B] &lt;: A) + B)
updatedPassword = {(U0, UR0, P3)}
urlPasswords ++ updatedPassword = {(U0, UR0, P3), (U0, UR1, P2), (U1, UR0, P2)}

// cardinalities
#urlPasswords = 3
</code></pre></div></div>
<p>Note that if the relation has an arity of n, the first (n-1) are seen as domain, the last one is the range.</p>

<p><strong>Propositional Logic Operators</strong></p>

<p><img src="/assets/images/20240331-alloy-propop.png" alt="propop" /></p>

<p><strong>Quantifiers</strong></p>

<p><img src="/assets/images/20240331-alloy-quantifiers.png" alt="quantifiers" /></p>

<p>The last four can also be used to declare sets.</p>
<h2 id="temporal-logic">Temporal Logic</h2>
<p>One major feature of Alloy is that it can reason about <em>temporal logic</em> by <em>temporal operators</em>.</p>
<h3 id="temporal-logic-1">Temporal Logic</h3>
<p>Alloy adopts a model-based specification system, in which the system is defined as a <strong><em>state machine model</em></strong>. In an abstract state machine model, the state e
volves over time</p>

<p><img src="/assets/images/20240329164131.png" alt="statemachine" /></p>

<p>We can describe the transition as <strong><em>preconditions</em></strong> (what the state should satisfy before the transition) and <strong><em>postconditions</em></strong> (constraints after the transition).</p>

<p>For safety and security properties, we typically want it to hold in all states. Thus, it is called a <strong><em>state invariant</em></strong>.</p>

<p>To prove a state invariant <code class="language-plaintext highlighter-rouge">inv</code>, we need to use induction:
(a) <code class="language-plaintext highlighter-rouge">inv</code> holds in the initial state
(b) For each operation <code class="language-plaintext highlighter-rouge">op_i</code>, if <code class="language-plaintext highlighter-rouge">inv</code> holds in states, <code class="language-plaintext highlighter-rouge">inv</code> still holds after the operation <code class="language-plaintext highlighter-rouge">op_i</code>.</p>

<h3 id="language">Language</h3>

<p>There are two ways to express things happen in  a timeline:</p>

<p>(a) Use the next state operator <code class="language-plaintext highlighter-rouge">'</code> <strong>for sets</strong></p>
<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">newPassword</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">updatedPassword</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{(</span><span class="no">UR0</span><span class="o">,</span><span class="w"> </span><span class="no">P3</span><span class="o">)}</span><span class="w">
</span><span class="nn">user</span><span class="p">.</span><span class="no">passwords</span><span class="err">’</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">user</span><span class="p">.</span><span class="no">passwords</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">newPassword</span><span class="w">
</span></code></pre></div></div>
<p>It says “In the next state, there is one password being updated”</p>

<p>(b) Use temporal logic keywords <strong>for predicates</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// after means the predicate holds for next state on the timeline
delete_all[user] =&gt; after (no user.passwords)
</code></pre></div></div>

<p><img src="/assets/images/20240329155752.png" alt="temporalops" />
All temporal operators</p>

<h2 id="alloy-language">Alloy Language</h2>
<p><strong>Signatures</strong> are type declarations.</p>

<p><img src="/assets/images/20240329160557.png" alt="sigs" />
Common Signature Declarations</p>

<p>Example: Passbook is a database that stores the relation of (user, url, password).</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sig URL {} 
sig Username {} 
sig Password {} 
sig PassBook {var password : Username -&gt; URL -&gt; Password}
</code></pre></div></div>

<p><strong>Facts</strong> are constraints that are assumed to hold true. They only check initial state by default , unless there are temporal keywords.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fact NoDuplicates
{
	always all pb : PassBook, user : Username, url : URL 
		| lone pb.password[user][url]
}
</code></pre></div></div>
<p>It reads “for all time, all passbooks, users and URLs, there is at most one password for each <code class="language-plaintext highlighter-rouge">(user,url)</code> pair”</p>

<p><strong>Predicates</strong> are primarily used to introduce <em>operations</em> over a state</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//Add a password for a new user/url pair
pred add [pb : PassBook, url : URL, user: Username, pwd: Password] {
	no pb.password[user][url]
	pb.password’ = pb.password + (user-&gt;url-&gt;pwd)
}

//Delete an existing password
pred delete [pb : PassBook, url : URL, user: Username] {
	one pb.password[user][url]
	pb.password’ = pb.password - (user-&gt;url-&gt;Password)
}
</code></pre></div></div>

<p><strong>Functions</strong> are named expressions for reuse of code</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//Return the password for a given user/URL pair
fun lookup [pb: PassBook, url : URL, user : Username] : lone Password {
	pb.password[user][url]
}
</code></pre></div></div>

<p><strong>Assertions</strong> are constraints are we want to check. We primarily use them to express the safety or security properties</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// (durability) If we add a new password, 
// then we get this password when we look it up 
assert addWorks {
	all pb : PassBook, url : URL, user : Username, p : Password |
	add [pb, url, user, p] =&gt; (after (lookup [pb, url, user]) = p)
}
</code></pre></div></div>
<h2 id="model-checking">Model Checking</h2>
<p>The advantage of Alloy is that proofs are automated. Users only need to give the constraints, then Alloy would try to find a counterexample. This approach significantly reduces the efforts in writing proofs. But the tradoff is that it cannot guarantee completeness.</p>

<p>Example:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>assert lone_password_per_user_url {
	all pb, user, url, pwd, res | 
	 (all user1, url1 | lone pb.password[user1][url1]) and
	 no pb.password[user][url] and
	 pb.password’ = pb.password + (user-&gt;url-&gt;pwd) =&gt;
	(lone pb.password’[user][url])
}
</code></pre></div></div>]]></content><author><name>Chew Y. Feng</name></author><category term="CourseNote" /><category term="Formal Method" /><summary type="html"><![CDATA[Light Weighted Formal Methods]]></summary></entry><entry><title type="html">Hoare Logic - Decorated Program</title><link href="/software-foundations/2024/02/15/Decorated-Program.html" rel="alternate" type="text/html" title="Hoare Logic - Decorated Program" /><published>2024-02-15T00:00:00+00:00</published><updated>2024-02-15T10:47:25+00:00</updated><id>/software-foundations/2024/02/15/Decorated%20Program</id><content type="html" xml:base="/software-foundations/2024/02/15/Decorated-Program.html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#decorated-programs" id="markdown-toc-decorated-programs">Decorated Programs</a>    <ul>
      <li><a href="#simplified-decorated-programs" id="markdown-toc-simplified-decorated-programs">Simplified Decorated Programs</a></li>
    </ul>
  </li>
  <li><a href="#automated-verification" id="markdown-toc-automated-verification">Automated Verification</a></li>
  <li><a href="#finding-loop-invariants" id="markdown-toc-finding-loop-invariants">Finding loop invariants</a></li>
  <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
  <li><a href="#referrecne" id="markdown-toc-referrecne">Referrecne</a></li>
</ul>

<h2 id="decorated-programs">Decorated Programs</h2>
<p>The aesthetics of Hoare Logic is that it follows the structure of the program itself, which enables a powerful way to reason about a program – by decoration.</p>

<p>This naive program which subtracts a number is from the PLT series<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</p>
<pre><code class="language-plain">{{ True }} -&gt;&gt; // 1
{{ m = m }}
  X := m
		 {{ X = m }} -&gt;&gt;
		 {{ X = m /\ p = p }};
  Z := p;
		 {{ X = m /\ Z = p }} -&gt;&gt;
		 {{ Z - X = p - m }}
  while X ≠ 0 do
		 {{ Z - X = p - m /\ X ≠ 0 }} -&gt;&gt;
		 {{ (Z - 1) - (X - 1) = p - m }}
	Z := Z - 1
		 {{ Z - (X - 1) = p - m }};
	X := X - 1
		 {{ Z - X = p - m }} // 2
  end
{{ Z - X = p - m /\ ¬(X ≠ 0) }} -&gt;&gt;
{{ Z = p - m }}
</code></pre>

<p>In this example, we showed that the result of the program is indeed <code class="language-plaintext highlighter-rouge">p - m</code> by a <em>decorated proof</em>. Each line accompanies an assertion which states the condition that the program state meets. The mark 1 “narrows down” the assertion, which is discussed in the previous article<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>. To remind it, we can use a weaker assertion to replace a stronger one to meet the requirement of the proof goal. The <em>loop invariant</em> (mark 2) states the condition that the loop satisfies. For assignments, conditions and most other commands that do not involve loops, finding the assertions is fairly easy by following the rules of Hoare Logic. We could see finding loop invariant is the creative part of this art.</p>

<p>One could prove a decorated proof is indeed logically correct by an almost automated process - a “prover” (proof assistant) could look at each assertion and line of programs to decide if the deduction is correct. The reason why it could be automated is that the rules of Hoare logic are mechanical enough, as discussed in the previous post<sup id="fnref:2:1" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>.</p>
<h3 id="simplified-decorated-programs">Simplified Decorated Programs</h3>
<p>The straightforward way to formalize a decorated program is to present two assertions to each one command. Just like the classic Hoare logic statement:
\({\displaystyle \{P\}C\{Q\}}\)
But it turns out to be too verbose that even reading it makes people frustrated.  A decorated program which contains two <code class="language-plaintext highlighter-rouge">skip</code> would look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{{P}} ({{P}} skip {{P}}) ; ({{P}} skip {{P}}) {{P}}
</code></pre></div></div>

<p>An obvious observation is that for two sequential commands, the postcondition of the former one is the precondition of the later one. So we could agree that it’s sound to remove one of it.</p>

<p>For <code class="language-plaintext highlighter-rouge">skip</code> command, apparently, the assertion should not change after the execution. So we don’t need to provide the precondition.</p>
<blockquote>
  <p>[!NOTE] Discussion
Why not omit the postconditions instead? Because the preconditions are always provided either from the start of the program or from the previous command.</p>
</blockquote>

<p>Similarly, we could only provide postconditions of assignments, as the preconditions could be derived easily.</p>

<p>Loops <code class="language-plaintext highlighter-rouge">while b do d</code> can be simplified by omitting the assertion inside the commands because they can be derived from the preconditions and the postconditions.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while b do {{ P }} d end {{ Q }}
</code></pre></div></div>

<p>At last, we arrived to the simplified version of decorated programs, which can be implemented in Coq with some notation magic. The full implementation could be found on<sup id="fnref:1:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</p>
<h2 id="automated-verification">Automated Verification</h2>
<p>A decorated program could be translated to a sequence of verification conditions. By reading each line of the program and the related condition, a proof assistant is able to decide whether the condition could be satisfied.</p>

<p>Let’s look at the standard Hoare triple:
\({\displaystyle \{P\}C\{Q\}}\)
The condition is whether the Hoare triple could be proved <em>valid</em>. The command $C$ might be composed by a sequence of commands, and they can be verified mechanically.  Formally, a proof assistant would walk recursively into the command $C$ and generated a big conjunction that checks</p>
<ul>
  <li><em>Local consistency</em> of each command and</li>
  <li>To “bridge the gap” try to narrow down the assertion found in the program and the assertion imposed by the context. This post adopts the notation  <code class="language-plaintext highlighter-rouge">-&gt;&gt;</code> to notate this “narrowing down” from PLT series<sup id="fnref:1:2" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  "P-&gt;&gt;Q" &lt;-&gt; forall (st: State), P st -&gt; Q st
</code></pre></div>    </div>
  </li>
</ul>

<p>A decorated command is local consistent with a precondition <code class="language-plaintext highlighter-rouge">P</code> if</p>
<ul>
  <li>it is a skip <code class="language-plaintext highlighter-rouge">skip;{Q}</code> and  <code class="language-plaintext highlighter-rouge">P -&gt;&gt; Q</code>.</li>
  <li>it is an assignment <code class="language-plaintext highlighter-rouge">X:=a {Q}</code> and <code class="language-plaintext highlighter-rouge">P -&gt;&gt; Q[X|-&gt;a]</code></li>
  <li>it is a condition
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  if b then {{P1}} d1 else {{P2}} d2 end {{Q}}
</code></pre></div>    </div>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">P /\ b -&gt;&gt; P1</code></li>
      <li><code class="language-plaintext highlighter-rouge">P /\ ~b -&gt;&gt; P2</code></li>
      <li><code class="language-plaintext highlighter-rouge">post P1 -&gt;&gt; Q</code></li>
      <li><code class="language-plaintext highlighter-rouge">post P2 -&gt;&gt; Q</code>
  where <code class="language-plaintext highlighter-rouge">post</code> is to get the postcondition of a decorated program</li>
    </ul>
  </li>
  <li>it is a loop
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  while b do {{Q}} d end {{R}}
</code></pre></div>    </div>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">P /\ b -&gt;&gt; Q</code></li>
      <li><code class="language-plaintext highlighter-rouge">P /\ ~b -&gt;&gt; R</code></li>
      <li><code class="language-plaintext highlighter-rouge">post d /\ b -&gt;&gt; Q</code></li>
      <li><code class="language-plaintext highlighter-rouge">post d /\ ~b -&gt;&gt; R</code></li>
    </ul>
  </li>
  <li>if all explicit usages of <code class="language-plaintext highlighter-rouge">-&gt;&gt;</code> are valid</li>
</ul>

<p>Following these rules, an automated proof program could be developed.</p>
<h2 id="finding-loop-invariants">Finding loop invariants</h2>
<p>Once the outermost precondition and postcondition are chosen, the only left creative part of this “decorated” art is finding the loop invariants. You can’t choose an invariant that is too weak (such as <code class="language-plaintext highlighter-rouge">st -&gt; True</code>), because you’d need it to bridge the following conditions. Similarly, you can’t choose an invariant that is too strong, because it would be extremely hard or impossible to prove. It is indeed an art of finding the most appropriate loop invariants.</p>

<p>There is no silver bullet to solve the problem, but a few tips might help:</p>
<ul>
  <li>Try to use the strongest condition as the invariant first (the postcondition of the loop), and see what made it fails. Then adjust the invariants to a more “realistic one”</li>
  <li>Think about what the loop does and, how, by the end of the loop, the assertion <code class="language-plaintext highlighter-rouge">Q /\ b</code> is useful for proving the postcondition.</li>
  <li>What variables are used in the loop and how to propagate these variables into the information that the invariant carries.</li>
</ul>

<h2 id="summary">Summary</h2>
<ul>
  <li>Decorated Programs could be viewed as proofs of programs.</li>
  <li>Simplified Decorated Programs are equivalent to a fully decorated one, and it could help to avoid verbose, and thus, easier to read.</li>
  <li>The verification of a decorated program could be made automated.</li>
  <li>Finding loop invariants is relatively hard in this art.</li>
</ul>

<h2 id="referrecne">Referrecne</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>https://softwarefoundations.cis.upenn.edu/plf-current/Hoare2.html <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:1:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:1:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>https://excitedspider.github.io/software-foundations/2024/02/02/Hoare-Logic-Basic.html <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:2:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
  </ol>
</div>]]></content><author><name>Chew Y. Feng</name></author><category term="Software-Foundations" /><category term="Coq" /><category term="PLT" /><summary type="html"><![CDATA[Decoration and Automated Verification]]></summary></entry></feed>