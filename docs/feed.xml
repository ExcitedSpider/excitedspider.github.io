<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2025-06-20T06:12:29+00:00</updated><id>/feed.xml</id><title type="html">Chew’s Everyday Blog</title><subtitle>A blog of a CS student.</subtitle><author><name>Chew Y. Feng</name></author><entry><title type="html">An Abstract Interpretor Based on Compositional Semantics</title><link href="/pl/2025/06/18/an-abstract-interpreter.html" rel="alternate" type="text/html" title="An Abstract Interpretor Based on Compositional Semantics" /><published>2025-06-18T00:00:00+00:00</published><updated>2025-06-19T09:58:58+00:00</updated><id>/pl/2025/06/18/an-abstract-interpreter</id><content type="html" xml:base="/pl/2025/06/18/an-abstract-interpreter.html"><![CDATA[<object data="/pdfs/abstract-interpreter-compositional-semantics/main.pdf" width="1000" height="1000" type="application/pdf"></object>]]></content><author><name>Chew Y. Feng</name></author><category term="PL" /><category term="PL" /><summary type="html"><![CDATA[A study note.]]></summary></entry><entry><title type="html">WSL – File System, Networking, Configuration</title><link href="/os/2025/02/22/WSL-FS-Network-Conf.html" rel="alternate" type="text/html" title="WSL – File System, Networking, Configuration" /><published>2025-02-22T00:00:00+00:00</published><updated>2025-02-25T00:37:25+00:00</updated><id>/os/2025/02/22/WSL-FS-Network-Conf</id><content type="html" xml:base="/os/2025/02/22/WSL-FS-Network-Conf.html"><![CDATA[<h2 id="background">Background</h2>

<p>I’m a Windows user, and Windows Subsystem Linux (WSL) is the most frequent tool I need to use. 
I use WSL primarily for coding and dev, while Windows for entertaining.
My goal is <strong>not installing anything related to coding in Windows</strong>.
However, I find that I have little knowledge about how it works.
It sometimes makes me confused. 
So I decided to spend sometime and take a note about it.</p>

<h2 id="overview">Overview</h2>

<p>WSL 2 uses virtualization to run a Linux kernel inside a VM.
WSL 2 features</p>
<ul>
  <li>Faster File IO</li>
  <li>Full System Call Compatibility
      This allows full access to Linux apps like Docker (why)</li>
</ul>

<p>Architecture Change from WSL 1</p>
<ul>
  <li>WSLv1 uses a translation-based approach, which translates a Linux system call to Windows kernel. 
      This approach can be less compatible because system calls in win and Linux can have different semantics. 
      It also slows down the IO speed somehow.</li>
  <li>WSLv2 is VM-based approach. It has a full Linux kernel.</li>
</ul>

<h2 id="working-with-file-system">Working with File System</h2>

<p>You can run Linux tools from a Windows Command Line</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#powershell</span>
wsl <span class="nb">ls</span> <span class="nt">-la</span>
wsl <span class="nb">ls</span> <span class="nt">-la</span> <span class="s2">"/mnt/c/Program Files"</span> <span class="c"># note that you need to use linux file path  </span>
</code></pre></div></div>

<p>You can also run Windows tools in WSL by <code class="language-plaintext highlighter-rouge">[tool-name].exe</code></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#bash</span>
ipconfig.exe | <span class="nb">grep </span>IPv4 | <span class="nb">cut</span> <span class="nt">-d</span>: <span class="nt">-f2</span>
</code></pre></div></div>

<h2 id="configuration">Configuration</h2>

<p>WSL allows user providing a configuration file <code class="language-plaintext highlighter-rouge">%UserProfile%/.wslconfig</code>. 
See <a href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config#main-wsl-settings">Main WSL Settings</a> for the full configuration table.</p>

<p>By the way, I prefer using WSL setting app for config.</p>

<h2 id="networking-consideration">Networking Consideration</h2>

<p>Currently, WSL2 offers two modes of networking: NAT and Mirrored.</p>

<h3 id="nat-mode">NAT Mode</h3>

<p>NAT Mode means that WSL is running in a <strong>virtualized network environment</strong> where it is assigned with a <strong>private IP address</strong>, and Windows serves as the adapter.</p>

<p><strong>Accessing Internet from WSL</strong></p>

<p>WSL runs on NAT mode implies that Windows serves as the adapter, rewriting request from WSL with its IP.</p>

<p>Try this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; wsl curl 'https://api.ipify.org?format=json'
&gt; curl 'https://api.ipify.org?format=json'
</code></pre></div></div>

<p>The API simply returns the IP of the client. 
You can see that both are identical and is the IP address of the Windows.</p>

<p>Another experiment is that, you can trace network packets:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>traceroute google.com <span class="c"># On wsl</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tracert google.com <span class="c"># On wsl</span>
</code></pre></div></div>

<p>You will find that both are identical <strong>except there is one more jump from WSL to Windows</strong></p>

<p><strong>Accessing WSL from Windows</strong></p>

<p>On Windows, you can access networking apps in WSL using localhost. There is an auto-forwarding feature working:</p>

<p><img src="/assets/images/Pasted%20image%2020250222170500.png" alt="Experiment: Accessing WSL Networking application " /></p>

<p>You can also access networking apps by using the assigned IP address of WSL.</p>

<p>The Windows host can use this command to query the IP address</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">&gt;</span><span class="w"> </span><span class="n">wsl</span><span class="w"> </span><span class="nt">-d</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">DistributionName</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">hostname</span><span class="w"> </span><span class="nt">-I</span><span class="w">
</span></code></pre></div></div>

<p><strong>Accessing WSL from LAN</strong></p>

<p>To enable devices on your LAN to access WSL, it needs proper proxy setup. See <a href="https://learn.microsoft.com/en-us/windows/wsl/networking#accessing-a-wsl-2-distribution-from-your-local-area-network-lan">Accessing a WSL 2 distribution from your local area network (LAN)</a></p>

<h3 id="mirrored-networking-mode">Mirrored Networking Mode</h3>

<p>In mirrored mode, WSL works as <strong>if they are the same machine in network</strong>. Benefits are:</p>
<ul>
  <li>IPv6 Support</li>
  <li>Connect to Windows servers from within Linux using the localhost address <code class="language-plaintext highlighter-rouge">127.0.0.1</code>.</li>
  <li>Improved networking compatibility for VPNs</li>
  <li>Connect to WSL directly from your local area network (LAN)</li>
</ul>

<p>It implies that both Windows and WSL Apps connect to the same physical network of the Windows host.</p>

<p>The VM “mirrors” all network settings from Windows.</p>

<p>This can be validate by tracing network parcels:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># on WSL
traceroute google.com
</code></pre></div></div>

<p>You will find there is not a jump to Windows host.</p>

<p>The only thing we know about the implementation is that it utilizes Hyper-V virtual switch feature. 
MS do not share more detailed information about it.</p>

<h2 id="mounting-a-device">Mounting a Device</h2>

<blockquote>
  <p>Shout out to [https://askubuntu.com/questions/1116200/how-can-i-access-my-usb-drive-from-my-windows-subsystem-for-linux-ubuntu-dist]</p>
</blockquote>

<p>Suppose there is a new USB device mounted on G: on windows. 
To access it on WSL:</p>

<ol>
  <li>Create the mount point: <code class="language-plaintext highlighter-rouge">mkdir /mnt/g</code></li>
  <li>Mount the drive to the directory using <code class="language-plaintext highlighter-rouge">sudo mount -t drvfs G: /mnt/g</code></li>
</ol>

<h1 id="references">References</h1>
<ol>
  <li>MS WSL Doc https://learn.microsoft.com/en-us/windows/wsl/about</li>
  <li>Intro to WSL2 Video https://youtu.be/MrZolfGm8Zk?si=pRhVjzF84i49Zoqi</li>
</ol>]]></content><author><name>Chew Y. Feng</name></author><category term="OS" /><category term="OS" /><summary type="html"><![CDATA[My story with Linux subsystem.]]></summary></entry><entry><title type="html">Simply Typed Lambda-Calculus</title><link href="/software-foundations/2024/07/18/Simple-Typed-Lambda-Calculus.html" rel="alternate" type="text/html" title="Simply Typed Lambda-Calculus" /><published>2024-07-18T00:00:00+00:00</published><updated>2024-07-18T07:28:57+00:00</updated><id>/software-foundations/2024/07/18/Simple-Typed-Lambda-Calculus</id><content type="html" xml:base="/software-foundations/2024/07/18/Simple-Typed-Lambda-Calculus.html"><![CDATA[<p>This article is a study note of <a href="https://softwarefoundations.cis.upenn.edu/plf-current/Stlc.html">Programming Language Foundation</a></p>

<h2 id="overview">Overview</h2>

<p>The simply typed lambda calculus (STLC) is a wonderful study target which represents many intriguing language features among modern programming language.</p>

<p>Lambda calculus (also written as λ-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution (From Wikipedia).</p>

<p>Consider a lambda-calculus system that only contains Boolean values, which can be expressed by following BNF notation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>t ::= x                      (variable)
 | \x:T,t                    (abstraction)
 | t t                       (application)
 | true                      (constant true)
 | false                     (constant false)
 | if t then t else t        (conditional)
</code></pre></div></div>

<p>Examples:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">\</span><span class="n">x</span><span class="o">:</span> <span class="n">Bool</span><span class="p">,</span> <span class="n">x</span> <span class="c1">// identity function</span>
<span class="p">(</span><span class="err">\</span><span class="n">x</span><span class="o">:</span> <span class="n">Bool</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="nb">true</span> <span class="c1">// apply the identity function to value true</span>
<span class="err">\</span><span class="n">x</span><span class="o">:</span><span class="n">Bool</span><span class="p">,</span><span class="err"> </span><span class="k">if</span><span class="err"> </span><span class="n">x</span><span class="err"> </span><span class="n">then</span><span class="err"> </span><span class="nb">false</span><span class="err"> </span><span class="k">else</span><span class="err"> </span><span class="nb">true</span> <span class="c1">// function 'not'</span>
<span class="err">\</span><span class="n">f</span><span class="o">:</span><span class="n">Bool</span><span class="err">→</span><span class="n">Bool</span><span class="p">,</span><span class="err"> </span><span class="n">f</span><span class="err"> </span><span class="p">(</span><span class="n">f</span><span class="err"> </span><span class="nb">true</span><span class="p">)</span> <span class="c1">// a higher order function</span>
</code></pre></div></div>

<p>Although it only contains Boolean values, it processes the computation ability that equivalent any modern programming languages. It even supports higher order function that some “modern” languages don’t support well, like C and C++.</p>

<p>Note that there are variables involved in the definition. A <em>complete</em> program is a program that never refer to any undefined variables. In most time, we want the program to be complete and we can simply fail there are free variables (which doesn’t bind to any terms and types).</p>
<h2 id="operational-semantics">Operational Semantics</h2>

<h3 id="values">Values</h3>

<p>To decide what are the <em>values</em> of STLC, a little discussion is needed on the case of abstraction. An abstraction (similar to a “function” in imperative programming language) is of such form</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\x:T, t
</code></pre></div></div>

<p>There are two choices:</p>
<ol>
  <li>An abstraction is always a value</li>
  <li>An abstraction is a value if <code class="language-plaintext highlighter-rouge">t</code> is a value</li>
</ol>

<p>I would say I prefer option 1, and that is the choice in the textbook, because it makes things a lot easier. But option 2 is also the choice for some language, for some reasons like compile-time optimization.</p>

<h3 id="substitution">Substitution</h3>

<p>The heart of lambda calculus is substitution. For example, we reduce</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> (\x:Bool, if x then true else x) false
</code></pre></div></div>

<p>to</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if false then true else false
</code></pre></div></div>

<p>The application works by substitute <code class="language-plaintext highlighter-rouge">\x</code> into the bind value <code class="language-plaintext highlighter-rouge">false</code>. We mark the substitution as <code class="language-plaintext highlighter-rouge">[x:=s]t</code>, which literally says “substitute all occurrences of <code class="language-plaintext highlighter-rouge">x</code> into <code class="language-plaintext highlighter-rouge">s</code> in the term <code class="language-plaintext highlighter-rouge">t</code>”.</p>

<p>More example:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">[x:=true] (if x then x else y)</code> yields <code class="language-plaintext highlighter-rouge">if true then true else y</code></li>
  <li><code class="language-plaintext highlighter-rouge">[x:=true](\y:Bool,x)</code> yields <code class="language-plaintext highlighter-rouge">\y:Bool,true</code></li>
</ul>

<p>Substitution is a deterministic and easy problem (i.e. not a NP-hard one). So the textbook simply encoded substitution into a fixpoint function <code class="language-plaintext highlighter-rouge">subst</code>. It’s very interesting to think how a powerful computation model is just such a small substitution machine.</p>

<p>Exercise: 3 stars, standard (substi_correct)
This Exercise asks us to define substitution as a inductive relation <code class="language-plaintext highlighter-rouge">substi</code> , and prove the relation is equivalent to the fixpoint version.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">substi</span><span class="w"> </span><span class="o">(</span><span class="no">s</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kr">Prop</span><span class="w">

</span><span class="k">Theorem</span><span class="w"> </span><span class="no">substi_correct</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="no">t'</span><span class="o">,</span><span class="w">
  </span><span class="o">&lt;{</span><span class="w"> </span><span class="o">[</span><span class="no">x</span><span class="p">:</span><span class="o">=</span><span class="no">s</span><span class="o">]</span><span class="no">t</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">t'</span><span class="w"> </span><span class="o">&lt;-&gt;</span><span class="w"> </span><span class="no">substi</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="no">t'</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>For direction <code class="language-plaintext highlighter-rouge">-&gt;</code>, it can be proved by induction on term <code class="language-plaintext highlighter-rouge">t</code></li>
  <li>For direction <code class="language-plaintext highlighter-rouge">&lt;-</code>, it can be proved by induction on relation <code class="language-plaintext highlighter-rouge">substi</code></li>
</ul>

<h3 id="reduction">Reduction</h3>

<p>Based on substitution, we can define how an expression is <em>reduced</em> to value. The core of reduction is the application rule, which says</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(\x:T,t) v --&gt; [x:=v] t
</code></pre></div></div>

<p>To make the process of reduction to be deterministic, we made a design: 
<strong>Apply reduction of application expression only if both the left-hand side (the abstraction) and the right-hand side (the argument) is a value.</strong></p>

<h2 id="typing">Typing</h2>

<p>The STLC has a powerful feature – typing, which becomes more and more important in programming language design. For some reasons, computer scientists write typing relation as following form:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|-- t \in T
</code></pre></div></div>

<p>which says that “term t has type T”.</p>

<p>An obvious problem is typing abstractions. Consider such abstraction:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\x:T1, t2
</code></pre></div></div>

<p>which has type <code class="language-plaintext highlighter-rouge">T1 -&gt; T2</code>. If we want to typecheck it, we need to make sure term <code class="language-plaintext highlighter-rouge">t2</code> has type <code class="language-plaintext highlighter-rouge">T2</code> <strong>under the context that <code class="language-plaintext highlighter-rouge">x</code> has type <code class="language-plaintext highlighter-rouge">T1</code>.</strong></p>

<p>Context can be represented as a single global information, which adds to the typing relation. A map (partial-map) is capable of representing such information, which we name it <em>Gamma</em>. The new typing judgment is written <code class="language-plaintext highlighter-rouge">Gamma |-- t \in T</code> and informally read as “term t has type T, given the types of free variables in t as specified by Gamma”.</p>

<p>Examples:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Example</span><span class="w"> </span><span class="no">typing_example_1</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="no">empty</span><span class="w"> </span><span class="o">|--</span><span class="w"> </span><span class="err">\</span><span class="no">x</span><span class="p">:</span><span class="no">Bool</span><span class="o">,</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="err">\</span><span class="kr">in</span><span class="w"> </span><span class="o">(</span><span class="no">Bool</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">Bool</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>Finally, we present the typing rule of abstraction:</p>

<p>\(\frac{x \mapsto T2 ; \Gamma \vdash t1 \in T1}{
\Gamma \vdash \backslash x:T2,t1 \in T2\to T1
}\)
Other rules can be found in the textbook as well.</p>

<p>Talking about variables, a term is <em>closed</em> if all variables in it are well typed (contain no free variables).</p>

<h2 id="properties-of-stlc">Properties of STLC</h2>

<p>We discuss what makes the language to be “well and sound”.</p>

<h3 id="canonical-form">Canonical Form</h3>

<p>We can establish the relation between well-typed values (canonical form)  and their type. For example, if a value has type <code class="language-plaintext highlighter-rouge">Bool</code>, it must be a <code class="language-plaintext highlighter-rouge">false</code> or <code class="language-plaintext highlighter-rouge">true</code>.</p>
<h3 id="progress">Progress</h3>

<p>The progress theorem tells us that closed, well-typed terms are not stuck: either a well-typed term is a value, or it can take a reduction step.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">progress</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="no">T</span><span class="o">,</span><span class="w">
  </span><span class="no">empty</span><span class="w"> </span><span class="o">|--</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="err">\</span><span class="kr">in</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="p">→</span><span class="w">
  </span><span class="no">value</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="o">\/</span><span class="w"> </span><span class="p">∃</span><span class="w"> </span><span class="no">t'</span><span class="o">,</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="no">t'</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>Exercise: 3 stars, advanced (progress_from_term_ind).</p>

<p>It asks us to prove theorem <code class="language-plaintext highlighter-rouge">progess</code> by induction on terms. The proof is a bit long but not complicated. Just follow the reduction rules to see if it can make a step, or it is a value, or there is a contradiction in hypothesis.</p>

<h3 id="preservation">Preservation</h3>

<p>The preservation theorem says reduction doesn’t change the type of a term (so it <em>preserves</em> the type). This property shows our typing is indeed sound and well-fitted into the operational semantics.</p>

<p>To establish the preservation property on STLC, we take a few steps:</p>
<ol>
  <li>The Weakening Lemma, which says if <code class="language-plaintext highlighter-rouge">t</code> has type <code class="language-plaintext highlighter-rouge">T</code> in some context <code class="language-plaintext highlighter-rouge">Gamma</code>and  <code class="language-plaintext highlighter-rouge">Gamma</code> is included in a bigger context <code class="language-plaintext highlighter-rouge">Gamma'</code>, t also has type <code class="language-plaintext highlighter-rouge">T</code> in <code class="language-plaintext highlighter-rouge">Gamma'</code>.
 To prove this, one need to consider what “a context is included in other context” means. But it’s fairly straightforward.</li>
  <li>The Substitution Lemma, which says substitution preserves the type.</li>
  <li>The main theorem. With the help of substitution lemma, it can be proved with ease.</li>
</ol>

<p>Exercise: 3 stars, advanced (substitution_preserves_typing_from_typing_ind)
It asks us to prove the substitution lemma, which lies at the heart of this proof chain. A few tips:</p>
<ul>
  <li>Read carefully about the informal proof provided by the author.</li>
  <li>When encounter <code class="language-plaintext highlighter-rouge">(x =? y)%string</code> (string equality), use <code class="language-plaintext highlighter-rouge">destruct eqb_spec</code> to perform case analysis.</li>
  <li>When the goal is the form <code class="language-plaintext highlighter-rouge">Gamma |-- t \in T</code>, you can use the weakening lemma to transform it to <code class="language-plaintext highlighter-rouge">empty |-- t \in t</code>.</li>
</ul>

<p>Exercise: 2 stars, standard, especially useful (subject_expansion_stlc)
Show that the reverse to preservation theorem does not hold. That is, if <code class="language-plaintext highlighter-rouge">t --&gt; t'</code> and <code class="language-plaintext highlighter-rouge">t' \in T</code>, we can not make sure <code class="language-plaintext highlighter-rouge">t \in T</code>.
I exploit the fact that reduction doesn’t type check.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(* t *) exists &lt;{ (\x: Bool -&gt; Bool, x) true }&gt;.
(* t'*) exists &lt;{ true }&gt;.
(* T *) exists &lt;{ Bool }&gt;.
</code></pre></div></div>
<p>It’s a little bit cheating, I admit. But I can’t find a better one.</p>
<h3 id="type-soundness">Type Soundness</h3>

<p>Put progress and preservation together, we can show that a well-typed term can <em>never</em> reach a stuck state.</p>

<p>Exercise: 2 stars, standard, optional (type_soundness)
Type soundness can be proved by induction on Hmulti (<code class="language-plaintext highlighter-rouge">t --&gt;* t'</code>).</p>

<h3 id="uniqueness-of-types">Uniqueness of Types</h3>

<p>Another nice property of the STLC is that types are unique: a given term (in a given context) has at most one type.</p>

<p>Exercise: 3 stars, standard (unique_types)
This exercise can be solved by induction on term <code class="language-plaintext highlighter-rouge">e</code>. The whole proof heavily use inversion to do case analysis.</p>

<h2 id="extension-to-stlc">Extension to STLC</h2>

<p>One might argue that the current STLC is still too simple and cannot match a real modern programming language. Well, there are a lot of extensions to STLC in the textbook to show the possibility of the language.</p>

<ul>
  <li>Numbers.</li>
  <li>Let bindings, which adds the let expression like those in Haskell.</li>
  <li>Pairs, which are popular in many languages. For example, I can have a pair of <code class="language-plaintext highlighter-rouge">(1, false)</code> of type <code class="language-plaintext highlighter-rouge">(Nat, Bool)</code></li>
  <li>Unit. A unit type is a type that only has one value. It can be quite helpful to express things like <code class="language-plaintext highlighter-rouge">null</code>, <code class="language-plaintext highlighter-rouge">nullptr</code></li>
  <li>Sums. A sum is like the <code class="language-plaintext highlighter-rouge">Either</code> monads In Haskell.</li>
  <li>Lists.</li>
  <li>Recursion (Recursive Abstraction)</li>
  <li>Records. Like dictionary in python.</li>
</ul>

<p>The exercises in this chapter is to formalize these features, including the substitution, reduction and typing. I would say it is quite straightforward to follow the informal definition given by the author, and satisfying to see how it works.</p>]]></content><author><name>Chew Y. Feng</name></author><category term="Software-Foundations" /><category term="Coq" /><category term="PLT" /><summary type="html"><![CDATA[A small yet powerful language]]></summary></entry><entry><title type="html">Small-Step Operational Semantics</title><link href="/software-foundations/2024/06/22/Small-Steps.html" rel="alternate" type="text/html" title="Small-Step Operational Semantics" /><published>2024-06-22T00:00:00+00:00</published><updated>2024-06-22T05:27:12+00:00</updated><id>/software-foundations/2024/06/22/Small-Steps</id><content type="html" xml:base="/software-foundations/2024/06/22/Small-Steps.html"><![CDATA[<p>Even if I have walked through all the content and practices in the <a href="https://softwarefoundations.cis.upenn.edu/plf-current/Smallstep.html">textbook</a>, it still confuses me about what “Small-Step Operational Semantics” is. It is partly because the study of the chapter is segmented into pieces because I have to only use my free time to do it. It also because this chapter is way too long such that one can’t get to the important points immediately.</p>

<h2 id="small-step-semantics">Small-step Semantics</h2>

<p><em>Small-step</em> means the evaluation of the semantics from the program can be carried out step-by-step. Some would also describe it as “structural operational semantics” because the the method usually follows the structure of programs. It might takes multiple steps to get the final semantics of a statement. Conversely, <em>natural semantics</em> directly evaluate a statement to the final state, which can be steadily implemented in a evaluation function.</p>

<p>For example, given the statement</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(1 + 3) + (2 + 4)
</code></pre></div></div>

<p>It might takes multiple steps to get the semantics:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(4) + (2 + 4)
(4) + (6)
10 &lt;-- final semantics
</code></pre></div></div>

<p>There are two reasons (the textbook gives) to recommend small-step semantics instead of natural semantics.</p>
<ul>
  <li>We includes the intermediate states that it passes through along the way. Observable execution is critical in many situation.</li>
  <li>By only define one-step evaluation, we allow <em>undefined behaviours</em> in the program.</li>
</ul>

<h2 id="implementation-comparison">Implementation Comparison</h2>

<p>Compared to natural semantics, the implementation of small-step would be more complicated – a single function can’t suffice. Fortunately we are doing this in Coq, which has a very power tool  – Inductive type.</p>

<p>In the most naïve language where there are only constant (denotes by C) and addition (denotes by P), the informal semantics are:</p>

\[\frac{}{C~n \to n}\]

\[\frac{t_1 \to n_1,~t_2\to n_2}{P~t_1~t_2 \to n_1 + n_2}\]

<p>The formal semantics can be encoded in Coq:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">C</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="c">(* Constant *)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">tm</span><span class="pi">.</span><span class="w"> </span><span class="c">(* Plus *)</span><span class="w">
</span></code></pre></div></div>

<p>The natural semantics is a function defined in a very straightforward way</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Fixpoint</span><span class="w"> </span><span class="no">evalF</span><span class="w"> </span><span class="o">(</span><span class="no">t</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">C</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">n</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="no">t2</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">evalF</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">evalF</span><span class="w"> </span><span class="no">t2</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>This evaluation function can easily handle statement such as:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">C 3</code></li>
  <li><code class="language-plaintext highlighter-rouge">P (C 3) (C 5)</code></li>
  <li><code class="language-plaintext highlighter-rouge">P (C 3) (P (C 2) (C 3))</code></li>
</ul>

<p>Conversely, the small step semantics involves a inductive relation describing how to take a step forward:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">step</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">ST_PlusConstConst</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">n1</span><span class="w"> </span><span class="no">n2</span><span class="o">,</span><span class="w">
      </span><span class="no">P</span><span class="w"> </span><span class="o">(</span><span class="no">C</span><span class="w"> </span><span class="no">n1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">C</span><span class="w"> </span><span class="no">n2</span><span class="o">)</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="no">C</span><span class="w"> </span><span class="o">(</span><span class="no">n1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">n2</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">ST_Plus1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="no">t1'</span><span class="w"> </span><span class="no">t2</span><span class="o">,</span><span class="w">
      </span><span class="no">t1</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="no">t1'</span><span class="w"> </span><span class="p">→</span><span class="w">
      </span><span class="no">P</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="no">t2</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">t1'</span><span class="w"> </span><span class="no">t2</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">ST_Plus2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">n1</span><span class="w"> </span><span class="no">t2</span><span class="w"> </span><span class="no">t2'</span><span class="o">,</span><span class="w">
      </span><span class="no">t2</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="no">t2'</span><span class="w"> </span><span class="p">→</span><span class="w">
      </span><span class="no">P</span><span class="w"> </span><span class="o">(</span><span class="no">C</span><span class="w"> </span><span class="no">n1</span><span class="o">)</span><span class="w"> </span><span class="no">t2</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="o">(</span><span class="no">C</span><span class="w"> </span><span class="no">n1</span><span class="o">)</span><span class="w"> </span><span class="no">t2'</span><span class="w">

  </span><span class="no">where</span><span class="w"> </span><span class="s2">" t '--&gt;' t' "</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">step</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="no">t'</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>And another inductive relation which defines a multi step evaluation as multiple consecutive single-step evaluations:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">multi</span><span class="w"> </span><span class="o">{</span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">R</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">relation</span><span class="w"> </span><span class="no">X</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">relation</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">multi_refl</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">X</span><span class="o">),</span><span class="w"> </span><span class="no">multi</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">x</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">multi_step</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">X</span><span class="o">),</span><span class="w">
                    </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="p">→</span><span class="w">
                    </span><span class="no">multi</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="w"> </span><span class="p">→</span><span class="w">
                    </span><span class="no">multi</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">z</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>This example shows the difference. You can clearly see that small-step semantics is quite complicated compared to natural semantics, which is only a function.</p>

<h2 id="properties-of-small-step-semantics">Properties of Small-step Semantics</h2>

<h3 id="deterministic">Deterministic</h3>

<p>Firstly, given two same programs, the semantics that we found should be identical. In other word, there should be no randomness get in the way for this tiny toy language. This property is called <em>deterministic</em>.</p>

<p><strong>Deterministic Property</strong>: “for each t, there is at most one t’ such that t steps to t’ (t –&gt; t’ is provable).”</p>

<p>It sounds intuitive but the proof is not so straightforward. Readers can check the textbook <code class="language-plaintext highlighter-rouge">Theorem step_deterministic</code> if interested.</p>
<h3 id="values">Values</h3>

<p>There is a slight problem. When dealing with expressions such as</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P (P (C 1) (C 3)) (P (C 2) (C 4))
</code></pre></div></div>

<p>There are actually two directions to step forward: – either handle 1 + 3 or 2 + 4, which results in different intermediate states. This is not we typically want and sometimes causes trouble.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">P</span> <span class="p">(</span><span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">4</span><span class="p">))</span>
<span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">4</span><span class="p">))</span>
<span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">6</span><span class="p">)</span>
<span class="kt">C</span> <span class="mi">10</span>
<span class="c1">-- or</span>
<span class="kt">P</span> <span class="p">(</span><span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">4</span><span class="p">))</span>
<span class="kt">P</span> <span class="p">(</span><span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">6</span><span class="p">)</span>
<span class="kt">P</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="kt">C</span> <span class="mi">6</span><span class="p">)</span>
<span class="kt">C</span> <span class="mi">10</span>
</code></pre></div></div>

<p>This problem can be solved by defining <em>values</em>. We always want the final term to be some special forms, which we called <em>values</em>. In this language, we expect the final semantics to some constant terms.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">v_const</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">n</span><span class="o">,</span><span class="w"> </span><span class="no">value</span><span class="w"> </span><span class="o">(</span><span class="no">C</span><span class="w"> </span><span class="no">n</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>With the concepts of value, we revise the definition of steps:</p>

\[\frac{t_1 \to t_1',}{P~t_1~t_2 \to P~t_1'~t_2}\]

\[\frac{\text{value}~t_1,~t_2\to t_2'}{P~t_1~t_2 \to P~t_1~t_2'}\]

<p>The second one is crucial. It says we take the step of $t_2$ only when t1 is a value. This definition ensures we always evaluate the first argument (t1) until it reaches the form of value.</p>

<p>The usage of values doesn’t limit to this. In fact, they are very important and critical in small-step semantics.</p>

<h3 id="progress-and-normal-forms">Progress and Normal Forms</h3>

<p>In a large language, sometimes people can easily forget one or more rules, which results in a incomplete definition. One should prove its semantics to be <em>strong progress</em> to show there is nothing left.</p>

<p><strong>Theorem Strong Progress</strong>: If t is a term, then either t is a value or else there exists a term t’ such that t–&gt;t’.</p>

<p>When there are statement that doesn’t make sense, we don’t want to define every possible combination of terms. For example, if there are lists in the language, how could <code class="language-plaintext highlighter-rouge">1 + []</code> proceeds? The solution is called <em>typed progress</em>, which involves defining type systems to distinguish what statement doesn’t make sense, and only well-typed terms are progress. We don’t discuss more about types in this article.</p>

<p>Terms that cannot make progress are called <em>normal forms</em>. In this language, only values cannot make a further step. This is quite something that suggests our definition tend to be correct. Why? Because value is a syntactic concept – it is defined by looking at the way a term is written – while normal form is a semantic one – it is defined by looking at how the term steps.</p>

<h2 id="multi-step-reduction">Multi-Step Reduction</h2>

<p>Recall how multi-step evaluation relation is defined:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">multi</span><span class="w"> </span><span class="o">{</span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">R</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">relation</span><span class="w"> </span><span class="no">X</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">relation</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">multi_refl</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">X</span><span class="o">),</span><span class="w"> </span><span class="no">multi</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">x</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">multi_step</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">X</span><span class="o">),</span><span class="w">
                    </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="p">→</span><span class="w">
                    </span><span class="no">multi</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="w"> </span><span class="p">→</span><span class="w">
                    </span><span class="no">multi</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">z</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>This relation has a few properties</p>
<ul>
  <li>It is obviously <em>reflexive</em> (from the rule <code class="language-plaintext highlighter-rouge">multi_refl</code>).</li>
  <li>In the second rule, it takes a step relation $R$ to define what is multi-step evaluation of $R$. This is called <em>closure</em> of <em>R</em>.</li>
  <li>Third, it is <em>transitive</em>. i.e. If <code class="language-plaintext highlighter-rouge">multi t1 t2</code> and <code class="language-plaintext highlighter-rouge">multi t2 t3</code>, we have <code class="language-plaintext highlighter-rouge">multi t1 t3</code></li>
</ul>

<h3 id="normal-forms-in-multi-steps">Normal Forms in Multi-Steps</h3>

<p>If t reduces to t’ in zero or more steps and t’ is a normal form, we say that “t’ is a normal form of t.”</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">normal_form_of</span><span class="w"> </span><span class="o">(</span><span class="no">t</span><span class="w"> </span><span class="no">t'</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">(</span><span class="no">t</span><span class="w"> </span><span class="o">--&gt;*</span><span class="w"> </span><span class="no">t'</span><span class="w"> </span><span class="p">∧</span><span class="w"> </span><span class="no">step_normal_form</span><span class="w"> </span><span class="no">t'</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>This definition is important because it define what is typically the end of the evaluation.</p>

<p>We have seen single-step evaluation is deterministic. Following that, we also want to ensure that if t can reach a normal form, then this normal form is unique.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This article explains what is small-step operational semantics and what are the properties that developers should be aware of.</p>]]></content><author><name>Chew Y. Feng</name></author><category term="Software-Foundations" /><category term="Coq" /><category term="PLT" /><summary type="html"><![CDATA[Finding the meaning of a program]]></summary></entry><entry><title type="html">Distributed Transactions</title><link href="/coursenote/2024/05/11/Distributed-Transactions.html" rel="alternate" type="text/html" title="Distributed Transactions" /><published>2024-05-11T00:00:00+00:00</published><updated>2024-05-11T06:45:56+00:00</updated><id>/coursenote/2024/05/11/Distributed-Transactions</id><content type="html" xml:base="/coursenote/2024/05/11/Distributed-Transactions.html"><![CDATA[<p>In a distributed DBMS, a transaction usually involves multiple servers. Consider a transaction that a client transfers 10 dollars from account A to C and then transfers 20 dollars from B to D, and each of these accounts is stored in different servers as shown in the graph. If any one server in this transaction fails, the whole transaction needs to abort.</p>

<p><img src="/assets/images/Pasted image 20240511143920.png" alt="DistributedTransaction" /></p>

<p>A client transaction becomes distributed if it invokes operations in several different servers. This document talks about the main strategies to achieve ACID properties for distributed transactions.</p>

<h2 id="two-phase-commit-protocol">Two-Phase Commit Protocol</h2>

<p>The two-phase commit protocol (2PC) was devised to ensure the atomicity property in a distributed DBMS. where the atomicity property requires that when a distributed transaction comes to an end, <strong>either all of its operations are carried out or none of them</strong>.</p>

<!-- ![[Pasted image 20240511143920.png]] -->

<p>In 2PC, firstly, a server is selected to be the coordinator, which communicates with the client and coordinate the work on all servers.</p>

<p><img src="/assets/images/Pasted image 20240511144355.png" alt="DistributedTransaction" />
<!-- ![[Pasted image 20240511144355.png]] --></p>

<p>In the first phase of 2PC, each participant votes for the transaction to be committed or aborted. Once a participant has voted to commit a transaction, it is not allowed to abort it. Therefore, before a participant votes to commit a transaction, <strong>it must ensure that it will eventually be able to carry out its part of the commit protocol</strong>, even if it fails. A participant to said to be in a <em>prepared</em> state if it votes to commit.</p>

<p>In the second phase of the protocol, the coordinator decides the final decision (either abort or commit), every participant in the transaction carries out the joint decision.</p>

<p>To formally define the protocol, we first list the operations (interfaces) in the protocol:</p>
<ul>
  <li><em>canCommit</em>(trans) Yes / No
    <ul>
      <li>Call from coordinator to participant to ask whether it can commit a transaction. Participant replies with its vote.</li>
    </ul>
  </li>
  <li>*doCommit(trans)
    <ul>
      <li>Call from coordinator to participant to commit its part of a transaction.</li>
    </ul>
  </li>
  <li><em>doAbort</em>(trans)
    <ul>
      <li>Call from coordinator to participant to abort its part of a transaction.</li>
    </ul>
  </li>
  <li><em>haveCommitted</em>(trans, participant)
    <ul>
      <li>Call from participant to coordinator to confirm that it has committed the transaction.</li>
      <li>Just for deleting stale information on the coordinator.</li>
    </ul>
  </li>
  <li><em>getDecision</em>(trans) -&gt; Yes / No
    <ul>
      <li>Call from participant to coordinator to ask for the decision on a transaction after it has voted Yes but has still had no reply after some delay. Used to recover from server crash or delayed messages.</li>
    </ul>
  </li>
</ul>

<p>Phase 1</p>
<ol>
  <li>The coordinator sends a <em>canCommit</em>? request to each of the participants in the transaction.</li>
  <li>When a participant receives a <em>canCommit</em>? request it replies with its vote (Yes or No) to the coordinator. Before voting Yes, it prepares to commit by saving objects in permanent storage. If the vote is No, the participant aborts immediately.</li>
</ol>

<p>Phase 2</p>
<ol>
  <li>The coordinator collects the votes (including its own).
    <ol>
      <li>If there are no failures and all the votes are Yes, the coordinator decides to commit the transaction and sends a <em>doCommit</em> request to each of the participants.</li>
      <li>Otherwise, the coordinator decides to abort the transaction and sends <em>doAbort</em> requests to all participants that voted Yes.</li>
    </ol>
  </li>
  <li>Participants that voted Yes are waiting for a <em>doCommit</em> or <em>doAbort</em> request from the coordinator. When a participant receives one of these messages it acts accordingly and, in the case of commit, makes a <em>haveCommitted</em> call as confirmation to the coordinator.</li>
</ol>

<p><img src="/assets/images/Pasted image 20240511145431.png" alt="DistributedTransaction" />
<!-- ![[Pasted image 20240511145431.png]] --></p>

<p>Timeout is employed in 2PC.</p>
<ul>
  <li>If a participant votes yes, but not receiving any reply from the coordinator after a certain time, it enters the <em>uncertain</em> state. It can make a <em>getDecision</em> request to the coordinator to determine the outcome.</li>
  <li>Since after a participant votes yes, it can’t do anything until receive a decision from the coordinator. Thus, if a coordinator fails, it must be replaced.</li>
  <li>Conversely, if a participant can’t vote in a certain time, the coordinator must announce <em>doAbort</em> to all participants.</li>
</ul>

<h2 id="timestamp-ordering">Timestamp Ordering</h2>

<p>Similarly, the isolation property needs to be preserved in distributed transactions. There are two meanings behind isolation in distributed DBMSs:</p>
<ol>
  <li>Each server needs to be responsible for applying concurrency control to its own objects.</li>
  <li>All members of a distributed transactions are jointly responsible for ensuring that they are performed in a serially equivalent manner.</li>
</ol>

<p>We mainly talk about 2 in this article, where “serially equivalent manner” or “serializability” means if transaction T is before transaction U in their conflicting access to objects at one of the servers, then they must be in that order at all of the servers whose objects are accessed in a conflicting manner by both T and U.</p>

<p>The most common protocol is the timestamp ordering. in the protocol, similarly, a central coordinator is selected.</p>
<ul>
  <li>The coordinator issues a timestamp – the globally unique transaction timestamps – to each transaction when it starts to participants. All members are responsible for ensuring that transactions execute in the order of timestamp.</li>
  <li>The transaction timestamp is passed to the coordinator at each server whose objects perform an operation in the transaction. In this way, the coordinator can find the potential inconsistency</li>
</ul>

<h2 id="one-copy-serializability">One-copy Serializability</h2>

<p>There is a final concerns of distributed transactions. Usually, for increasing data availability, there are replicas for objects. From a client’s viewpoint, a transaction on replicated objects should appear the same as one with non-replicated objects. This property is named <em>one-copy serializability</em>. It is similar to, but not to be confused with, sequential consistency or sequential serializability.</p>

<p>The simplest protocol to achieve one-copy serializability is <strong>read-one/write-all</strong>. As its name suggests, when it reads, it can read from any one of the replicas. But a write requests must be performed on all replicas by the replica manager.</p>

<p><img src="/assets/images/Pasted image 20240511161255.png" alt="DistributedTransaction" />
<!-- ![[Pasted image 20240511161255.png]] --></p>

<p>Simple read-one/write-all replication is not a realistic scheme, because it cannot be carried out if some of the replica managers are unavailable. This deficiency essentially contradicts with the purpose of replicas because replicas scheme is designed to allow for some replica managers being temporarily unavailable.</p>

<p>A more realistic protocol is local validation. It allows a transaction to write only to available replicas. However, before a transaction commits it checks for any failures (and recoveries) of replica managers of objects it has accessed. A transaction can only commits if there is no failure and recovery of replicas which stores the object used in the transaction.</p>

<h2 id="reference">Reference</h2>

<p>Coulouris, George F., Jean Dollimore, and Tim Kindberg. Distributed systems: concepts and design. pearson education, 2005.</p>]]></content><author><name>Chew Y. Feng</name></author><category term="CourseNote" /><category term="Database" /><summary type="html"><![CDATA[Deal with the complexity in distributed systems.]]></summary></entry><entry><title type="html">Transaction Management</title><link href="/coursenote/2024/04/19/Transaction-Management.html" rel="alternate" type="text/html" title="Transaction Management" /><published>2024-04-19T00:00:00+00:00</published><updated>2024-05-11T06:41:14+00:00</updated><id>/coursenote/2024/04/19/Transaction-Management</id><content type="html" xml:base="/coursenote/2024/04/19/Transaction-Management.html"><![CDATA[<p>The document summarize transaction management in database.</p>

<p>Content from Unimelb Master Subject <a href="https://handbook.unimelb.edu.au/subjects/comp90050">COMP90050</a></p>

<h2 id="background">Background</h2>

<p>Some cliché here:
Transaction is a <strong>unit of work</strong> in a database
Properties of transaction: <strong>ACID</strong></p>
<ul>
  <li><strong>Atomicity</strong>. Either all operations of the transaction are reflected properly in the database, or none are</li>
  <li><strong>Consistency</strong>. Execution of a transaction in isolation (i.e., with no other transaction executing concurrently) preserves the consistency of the database.
    <ul>
      <li>What is “consistent” often depends on applications</li>
      <li>Not easily computable in general</li>
    </ul>
  </li>
  <li><strong>Isolation</strong>. Even though multiple transactions may execute concurrently, the system guarantees that, for every pair of transactions, it appears that one is unaware of another
    <ul>
      <li>mainly about concurrency control</li>
    </ul>
  </li>
  <li><strong>Durability</strong>. After a transaction completes successfully, the changes it has made to the database persist, even if there are system failures.</li>
</ul>

<p>Not all operations can have ACID. Three types of operations in DBMS</p>
<ul>
  <li>Unprotected actions. actions with no ACID. e.g. low level read and write from memory / disk</li>
  <li><strong>Protected actions</strong></li>
  <li>Real actions. These actions affect the real, physical world in a way that is hard or impossible to reverse. theoretically impossible to implement ACID. e.g. printing a report, sending a SMS message…</li>
</ul>

<h2 id="transaction-from-programmers-perspective">Transaction from Programmers Perspective</h2>

<p>Not all queries can be expressed in SQL, so a transaction often works with a general purpose language such as C and Java</p>

<p>Two approaches to accessing SQL: Dynamic SQL and Embedded SQL</p>
<ul>
  <li>Dynamic SQL ← construct and submit SQL queries at <strong>runtime</strong>. e.g. JDBC</li>
  <li>Embedded SQL ← compile SQL statement at <strong>compile time</strong>. e.g. C Embedded SQL</li>
</ul>

<p>The main distinction between Dynamic SQL and Embedded SQL is the existence of <strong>Pre-processing</strong>. Preprocessing can catch errors in the compile stage e.g. type error, SQL syntax error, but it complicates debugging of the program and even causes ambiguity because it, actually creates a new host language. As a result, most modern systems use dynamic SQL.</p>

<p>Finally, note that nondeclarative actions in programs – printing to terminal, sending result to UI – cannot be undone by DB</p>
<h3 id="c-embedded-sql">C Embedded SQL</h3>
<p>Example a flat transaction.</p>

<p>First, create a function with no transaction</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">BEGIN</span> <span class="n">DECLARE</span> <span class="n">SECTION</span><span class="p">;</span>
	<span class="cm">/* The following variables are used for communicating between SQL and C */</span>
	<span class="kt">int</span> <span class="n">OrderID</span><span class="p">;</span> 		<span class="cm">/* Employee ID (from user) */</span> 
	<span class="kt">int</span> <span class="n">CustID</span><span class="p">;</span>	 	<span class="cm">/* Retrieved customer ID */</span> 
	<span class="kt">char</span> <span class="n">SalesPerson</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="cm">/* Retrieved salesperson name */</span> 
	<span class="kt">char</span> <span class="n">Status</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> 	<span class="cm">/* Retrieved order status */</span> 
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">END</span> <span class="n">DECLARE</span> <span class="n">SECTION</span><span class="p">;</span> 
	
	<span class="cm">/* Set up error processing */</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">WHENEVER</span> <span class="n">SQLERROR</span> <span class="n">GOTO</span> <span class="n">query_error</span><span class="p">;</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">WHENEVER</span> <span class="n">NOTFOUND</span> <span class="n">GOTO</span> <span class="n">bad_number</span><span class="p">;</span>
	
	<span class="cm">/* Prompt the user for order number */</span>
	<span class="n">printf</span> <span class="p">(</span><span class="s">"Enter order number: "</span><span class="p">);</span>
	<span class="n">scanf_s</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">OrderID</span><span class="p">);</span>
	
	<span class="cm">/* Execute the SQL query, simple query no transaction definition */</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">SELECT</span> <span class="n">CustID</span><span class="p">,</span> <span class="n">SalesPerson</span><span class="p">,</span> <span class="n">Status</span>
	<span class="n">FROM</span> <span class="n">Orders</span>
	<span class="n">WHERE</span> <span class="n">OrderID</span> <span class="o">=</span> <span class="o">:</span><span class="n">OrderID</span><span class="p">;</span><span class="c1">// ”:” indicates to refer to  C variable</span>
	<span class="n">INTO</span> <span class="o">:</span><span class="n">CustID</span><span class="p">,</span> <span class="o">:</span><span class="n">SalesPerson</span><span class="p">,</span> <span class="o">:</span><span class="n">Status</span><span class="p">;</span>
	
	<span class="n">printf</span> <span class="p">(</span><span class="s">"Customer number: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">CustID</span><span class="p">);</span>
	<span class="n">printf</span> <span class="p">(</span><span class="s">"Salesperson: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">SalesPerson</span><span class="p">);</span>
	<span class="n">printf</span> <span class="p">(</span><span class="s">"Status: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Status</span><span class="p">);</span>
	
	<span class="n">exit</span><span class="p">();</span>
	
	<span class="nl">query_error:</span>
	<span class="n">printf</span> <span class="p">(</span><span class="s">"SQL error: %ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sqlca</span><span class="o">-&gt;</span><span class="n">sqlcode</span><span class="p">);</span> <span class="n">exit</span><span class="p">();</span>
	
	<span class="nl">bad_number:</span>
	<span class="n">printf</span> <span class="p">(</span><span class="s">"Invalid order number.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="n">exit</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>Then, put transaction into the example: Everything between</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">exec</span> <span class="n">sql</span> <span class="n">BEGIN</span> <span class="n">WORK</span><span class="p">;</span>
</code></pre></div></div>
<p>and</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">exec</span> <span class="n">sql</span> <span class="n">COMMIT</span> <span class="n">WORK</span><span class="p">;</span>
</code></pre></div></div>
<p>is seen as transaction.</p>

<p>e.g.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DCApplication</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">BEGIN</span> <span class="n">WORK</span><span class="p">;</span>
	<span class="n">AccBalance</span> <span class="o">=</span> <span class="n">DodebitCredit</span><span class="p">(</span><span class="n">BranchId</span><span class="p">,</span> <span class="n">TellerId</span><span class="p">,</span> <span class="n">AccId</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
	<span class="c1">// Consistency Check</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AccBalance</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Inconsistent</span>
	<span class="c1">// Let dbms undo whatever it has done</span>
		<span class="n">exec</span> <span class="n">sql</span> <span class="n">ROLLBACK</span> <span class="n">WORK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> 
		<span class="n">send</span> <span class="n">output</span> <span class="n">msg</span><span class="p">;</span>
		<span class="n">exec</span> <span class="n">sql</span> <span class="n">COMMIT</span> <span class="n">WORK</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">Long</span> <span class="nf">DoDebitCredit</span><span class="p">(</span><span class="kt">long</span> <span class="n">BranchId</span><span class="p">,</span> <span class="kt">long</span> <span class="n">TellerId</span><span class="p">,</span> <span class="kt">long</span> <span class="n">AccId</span><span class="p">,</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">UPDATE</span> <span class="n">accounts</span>
	<span class="n">SET</span> <span class="n">AccBalance</span> <span class="o">=</span><span class="n">AccBalance</span> <span class="o">+</span> <span class="o">:</span><span class="n">delta</span>
	<span class="n">WHERE</span> <span class="n">AccId</span> <span class="o">=</span> <span class="o">:</span><span class="n">AccId</span><span class="p">;</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">SELECT</span> <span class="n">AccBalance</span> <span class="n">INTO</span>  <span class="o">:</span><span class="n">AccBalance</span>
	<span class="n">FROM</span> <span class="n">accounts</span> <span class="n">WHERE</span> <span class="n">AccId</span> <span class="o">=</span> <span class="o">:</span><span class="n">AccId</span><span class="p">;</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">UPDATE</span> <span class="n">tellers</span>
	<span class="n">SET</span> <span class="n">TellerBalance</span> <span class="o">=</span> <span class="n">TellerBalance</span> <span class="o">+</span> <span class="o">:</span><span class="n">delta</span>
	<span class="n">WHERE</span> <span class="n">TellerId</span> <span class="o">=</span> <span class="o">:</span><span class="n">TellerId</span><span class="p">;</span>
	<span class="n">exec</span> <span class="n">sql</span> <span class="n">UPDATE</span> <span class="n">branches</span>
	<span class="n">SET</span> <span class="n">BranchBalance</span> <span class="o">=</span> <span class="n">BranchBalance</span> <span class="o">+</span> <span class="o">:</span><span class="n">delta</span>
	<span class="n">WHERE</span> <span class="n">BranchId</span> <span class="o">=</span> <span class="o">:</span><span class="n">BranchId</span><span class="p">;</span>
	
	<span class="n">Exec</span> <span class="n">sql</span> <span class="n">INSERT</span> <span class="n">INTO</span> <span class="n">history</span><span class="p">(</span><span class="n">TellerId</span><span class="p">,</span> <span class="n">BranchId</span><span class="p">,</span> <span class="n">AccId</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
	<span class="n">VALUES</span><span class="p">(</span> <span class="o">:</span><span class="n">TellerId</span><span class="p">,</span> <span class="o">:</span><span class="n">BranchId</span><span class="p">,</span> <span class="o">:</span><span class="n">AccId</span><span class="p">,</span> <span class="o">:</span><span class="n">delta</span><span class="p">,</span> <span class="n">CURRENT</span><span class="p">);</span>
	
	<span class="k">return</span><span class="p">(</span><span class="n">AccBalance</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>the transaction will either survive together with everything from BEGIN WORK to COMMIT WORD, or it will be rolled back with everything (abort).</p>

<h3 id="dynamic-sql">Dynamic SQL</h3>

<p>Take JDBC as an example.</p>

<p>Mainly four steps:</p>
<ul>
  <li>Open a connection</li>
  <li>Create a statement object</li>
  <li>Execute queries using the statement object to send queries and fetch results</li>
  <li>Exception mechanism to handle errors</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">JDBCexample</span><span class="o">(</span><span class="nc">String</span> <span class="n">userid</span><span class="o">,</span> <span class="nc">String</span> <span class="n">passwd</span><span class="o">)</span>
<span class="o">{</span>
	<span class="k">try</span> <span class="o">(</span>
		<span class="c1">// Open a connection</span>
		<span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span>
			<span class="s">"jdbc:oracle:thin:@db.yale.edu:1521:univdb"</span><span class="o">,</span>
			<span class="n">userid</span><span class="o">,</span> <span class="n">passwd</span><span class="o">);</span>
		<span class="c1">// Create a statement object</span>
		<span class="nc">Statement</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">createStatement</span><span class="o">();</span>
	<span class="o">)</span> <span class="o">{</span>
		<span class="k">try</span> <span class="o">{</span>
			<span class="c1">// Execute queries using the statement object</span>
			<span class="n">stmt</span><span class="o">.</span><span class="na">executeUpdate</span><span class="o">(</span>
			<span class="s">"insert into instructor values(’77987’,’Kim’,’Physics’,98000)"</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="k">catch</span> <span class="o">(</span><span class="nc">SQLException</span> <span class="n">sqle</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Could not insert tuple. "</span> <span class="o">+</span> <span class="n">sqle</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="c1">// Execute queries using the statement object</span>
		<span class="nc">ResultSet</span> <span class="n">rset</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">(</span>
			<span class="s">"select dept_name, avg (salary) "</span><span class="o">+</span>
			<span class="s">" from instructor "</span><span class="o">+</span>
			<span class="s">" group by dept_name"</span><span class="o">);</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">rset</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">rset</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"dept_name"</span><span class="o">)</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span>
			<span class="n">rset</span><span class="o">.</span><span class="na">getFloat</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
		<span class="o">}</span>
	<span class="o">}</span>
	<span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">sqle</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">// handle exception</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Exception : "</span> <span class="o">+</span> <span class="n">sqle</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><em>Automatic Commit</em>. Most DBs treats each SQL statement as a transaction by default.</p>

<p>To create a transaction, automatic commit must be turn off.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">assert</span> <span class="n">conn</span> <span class="k">instanceof</span> <span class="nc">Connection</span><span class="o">;</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setAutoCommit</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
</code></pre></div></div>

<p>A transaction can be put between</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">conn</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span> 
<span class="n">stmt</span><span class="o">.</span><span class="na">executeUpdate</span><span class="o">(...);</span>
<span class="n">conn</span><span class="o">.</span><span class="na">rollback</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="savepoints-and-nested-transactions">Savepoints And Nested Transactions</h2>

<p>The examples above are flat transactions.</p>

<p>A <em>flat transaction</em> typically refers to a transaction that doesn’t involve multiple steps or subtransactions. It’s a simple, single-operation transaction where a database operation is executed as a single unit of work.</p>

<p>A typical flat transaction:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BEGIN WORK
S1: book flight from Melbourne to Singapore
S2: book flight from Singapore to London
S3: book flight from London to Dublin
COMMIT WORK
</code></pre></div></div>

<p>The semantic of flat transaction is <strong><em>“all-or-nothing”</em></strong></p>
<ul>
  <li>A naïve implementation: giving up everything that has been done (invoke <code class="language-plaintext highlighter-rouge">ROLLBACK WORK</code>)</li>
  <li>Good at short applications such as debit/credit</li>
  <li>Problem: waste of computation power</li>
</ul>

<p>A better solution: stepping back to an earlier state <em>inside the same transaction</em> by <strong><em>savepoints</em></strong></p>

<p><img src="/assets/images/Pasted image 20240407110700.png" alt="SavePoints" /></p>

<p>Savepoints are explicitly established by the application program and can be reestablished by invoking a modified ROLLBACK function, which is aimed at an internal savepoint rather than at the beginning of the transaction.</p>

<p>An alternative to savepoints is nested transactions (or subtransactions)</p>

<p>Nested transactions are a generalization of savepoints. Whereas savepoints allow organizing a transaction into a <em>sequence</em> of actions that can be rolled back individually, nested transactions form a <em>hierarchy</em> of pieces of work.</p>

<p><img src="/assets/images/Pasted image 20240407111000.png" alt="NestedTransaction" /></p>

<p>Definition of nested Transaction:</p>

<ul>
  <li>A nested transaction is a tree of transactions, the sub-trees of which are either nested or flat transactions.</li>
  <li>A subtransaction can either commit or roll back; its commit will not take effect, though, unless the parent transaction commits. By induction, therefore, any subtransaction can finally commit only if the root transaction commits.</li>
</ul>

<p>Rules of subtransactions:</p>
<ul>
  <li><strong>Commit rule.</strong> The commit of a subtransaction makes its results accessible only to the parent transaction. Any subtransaction can finally commit only if the root transaction commits.</li>
  <li><strong>Rollback rule.</strong> If a transaction at any level is rolled back, all its subtransactions are also  rolled back</li>
  <li><strong>Visibility rule.</strong> All changes done by a subtransaction become visible to the parent transaction upon the subtransaction’s commit. All objects held by a parent transaction can be made accessible to its subtransactions. Changes made by a subtransaction are not visible to its siblings, in case they execute concurrently. Siblings cannot view each other.</li>
</ul>

<p>subtransactions are more capable than savepoints + flat transaction:</p>
<ul>
  <li>subtransactions can run in parallel so more effecient.</li>
  <li>the code will be more organizable</li>
</ul>

<p>Conclusion: subtransactions have ACI, but no D (The changes are made durable only after the whole transaction has committed)</p>

<h2 id="transaction-processing-monitors">Transaction Processing Monitors</h2>

<p><em>TP monitors</em> are the least well-defined software term. They function differently in different DBMS.</p>

<p>The main function of a TP monitor is <strong>to <em>integrate</em> other system components and manage resources</strong>.</p>

<p>The TP monitor integrates different system components to provide a uniform applications and operations interface with the same failure semantics (ACID properties).</p>

<p>In this subject, TP monitors are defined to be</p>
<ul>
  <li>TP monitors manage the <strong>transfer of data between clients and servers</strong></li>
  <li>Breaks down applications or code <strong>into transactions and ensures that all the database(s) are updated properly</strong></li>
  <li>It also takes appropriate <strong>actions if any error occurs</strong></li>
</ul>

<p>Services:</p>
<ul>
  <li><strong>Terminal(clients) management</strong>. manage connections, deliver and receive message by users</li>
  <li><strong>Presentation services</strong>. dealt with different UI software, similar to the previous one</li>
  <li><strong>Context management.</strong>  context such as “Current authenticated userid at that terminal,” “Default terminal for that user,” “Account number for that user,” “Current user role.”…</li>
  <li><strong>Start/restart</strong>. handle the restart after any failure</li>
</ul>

<h3 id="structures-of-tp-monitors">Structures of TP Monitors</h3>

<p><strong>One process per terminal</strong></p>

<p>Each process can run all applications. Each process may have to access any one of the databases. This design is typical of time-sharing systems. It has many processes and many control blocks.</p>

<p>Very memory expensive, context switching causes problems too..</p>

<p><strong>Only one terminal process</strong></p>

<p>In this solution, there is just one process in the entire system. It talks to all terminals, does presentation handling, receives the requests, contains the code for all services of all applications, can access any database, and creates dynamic threads to multiplex itself among the incoming request</p>

<p>This would work under a multithreaded environment but cannot do proper parallel processing, one error leads to large scale problems, not really distributed and rather monolithic</p>

<p><strong>Many Servers, One Scheduler</strong></p>

<p>Multiple processes have one requester, which is the process handling the communication with the clients.</p>

<p><strong>Multiple communication processes and servers</strong></p>

<p><strong>Generalization of the coexistence approach: multiple application servers invoked by multiple requesters.</strong> The association between these groups of functionally distinct processes, load control, activation/deactivation of processes, and so on, must now be coordinated by a separate instance, the monitor process.</p>

<h2 id="transaction-concurrency-control">Transaction Concurrency Control</h2>

<p>Concurrency control guarantee the <strong>isolation</strong> properties</p>

<p>Idea: impose exclusive access to shared variables on different threads.</p>

<p>Approaches:</p>
<ul>
  <li>Dekker’s Algorithm – needs almost no hardware support. but high complexity</li>
  <li>OS support primitives – simple to use, expensive, dependent on OS</li>
  <li>Spin locks – the most common mechanism in DBMS
  Atomic lock/unlock instructions</li>
</ul>

<p><strong>Dekker’s Algorithm</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="kt">int</span> <span class="n">wants</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> 		<span class="c1">// both should be initially 0</span>
<span class="err">…</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">wants</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> 		<span class="c1">// claim desire</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">wants</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">turn</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wants</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">==</span> <span class="n">j</span><span class="p">);</span>
			<span class="n">wants</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="o">:</span> 	<span class="c1">// resource we want mutex on</span>
	<span class="n">turn</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> 			<span class="c1">// assign turn</span>
	<span class="n">wants</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span><span class="err">…</span>
</code></pre></div></div>

<ul>
  <li>Manage <em>desire</em> by arrays</li>
  <li>Use loop statement to wait (busy waiting) → waste of computation power</li>
  <li>Transfer turn to others when task is done</li>
</ul>

<p><strong>OS Exclusive Access</strong></p>

<p>OS support primitives as lock and unlock</p>
<ul>
  <li>Do not use busy waiting, but also very expensive</li>
  <li>also OS dependent</li>
</ul>

<p><strong>Spin Locks</strong></p>

<ul>
  <li>Executed using atomic machine instructions such as test and set or swap</li>
  <li>Need hardware support ← need to lock bus</li>
  <li>uses busy waiting</li>
  <li>very efficient for low lock contentions, commonly used in DBMS</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// lock granted</span>
<span class="n">acquire</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">testAndSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">));</span> <span class="c1">// busy waiting</span>
<span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
<span class="c1">// release lock</span>
<span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">testAndSet</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Assume this line runs in atomic</span>
	<span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">lock</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">return</span> <span class="nb">true</span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="k">return</span> <span class="nb">false</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Yet another spin lock – compare and swap</p>

<p>more generic lock mechanism in programming languages:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lock</span><span class="o">(</span><span class="kt">var</span><span class="o">);</span>
<span class="n">unlock</span><span class="o">(</span><span class="kt">var</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="semaphore">Semaphore</h3>
<p>Definition: A bit, token, fragment of code, or some other mechanism which is used to restrict access to a shared function or device to a single process at a time, or to synchronize and coordinate events in different processes.</p>

<p>Semaphores derive from the <strong>trains</strong>: a train may proceed through a section of track only if there is no other train on the track. Else, it waits</p>

<p>Implement in computers:</p>
<ul>
  <li>A general <code class="language-plaintext highlighter-rouge">get</code> subroutine to acquire access, and a <code class="language-plaintext highlighter-rouge">give</code> to give access to others</li>
  <li>Put waiting processes into a queue to let them wait (simplest: a linked list)</li>
  <li>After a process release the access, give it to the very next process</li>
</ul>

<p>Semaphores are simple locks; no deadlock detection, no conversion, no escalation…</p>

<p>Exclusive Semaphores. An exclusive semaphore is a pointer to a linked list of processes, indicating the exclusive ownership of resources. The process at the end of the list own the semaphore.</p>

<p>To acquire a semaphore, a process needs to call <code class="language-plaintext highlighter-rouge">get()</code></p>

<p>An example <code class="language-plaintext highlighter-rouge">get()</code> of an exclusive semaphore
<img src="/assets/images/Pasted image 20240417095100.png" alt="Semaphore-Get" /></p>

<p>Note that <code class="language-plaintext highlighter-rouge">CS</code> stands for “compare-and-swap“ (a spin lock)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">boolean</span> <span class="nf">cs</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span><span class="cm">/* the following is executed atomically*/</span>
<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cell</span> <span class="o">==</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="n">cell</span> <span class="o">=</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span> <span class="k">return</span> <span class="n">TRUE</span><span class="p">;}</span>
<span class="k">else</span> <span class="p">{</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">cell</span><span class="p">;</span> <span class="k">return</span> <span class="n">FALSE</span><span class="p">;}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>After finishing all things, a process call <code class="language-plaintext highlighter-rouge">give()</code> to wake up the first process in the waiting list</p>

<p>An example <code class="language-plaintext highlighter-rouge">give()</code> of an exclusive semaphore
<img src="/assets/images/Pasted image 20240417095419.png" alt="Semaphore-Give" /></p>

<p>Problem of Exclusive Semaphore: Dead Locks</p>

<p>Solution to dead locks:</p>
<ul>
  <li>Have enough resources – not practical</li>
  <li>don’t allow a process to wait permanently. simply <strong>rollback</strong> after a certain time
  bad idea too. causing resources waste and repeated deadlocks. 
  it causes <em>live locks</em> → constantly change the state of processes but with no actual progress</li>
  <li>Linearly order the resources and request of resources should follow this order – practical
  guarantees that no cyclic dependencies among the transactions.
  i.e. a transaction after requesting ith resource can request jth resource if j &gt; i.
  it applies to statis resources such as printers, but it generally can’t apply to db in general because you don’t know how to order things until runtime</li>
  <li>pre-declare all necessary resources and allocate at once</li>
  <li>Periodically check cycles in graphs
  if a cycle exists, rollback one or more transaction
  not common in practical:
    <ul>
      <li>check if there is a cycle in distributed states is impossible to be absolutely correct</li>
      <li>how to decide which transaction to sacrifice?</li>
    </ul>
  </li>
  <li>Allow waiting for a maximum time on a lock then force Rollback: Many successful systems (IBM, etc) have chosen this approach…</li>
  <li>Most practical approach: allow a transaction waiting for a maximum time on a lock then force rollback</li>
</ul>

<h3 id="concurrency-control-for-isolation">Concurrency Control For Isolation</h3>

<p>The relation between concurrency control and isolation can be described in two aspects:</p>
<ul>
  <li>Concurrent transaction leaves the database in the same state as if the transactions were executed separately</li>
  <li>Isolation guarantees consistency, provided each transaction itself is consistent
  No inconsistency arise from allowing concurrency</li>
</ul>

<p>By the way, why not just achieve isolation by sequentially processing each transaction? Because <strong>efficiency is also important</strong> in DBMS.</p>

<p>Therefore, we need to use concurrency control to support properties of concurrent transactions:</p>
<ul>
  <li>concurrent execution should not cause programs to malfunction</li>
  <li>concurrent execution should have higher throughput (otherwise abandon it)</li>
</ul>

<h3 id="achieve-concurrency-control-in-db">Achieve Concurrency Control in DB</h3>

<p>The tool: dependency graphs</p>

<p><img src="/assets/images/Pasted image 20240417154210.png" alt="DependencyGraphs" /></p>

<p><strong>The dependencies induced by history fragments.</strong> Each graph shows the two transaction nodes <em>T1</em> and <em>T2</em> and the arcs labeled with the object 〈name,version〉 pairs.</p>

<p>A simple observation: read doesn’t cause concurrency issue</p>

<p>Possible Issues:</p>
<ul>
  <li>Lost Update: Write after write</li>
  <li>Dirty Read: Read after write</li>
  <li>Unrepeatable Read: READ→WRITE→READ</li>
</ul>]]></content><author><name>Chew Y. Feng</name></author><category term="CourseNote" /><category term="Database" /><summary type="html"><![CDATA[What is under the hood of DB magic]]></summary></entry><entry><title type="html">Note of Alloy Analyzer</title><link href="/coursenote/2024/03/31/Alloy-Analyser.html" rel="alternate" type="text/html" title="Note of Alloy Analyzer" /><published>2024-03-31T00:00:00+00:00</published><updated>2024-03-31T11:30:03+00:00</updated><id>/coursenote/2024/03/31/Alloy-Analyser</id><content type="html" xml:base="/coursenote/2024/03/31/Alloy-Analyser.html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#propositional-logic" id="markdown-toc-propositional-logic">Propositional Logic</a>    <ul>
      <li><a href="#relation-and-predicates" id="markdown-toc-relation-and-predicates">Relation and Predicates</a></li>
      <li><a href="#operators" id="markdown-toc-operators">Operators</a></li>
    </ul>
  </li>
  <li><a href="#temporal-logic" id="markdown-toc-temporal-logic">Temporal Logic</a>    <ul>
      <li><a href="#temporal-logic-1" id="markdown-toc-temporal-logic-1">Temporal Logic</a></li>
      <li><a href="#language" id="markdown-toc-language">Language</a></li>
    </ul>
  </li>
  <li><a href="#alloy-language" id="markdown-toc-alloy-language">Alloy Language</a></li>
  <li><a href="#model-checking" id="markdown-toc-model-checking">Model Checking</a></li>
</ul>

<blockquote>
  <ul>
    <li>Author: chew.y.feng@outlook.com</li>
    <li>Date: 03/29/2024</li>
  </ul>
</blockquote>

<h2 id="introduction">Introduction</h2>
<p>This note is a brief summary of <a href="https://alloytools.org/tutorials/online/">Alloy</a> for SWEN90010, Unimelb.</p>

<p>Alloy is an analyzer for software modeling. This subject mainly uses Alloy to find holes in security mechanisms. To be more specific, we use Alloy to <em>prove</em> properties about the software specification, such as safety and security.</p>
<h2 id="propositional-logic">Propositional Logic</h2>
<p>Alloy support basic propositional Logic:</p>
<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">all</span><span class="w"> </span><span class="no">city</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">AustralianCities</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">Raining</span><span class="o">[</span><span class="no">city</span><span class="o">]</span><span class="w">
</span></code></pre></div></div>
<p>It says “for all cities in Australia, they are raining”</p>
<h3 id="relation-and-predicates">Relation and Predicates</h3>
<p>Everything is a relation in Alloy. Sets are just unary relations. e.g.</p>
<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Username</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{(</span><span class="no">U0</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="no">U1</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="no">U2</span><span class="o">)}</span><span class="w"> 
</span><span class="no">URL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{(</span><span class="no">UR0</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="no">UR1</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="no">UR2</span><span class="o">)}</span><span class="w"> 
</span><span class="no">Password</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{(</span><span class="no">P0</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="no">P1</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="no">P2</span><span class="o">)}</span><span class="w">
</span></code></pre></div></div>

<p>For arity &gt; 1, relations are also sets e.g.</p>
<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Factor</span><span class="o">(</span><span class="no">x</span><span class="o">,</span><span class="no">y</span><span class="o">,</span><span class="no">z</span><span class="o">)</span><span class="w"> </span><span class="err">—</span><span class="w"> </span><span class="o">{(</span><span class="no">x</span><span class="o">,</span><span class="no">y</span><span class="o">,</span><span class="no">z</span><span class="o">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">z</span><span class="o">}</span><span class="w">
</span></code></pre></div></div>

<p>In summary, we have Sets = Relations = Predicates in alloy</p>
<h3 id="operators">Operators</h3>
<p><strong>Set operators</strong></p>

<p><img src="/assets/images/20240331-alloy-setop.png" alt="setops" /></p>

<p><strong>Relation operators</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Username = {(U0, U1, U2)} 
Password = {(P0, P1, P2)} 
// cross product
Username-&gt;Password = { (U0, P0), (U0, P1), (U0, P2),
					   (U1, P0), (U1, P1), (U1, P2), 
					   (U2, P0), (U2, P1), (U2, P2)}

urlPasswords = {(U0, UR0, P1), (U0, UR1, P2), (U1, UR0, P2)}
myUsername = {(U0)}
myUrl = {(UR1)}
myPassword = {(P2)}

// dot join
myUsername.urlPasswords = { (UR0, P1), (UR1, P2) }

// box join
myUsername.urlPasswords[myUrl] = {(P2)}

// domain restriction
urlPasswords &lt;: myUsername = {(U0, UR0, P1), (U0, UR1, P2) }

// range restriction
urlPasswords :&gt; myPassword = {(U0, UR1, P2), (U1, UR0, P2)}

// override is defined as A ++ B = (A - (domain[B] &lt;: A) + B)
updatedPassword = {(U0, UR0, P3)}
urlPasswords ++ updatedPassword = {(U0, UR0, P3), (U0, UR1, P2), (U1, UR0, P2)}

// cardinalities
#urlPasswords = 3
</code></pre></div></div>
<p>Note that if the relation has an arity of n, the first (n-1) are seen as domain, the last one is the range.</p>

<p><strong>Propositional Logic Operators</strong></p>

<p><img src="/assets/images/20240331-alloy-propop.png" alt="propop" /></p>

<p><strong>Quantifiers</strong></p>

<p><img src="/assets/images/20240331-alloy-quantifiers.png" alt="quantifiers" /></p>

<p>The last four can also be used to declare sets.</p>
<h2 id="temporal-logic">Temporal Logic</h2>
<p>One major feature of Alloy is that it can reason about <em>temporal logic</em> by <em>temporal operators</em>.</p>
<h3 id="temporal-logic-1">Temporal Logic</h3>
<p>Alloy adopts a model-based specification system, in which the system is defined as a <strong><em>state machine model</em></strong>. In an abstract state machine model, the state e
volves over time</p>

<p><img src="/assets/images/20240329164131.png" alt="statemachine" /></p>

<p>We can describe the transition as <strong><em>preconditions</em></strong> (what the state should satisfy before the transition) and <strong><em>postconditions</em></strong> (constraints after the transition).</p>

<p>For safety and security properties, we typically want it to hold in all states. Thus, it is called a <strong><em>state invariant</em></strong>.</p>

<p>To prove a state invariant <code class="language-plaintext highlighter-rouge">inv</code>, we need to use induction:
(a) <code class="language-plaintext highlighter-rouge">inv</code> holds in the initial state
(b) For each operation <code class="language-plaintext highlighter-rouge">op_i</code>, if <code class="language-plaintext highlighter-rouge">inv</code> holds in states, <code class="language-plaintext highlighter-rouge">inv</code> still holds after the operation <code class="language-plaintext highlighter-rouge">op_i</code>.</p>

<h3 id="language">Language</h3>

<p>There are two ways to express things happen in  a timeline:</p>

<p>(a) Use the next state operator <code class="language-plaintext highlighter-rouge">'</code> <strong>for sets</strong></p>
<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">newPassword</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">updatedPassword</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{(</span><span class="no">UR0</span><span class="o">,</span><span class="w"> </span><span class="no">P3</span><span class="o">)}</span><span class="w">
</span><span class="nn">user</span><span class="p">.</span><span class="no">passwords</span><span class="err">’</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">user</span><span class="p">.</span><span class="no">passwords</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">newPassword</span><span class="w">
</span></code></pre></div></div>
<p>It says “In the next state, there is one password being updated”</p>

<p>(b) Use temporal logic keywords <strong>for predicates</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// after means the predicate holds for next state on the timeline
delete_all[user] =&gt; after (no user.passwords)
</code></pre></div></div>

<p><img src="/assets/images/20240329155752.png" alt="temporalops" />
All temporal operators</p>

<h2 id="alloy-language">Alloy Language</h2>
<p><strong>Signatures</strong> are type declarations.</p>

<p><img src="/assets/images/20240329160557.png" alt="sigs" />
Common Signature Declarations</p>

<p>Example: Passbook is a database that stores the relation of (user, url, password).</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sig URL {} 
sig Username {} 
sig Password {} 
sig PassBook {var password : Username -&gt; URL -&gt; Password}
</code></pre></div></div>

<p><strong>Facts</strong> are constraints that are assumed to hold true. They only check initial state by default , unless there are temporal keywords.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fact NoDuplicates
{
	always all pb : PassBook, user : Username, url : URL 
		| lone pb.password[user][url]
}
</code></pre></div></div>
<p>It reads “for all time, all passbooks, users and URLs, there is at most one password for each <code class="language-plaintext highlighter-rouge">(user,url)</code> pair”</p>

<p><strong>Predicates</strong> are primarily used to introduce <em>operations</em> over a state</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//Add a password for a new user/url pair
pred add [pb : PassBook, url : URL, user: Username, pwd: Password] {
	no pb.password[user][url]
	pb.password’ = pb.password + (user-&gt;url-&gt;pwd)
}

//Delete an existing password
pred delete [pb : PassBook, url : URL, user: Username] {
	one pb.password[user][url]
	pb.password’ = pb.password - (user-&gt;url-&gt;Password)
}
</code></pre></div></div>

<p><strong>Functions</strong> are named expressions for reuse of code</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//Return the password for a given user/URL pair
fun lookup [pb: PassBook, url : URL, user : Username] : lone Password {
	pb.password[user][url]
}
</code></pre></div></div>

<p><strong>Assertions</strong> are constraints are we want to check. We primarily use them to express the safety or security properties</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// (durability) If we add a new password, 
// then we get this password when we look it up 
assert addWorks {
	all pb : PassBook, url : URL, user : Username, p : Password |
	add [pb, url, user, p] =&gt; (after (lookup [pb, url, user]) = p)
}
</code></pre></div></div>
<h2 id="model-checking">Model Checking</h2>
<p>The advantage of Alloy is that proofs are automated. Users only need to give the constraints, then Alloy would try to find a counterexample. This approach significantly reduces the efforts in writing proofs. But the tradoff is that it cannot guarantee completeness.</p>

<p>Example:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>assert lone_password_per_user_url {
	all pb, user, url, pwd, res | 
	 (all user1, url1 | lone pb.password[user1][url1]) and
	 no pb.password[user][url] and
	 pb.password’ = pb.password + (user-&gt;url-&gt;pwd) =&gt;
	(lone pb.password’[user][url])
}
</code></pre></div></div>]]></content><author><name>Chew Y. Feng</name></author><category term="CourseNote" /><category term="Formal Method" /><summary type="html"><![CDATA[Light Weighted Formal Methods]]></summary></entry><entry><title type="html">Hoare Logic - Decorated Program</title><link href="/software-foundations/2024/02/15/Decorated-Program.html" rel="alternate" type="text/html" title="Hoare Logic - Decorated Program" /><published>2024-02-15T00:00:00+00:00</published><updated>2024-02-15T10:47:25+00:00</updated><id>/software-foundations/2024/02/15/Decorated%20Program</id><content type="html" xml:base="/software-foundations/2024/02/15/Decorated-Program.html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#decorated-programs" id="markdown-toc-decorated-programs">Decorated Programs</a>    <ul>
      <li><a href="#simplified-decorated-programs" id="markdown-toc-simplified-decorated-programs">Simplified Decorated Programs</a></li>
    </ul>
  </li>
  <li><a href="#automated-verification" id="markdown-toc-automated-verification">Automated Verification</a></li>
  <li><a href="#finding-loop-invariants" id="markdown-toc-finding-loop-invariants">Finding loop invariants</a></li>
  <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
  <li><a href="#referrecne" id="markdown-toc-referrecne">Referrecne</a></li>
</ul>

<h2 id="decorated-programs">Decorated Programs</h2>
<p>The aesthetics of Hoare Logic is that it follows the structure of the program itself, which enables a powerful way to reason about a program – by decoration.</p>

<p>This naive program which subtracts a number is from the PLT series<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</p>
<pre><code class="language-plain">{{ True }} -&gt;&gt; // 1
{{ m = m }}
  X := m
		 {{ X = m }} -&gt;&gt;
		 {{ X = m /\ p = p }};
  Z := p;
		 {{ X = m /\ Z = p }} -&gt;&gt;
		 {{ Z - X = p - m }}
  while X ≠ 0 do
		 {{ Z - X = p - m /\ X ≠ 0 }} -&gt;&gt;
		 {{ (Z - 1) - (X - 1) = p - m }}
	Z := Z - 1
		 {{ Z - (X - 1) = p - m }};
	X := X - 1
		 {{ Z - X = p - m }} // 2
  end
{{ Z - X = p - m /\ ¬(X ≠ 0) }} -&gt;&gt;
{{ Z = p - m }}
</code></pre>

<p>In this example, we showed that the result of the program is indeed <code class="language-plaintext highlighter-rouge">p - m</code> by a <em>decorated proof</em>. Each line accompanies an assertion which states the condition that the program state meets. The mark 1 “narrows down” the assertion, which is discussed in the previous article<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>. To remind it, we can use a weaker assertion to replace a stronger one to meet the requirement of the proof goal. The <em>loop invariant</em> (mark 2) states the condition that the loop satisfies. For assignments, conditions and most other commands that do not involve loops, finding the assertions is fairly easy by following the rules of Hoare Logic. We could see finding loop invariant is the creative part of this art.</p>

<p>One could prove a decorated proof is indeed logically correct by an almost automated process - a “prover” (proof assistant) could look at each assertion and line of programs to decide if the deduction is correct. The reason why it could be automated is that the rules of Hoare logic are mechanical enough, as discussed in the previous post<sup id="fnref:2:1" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>.</p>
<h3 id="simplified-decorated-programs">Simplified Decorated Programs</h3>
<p>The straightforward way to formalize a decorated program is to present two assertions to each one command. Just like the classic Hoare logic statement:
\({\displaystyle \{P\}C\{Q\}}\)
But it turns out to be too verbose that even reading it makes people frustrated.  A decorated program which contains two <code class="language-plaintext highlighter-rouge">skip</code> would look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{{P}} ({{P}} skip {{P}}) ; ({{P}} skip {{P}}) {{P}}
</code></pre></div></div>

<p>An obvious observation is that for two sequential commands, the postcondition of the former one is the precondition of the later one. So we could agree that it’s sound to remove one of it.</p>

<p>For <code class="language-plaintext highlighter-rouge">skip</code> command, apparently, the assertion should not change after the execution. So we don’t need to provide the precondition.</p>
<blockquote>
  <p>[!NOTE] Discussion
Why not omit the postconditions instead? Because the preconditions are always provided either from the start of the program or from the previous command.</p>
</blockquote>

<p>Similarly, we could only provide postconditions of assignments, as the preconditions could be derived easily.</p>

<p>Loops <code class="language-plaintext highlighter-rouge">while b do d</code> can be simplified by omitting the assertion inside the commands because they can be derived from the preconditions and the postconditions.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while b do {{ P }} d end {{ Q }}
</code></pre></div></div>

<p>At last, we arrived to the simplified version of decorated programs, which can be implemented in Coq with some notation magic. The full implementation could be found on<sup id="fnref:1:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</p>
<h2 id="automated-verification">Automated Verification</h2>
<p>A decorated program could be translated to a sequence of verification conditions. By reading each line of the program and the related condition, a proof assistant is able to decide whether the condition could be satisfied.</p>

<p>Let’s look at the standard Hoare triple:
\({\displaystyle \{P\}C\{Q\}}\)
The condition is whether the Hoare triple could be proved <em>valid</em>. The command $C$ might be composed by a sequence of commands, and they can be verified mechanically.  Formally, a proof assistant would walk recursively into the command $C$ and generated a big conjunction that checks</p>
<ul>
  <li><em>Local consistency</em> of each command and</li>
  <li>To “bridge the gap” try to narrow down the assertion found in the program and the assertion imposed by the context. This post adopts the notation  <code class="language-plaintext highlighter-rouge">-&gt;&gt;</code> to notate this “narrowing down” from PLT series<sup id="fnref:1:2" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  "P-&gt;&gt;Q" &lt;-&gt; forall (st: State), P st -&gt; Q st
</code></pre></div>    </div>
  </li>
</ul>

<p>A decorated command is local consistent with a precondition <code class="language-plaintext highlighter-rouge">P</code> if</p>
<ul>
  <li>it is a skip <code class="language-plaintext highlighter-rouge">skip;{Q}</code> and  <code class="language-plaintext highlighter-rouge">P -&gt;&gt; Q</code>.</li>
  <li>it is an assignment <code class="language-plaintext highlighter-rouge">X:=a {Q}</code> and <code class="language-plaintext highlighter-rouge">P -&gt;&gt; Q[X|-&gt;a]</code></li>
  <li>it is a condition
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  if b then {{P1}} d1 else {{P2}} d2 end {{Q}}
</code></pre></div>    </div>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">P /\ b -&gt;&gt; P1</code></li>
      <li><code class="language-plaintext highlighter-rouge">P /\ ~b -&gt;&gt; P2</code></li>
      <li><code class="language-plaintext highlighter-rouge">post P1 -&gt;&gt; Q</code></li>
      <li><code class="language-plaintext highlighter-rouge">post P2 -&gt;&gt; Q</code>
  where <code class="language-plaintext highlighter-rouge">post</code> is to get the postcondition of a decorated program</li>
    </ul>
  </li>
  <li>it is a loop
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  while b do {{Q}} d end {{R}}
</code></pre></div>    </div>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">P /\ b -&gt;&gt; Q</code></li>
      <li><code class="language-plaintext highlighter-rouge">P /\ ~b -&gt;&gt; R</code></li>
      <li><code class="language-plaintext highlighter-rouge">post d /\ b -&gt;&gt; Q</code></li>
      <li><code class="language-plaintext highlighter-rouge">post d /\ ~b -&gt;&gt; R</code></li>
    </ul>
  </li>
  <li>if all explicit usages of <code class="language-plaintext highlighter-rouge">-&gt;&gt;</code> are valid</li>
</ul>

<p>Following these rules, an automated proof program could be developed.</p>
<h2 id="finding-loop-invariants">Finding loop invariants</h2>
<p>Once the outermost precondition and postcondition are chosen, the only left creative part of this “decorated” art is finding the loop invariants. You can’t choose an invariant that is too weak (such as <code class="language-plaintext highlighter-rouge">st -&gt; True</code>), because you’d need it to bridge the following conditions. Similarly, you can’t choose an invariant that is too strong, because it would be extremely hard or impossible to prove. It is indeed an art of finding the most appropriate loop invariants.</p>

<p>There is no silver bullet to solve the problem, but a few tips might help:</p>
<ul>
  <li>Try to use the strongest condition as the invariant first (the postcondition of the loop), and see what made it fails. Then adjust the invariants to a more “realistic one”</li>
  <li>Think about what the loop does and, how, by the end of the loop, the assertion <code class="language-plaintext highlighter-rouge">Q /\ b</code> is useful for proving the postcondition.</li>
  <li>What variables are used in the loop and how to propagate these variables into the information that the invariant carries.</li>
</ul>

<h2 id="summary">Summary</h2>
<ul>
  <li>Decorated Programs could be viewed as proofs of programs.</li>
  <li>Simplified Decorated Programs are equivalent to a fully decorated one, and it could help to avoid verbose, and thus, easier to read.</li>
  <li>The verification of a decorated program could be made automated.</li>
  <li>Finding loop invariants is relatively hard in this art.</li>
</ul>

<h2 id="referrecne">Referrecne</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>https://softwarefoundations.cis.upenn.edu/plf-current/Hoare2.html <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:1:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:1:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>https://excitedspider.github.io/software-foundations/2024/02/02/Hoare-Logic-Basic.html <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:2:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
  </ol>
</div>]]></content><author><name>Chew Y. Feng</name></author><category term="Software-Foundations" /><category term="Coq" /><category term="PLT" /><summary type="html"><![CDATA[Decoration and Automated Verification]]></summary></entry><entry><title type="html">Hoare Logic Basic</title><link href="/software-foundations/2024/02/02/Hoare-Logic-Basic.html" rel="alternate" type="text/html" title="Hoare Logic Basic" /><published>2024-02-02T00:00:00+00:00</published><updated>2024-02-15T10:47:25+00:00</updated><id>/software-foundations/2024/02/02/Hoare%20Logic%20Basic</id><content type="html" xml:base="/software-foundations/2024/02/02/Hoare-Logic-Basic.html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#assertions" id="markdown-toc-assertions">Assertions</a></li>
  <li><a href="#hoare-triple" id="markdown-toc-hoare-triple">Hoare Triple</a></li>
  <li><a href="#structured-proof-rules" id="markdown-toc-structured-proof-rules">Structured Proof Rules</a>    <ul>
      <li><a href="#sequencing" id="markdown-toc-sequencing">Sequencing</a></li>
      <li><a href="#assignment" id="markdown-toc-assignment">Assignment</a></li>
      <li><a href="#consequence" id="markdown-toc-consequence">Consequence</a></li>
      <li><a href="#conditions" id="markdown-toc-conditions">Conditions</a></li>
      <li><a href="#loops" id="markdown-toc-loops">Loops</a></li>
    </ul>
  </li>
  <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
  <li><a href="#reference" id="markdown-toc-reference">Reference</a></li>
</ul>

<p>The <em>Floyd-Hoare Logic</em>, or <em>Hoare Logic</em>, is a formal logic system which is able to reason about the correctness of computer programs <strong>rigorously</strong> and <strong>compositionally</strong>. It is rigorous in the sense that it bases on formal logics. It is compositional because it allows researchers to look at the syntactic constructs of a imperative program.</p>

<p>There are two main ideas of Hoare Logics:</p>
<ol>
  <li>writing down formal specifications of programs</li>
  <li>proof technique of programs which mirrors the structure of program</li>
</ol>

<h2 id="assertions">Assertions</h2>

<p>Assertions are logical claims about the state of programs. Intuitively, programmers want the programs to satisfy some constrains at a certain point.  For example, if I wrote such code</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">File</span> <span class="n">myObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"filename.txt"</span><span class="o">);</span>
<span class="nc">Scanner</span> <span class="n">myReader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="n">myObj</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">data</span> <span class="o">=</span> <span class="n">myReader</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span> <span class="c1">// &lt;-</span>
</code></pre></div></div>

<p>Before execution of the last line, I certainly want there are lines to read. In other words, it should be in a state that  <code class="language-plaintext highlighter-rouge">myReader</code> is valid:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">()</span> <span class="o">-&gt;</span> <span class="k">this</span><span class="o">.</span><span class="na">myReader</span><span class="o">.</span><span class="na">hasNextLine</span><span class="o">()</span>
</code></pre></div></div>

<p>Formally, an assertion is a property of states, which states the correctness of a program.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">Assertion</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">state</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="kr">Prop</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h2 id="hoare-triple">Hoare Triple</h2>
<p>The central of Hoare Logic is the <em>Hoare Triple</em>. A triple describes how the execution of a piece of code changes the state (<a href="https://en.wikipedia.org/wiki/State_(computer_science)">program state</a>). The formal notation of a triple is:</p>

\[\{P\}~c~\{Q\}\]

<p>where P and Q are assertions, c is the piece of code (commands) that being executed. P is named the <em>precondition</em> and Q the <em>postcondition</em>. This triple asserts that if the state satisfy $P$, after code $c$ was executed, the state should satisfy $Q$.</p>

<p>Reasoning about the program is (partially) equivalent to see if a triple is <em>valid</em>. For example, the triple</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">}</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">{</span><span class="no">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">}</span><span class="w">
</span></code></pre></div></div>

<p>is apparently valid. (Here I adopt the annotation of assertions from <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>)</p>

<p>We can formalize the validity of triples as a proposition</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">valid_hoare_triple</span><span class="w">
           </span><span class="o">(</span><span class="no">P</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Assertion</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">c</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">Q</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Assertion</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">forall</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">st'</span><span class="o">,</span><span class="w">
     </span><span class="no">st</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
     </span><span class="no">P</span><span class="w"> </span><span class="no">st</span><span class="w">  </span><span class="o">-&gt;</span><span class="w">
     </span><span class="no">Q</span><span class="w"> </span><span class="no">st'</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h2 id="structured-proof-rules">Structured Proof Rules</h2>

<p>A wonderful idea of Hoare Logic is that the proof mirrors the structure of the program itself. Let’s look at some fundamental ones based on the language imp (which defined in <sup id="fnref:1:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>).</p>

<h3 id="sequencing">Sequencing</h3>

<p>A sequence of commands can be “torn down” by look at each command.  The rule is:</p>

\[{\displaystyle {\dfrac {\{P\}S\{Q\}\quad ,\quad \{Q\}T\{R\}}{\{P\}S;T\{R\}}}}\]

<p>which can be easily translated to Coq:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">hoare_seq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">Q</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="no">c2</span><span class="o">,</span><span class="w">
     </span><span class="o">{{</span><span class="no">Q</span><span class="o">}}</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="o">{{</span><span class="no">R</span><span class="o">}}</span><span class="w"> </span><span class="p">→</span><span class="w">
     </span><span class="o">{{</span><span class="no">P</span><span class="o">}}</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="o">{{</span><span class="no">Q</span><span class="o">}}</span><span class="w"> </span><span class="p">→</span><span class="w">
     </span><span class="o">{{</span><span class="no">P</span><span class="o">}}</span><span class="w"> </span><span class="no">c1</span><span class="p">;</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="o">{{</span><span class="no">R</span><span class="o">}}.</span><span class="w">
</span></code></pre></div></div>

<p>Although it is intuitive, but one should see that it shows how Hoare Logic can <strong>compositionally</strong> reason a program - by the transitivity of triples - without taking the program as a whole.</p>
<h3 id="assignment">Assignment</h3>

<p>For imperative programs, the typical command that changes the program state is assignment. Thus, it is the most fundamental of the Hoare logic.</p>

\[{\dfrac {}{\{P[E/x]\}x:=E\{P\}}}\]

<p>where $P[E/x]$ means the assertion $P$ in which every free occurrence of x as been replaced by E.</p>

<p>For example, what the precondition could be in this triple?</p>

\[\{ ??? \}~X:= X + Y~\{X=1\}\]

<p>If we replace $X$ with $X+Y$ in the postcondition, a valid precondition is acquired.</p>

\[\{ X+Y = 1 \}~X:= X + Y~\{X=1\}\]

<p>This trick works because it exploits the definition of assignment. Besides, this trick is so mechanical that it could be implemented in Coq trivially.</p>

<p>The implementation of $P[E/x]$:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">assertion_sub</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">(</span><span class="no">P</span><span class="p">:</span><span class="no">Assertion</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Assertion</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">fun</span><span class="w"> </span><span class="o">(</span><span class="no">st</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
    </span><span class="no">P</span><span class="w"> </span><span class="o">(</span><span class="no">X</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="no">aeval</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="no">st</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>This function takes a variable <code class="language-plaintext highlighter-rouge">X</code>, an expression <code class="language-plaintext highlighter-rouge">a</code> and an assertion P, returns an assertion that replaces the evaluation of <code class="language-plaintext highlighter-rouge">st X</code> to <code class="language-plaintext highlighter-rouge">st a</code>.</p>

<p>It is also known as “backwards reasoning” because we take postconditions and commands as inputs, outputing the preconditions. Actually it is a good way to think because the postconditions are usually the most important. But it is not to say that it’s impossible to do forward reasoning - see <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> for more examples.</p>

<p>To translate this rule into Coq:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">hoare_asgn</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">Q</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="no">a</span><span class="o">,</span><span class="w">
  </span><span class="o">{{</span><span class="no">Q</span><span class="w"> </span><span class="o">[</span><span class="no">X</span><span class="w"> </span><span class="o">|-&gt;</span><span class="w"> </span><span class="no">a</span><span class="o">]}}</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">{{</span><span class="no">Q</span><span class="o">}}.</span><span class="w">

</span><span class="k">Example</span><span class="w"> </span><span class="no">hoare_asgn_examples1</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="kp">exists</span><span class="w"> </span><span class="no">P</span><span class="o">,</span><span class="w">
    </span><span class="o">{{</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="o">}}</span><span class="w">
      </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">X</span><span class="w">
    </span><span class="o">{{</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">}}.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">exists</span><span class="w"> </span><span class="o">((</span><span class="no">X</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10</span><span class="o">)</span><span class="w"> </span><span class="o">[</span><span class="no">X</span><span class="w"> </span><span class="o">|-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">X</span><span class="o">]).</span><span class="w">
  </span><span class="kp">apply</span><span class="w"> </span><span class="no">hoare_asgn</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>A common error is to use this rule in a “forward” way. In other words, this is incorrect: ${\displaystyle {P}x:=E{P[E/x]}}$</p>

<p>We give a counterexample of it to show that it is indeed incorrect:</p>

\[{\displaystyle \{\text{True}\}~x:=a~\{X = a\}}\]

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">hoare_asgn_wrong</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kp">exists</span><span class="w"> </span><span class="no">a</span><span class="p">:</span><span class="no">aexp</span><span class="o">,</span><span class="w">
  </span><span class="o">~</span><span class="w"> </span><span class="o">{{</span><span class="w"> </span><span class="no">True</span><span class="w"> </span><span class="o">}}</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">{{</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">}}.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">exists</span><span class="w"> </span><span class="o">(</span><span class="no">APlus</span><span class="w"> </span><span class="o">(</span><span class="no">AId</span><span class="w"> </span><span class="no">X</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">ANum</span><span class="w"> </span><span class="mi">1</span><span class="o">)).</span><span class="w"> </span><span class="c">(* X := X + 1 *)</span><span class="w">
  </span><span class="kp">unfold</span><span class="w"> </span><span class="no">not</span><span class="pi">.</span><span class="w">
  </span><span class="kp">unfold</span><span class="w"> </span><span class="no">valid_hoare_triple</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="pi">.</span><span class="w">
  </span><span class="no">remember</span><span class="w"> </span><span class="o">(</span><span class="no">X</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="no">st</span><span class="pi">.</span><span class="w">
  </span><span class="no">remember</span><span class="w"> </span><span class="o">(</span><span class="no">X</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="no">st</span><span class="o">)</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="no">st'</span><span class="pi">.</span><span class="w">
  </span><span class="kp">unfold</span><span class="w"> </span><span class="no">Aexp_of_aexp</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w">
  </span><span class="no">assert</span><span class="w"> </span><span class="o">(</span><span class="no">aeval</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">aeval</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">}&gt;).</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="kp">apply</span><span class="w"> </span><span class="no">H</span><span class="w"> </span><span class="kp">with</span><span class="w"> </span><span class="no">st</span><span class="pi">.</span><span class="w">
    </span><span class="o">-</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w">
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_Asgn</span><span class="pi">.</span><span class="w">
      </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
    </span><span class="o">-</span><span class="w"> </span><span class="kp">unfold</span><span class="w"> </span><span class="no">assert_of_Prop</span><span class="pi">.</span><span class="w"> </span><span class="no">trivial</span><span class="pi">.</span><span class="w">
  </span><span class="o">}</span><span class="w">
  </span><span class="kp">subst</span><span class="pi">.</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H0</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h3 id="consequence">Consequence</h3>

\[{\displaystyle {\dfrac {P_{1}\rightarrow P_{2}\quad ,\quad \{P_{2}\}S\{Q_{2}\}\quad ,\quad Q_{2}\rightarrow Q_{1}}{\{P_{1}\}S\{Q_{1}\}}}}\]

<p>This rule allows strengthening the precondition or(and) weaken the postconditions.</p>

<p>For example, if my precondition is ${ X &gt; 10 }$ , I can strengthen it to ${X &gt; 20}$. For most of the time, this rule is used to adjust the assertions to what we need.</p>

<h3 id="conditions">Conditions</h3>
<p>A conditional command <code class="language-plaintext highlighter-rouge">if b then s else t end</code> naturally has this form in logic:</p>

\[{\displaystyle {\dfrac {\{B\wedge P\}S\{Q\}\quad ,\quad \{\neg B\wedge P\}T\{Q\}}{\{P\}{\texttt {if}}\ B\ {\texttt {then}}\ S\ {\texttt {else}}\ T\ {\texttt {end}}\{Q\}}}}\]

<p>That is, in the <code class="language-plaintext highlighter-rouge">then</code> branch, we know $B$ is evaluated to $\text{True}$; and in the <code class="language-plaintext highlighter-rouge">else</code> branch, $B$ is evaluated to $\text{False}$.  We could use this information in reasoning. Moreover, if $B$ (or $\lnot B$) contradicts $P$, we could rule out that branch because its hypothesis contains a contradiction.</p>

<p>Formalization in coq:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">hoare_if</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">Q</span><span class="w"> </span><span class="o">(</span><span class="no">b</span><span class="p">:</span><span class="no">bexp</span><span class="o">)</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="no">c2</span><span class="o">,</span><span class="w">
  </span><span class="o">{{</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="o">/\</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">}}</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="o">{{</span><span class="no">Q</span><span class="o">}}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="o">{{</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="o">/\</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="no">b</span><span class="o">}}</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="o">{{</span><span class="no">Q</span><span class="o">}}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="o">{{</span><span class="no">P</span><span class="o">}}</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">{{</span><span class="no">Q</span><span class="o">}}.</span><span class="w">

</span><span class="c">(* example *)</span><span class="w">
</span><span class="k">Theorem</span><span class="w"> </span><span class="no">if_minus_plus</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="o">{{</span><span class="no">True</span><span class="o">}}</span><span class="w">
    </span><span class="kr">if</span><span class="w"> </span><span class="o">(</span><span class="no">X</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="no">Y</span><span class="o">)</span><span class="w">
      </span><span class="kr">then</span><span class="w"> </span><span class="no">Z</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">Y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="no">X</span><span class="w">
      </span><span class="kr">else</span><span class="w"> </span><span class="no">Y</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">Z</span><span class="w">
    </span><span class="kr">end</span><span class="w">
  </span><span class="o">{{</span><span class="no">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">Z</span><span class="o">}}.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">apply</span><span class="w"> </span><span class="no">hoare_if</span><span class="p">;</span><span class="w"> </span><span class="kp">eapply</span><span class="w"> </span><span class="no">hoare_consequence_pre</span><span class="p">;</span><span class="w">
  </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">apply</span><span class="w"> </span><span class="no">hoare_asgn</span><span class="o">)</span><span class="p">;</span><span class="w"> </span><span class="kp">simpl</span><span class="p">;</span><span class="w"> </span><span class="no">assertion_auto''</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h3 id="loops">Loops</h3>

\[{\displaystyle {\dfrac {\{P\wedge B\}S\{P\}}{\{P\}{\texttt {while}}\ B\ {\texttt {do}}\ S\ {\texttt {end}}\{\neg B\wedge P\}}}}\]

<p>This rule captures the most important behaviors of loops:</p>
<ul>
  <li>The loop body will be executed only if $B$ is true</li>
  <li>The loop terminates when $B$ becomes false.</li>
  <li>We call $P$ a loop invariant to $S$ if $\{P \wedge B\}S\{P\}$. This means P will be true at the end of the loop body if $B$ is true in the beginning. Otherwise, (if P contradicts B), it still holds because the precondition becomes trivial.</li>
</ul>

<p>Note that Hoare Logic only cares about loops that terminates. In other word, only partial correctness can be proven. There is a variant version of loop rule that can be formulated to prove total correctness<sup id="fnref:2:1" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>.  But as deciding if a program halts is known as undecidable, it is hard to work with total correctness, or it would require special designs of programming languages.</p>

<p>Formalize it in Coq</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">hoare_while</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="o">(</span><span class="no">b</span><span class="p">:</span><span class="no">bexp</span><span class="o">)</span><span class="w"> </span><span class="no">c</span><span class="o">,</span><span class="w">
  </span><span class="o">{{</span><span class="no">P</span><span class="w"> </span><span class="o">/\</span><span class="w"> </span><span class="no">b</span><span class="o">}}</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="o">{{</span><span class="no">P</span><span class="o">}}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="o">{{</span><span class="no">P</span><span class="o">}}</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">{{</span><span class="no">P</span><span class="w"> </span><span class="o">/\</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="no">b</span><span class="o">}}.</span><span class="w">
</span></code></pre></div></div>
<h2 id="summary">Summary</h2>
<ul>
  <li>Assertions are properties of program states.</li>
  <li>Hoare Triples are built on assertions.</li>
  <li>Hoare Triples can be reasoned mechanically through proof rules</li>
</ul>

<h2 id="reference">Reference</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p><a href="https://softwarefoundations.cis.upenn.edu/plf-current/index.html">PROGRAMMING LANGUAGE FOUNDATIONS</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:1:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><a href="https://en.wikipedia.org/wiki/Hoare_logic">Wikipedia: Hoare logic</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:2:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
  </ol>
</div>]]></content><author><name>Chew Y. Feng</name></author><category term="Software-Foundations" /><category term="Coq" /><category term="PLT" /><summary type="html"><![CDATA[Assertions, Hoare Triples and Proof Rules.]]></summary></entry><entry><title type="html">Program Equivalence</title><link href="/software-foundations/2024/01/25/Program-Equivalence.html" rel="alternate" type="text/html" title="Program Equivalence" /><published>2024-01-25T00:00:00+00:00</published><updated>2024-01-25T07:36:38+00:00</updated><id>/software-foundations/2024/01/25/Program-Equivalence</id><content type="html" xml:base="/software-foundations/2024/01/25/Program-Equivalence.html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#behavioral-equivalence" id="markdown-toc-behavioral-equivalence">Behavioral Equivalence</a>    <ul>
      <li><a href="#conditions" id="markdown-toc-conditions">Conditions</a></li>
      <li><a href="#loops" id="markdown-toc-loops">Loops</a></li>
      <li><a href="#assignments" id="markdown-toc-assignments">Assignments</a></li>
    </ul>
  </li>
  <li><a href="#behavioral-equivalence-is-congruence" id="markdown-toc-behavioral-equivalence-is-congruence">Behavioral Equivalence is Congruence</a></li>
  <li><a href="#program-transformation" id="markdown-toc-program-transformation">Program Transformation</a></li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
</ul>

<p>This is a summary for the programming language foundation, chapter “Program Equivalence”  <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</p>

<h2 id="behavioral-equivalence">Behavioral Equivalence</h2>
<p>The concept of <strong><em>equivalence</em></strong> is crucial to understand what is a correct program. For an example, if  program $A$ is correct and $B$ is equivalent to $A$, then it is guaranteed that $B$ is correct.</p>

<p>Generally, an equivalence is a relation that is <em>reflective</em>, <em>symmetric</em> and <em>transitive</em>. So there are many ways to define equivalence. I could define an equivalence relation as two programs are identical as two strings after remove whitespaces. But this definition is not so interesting because it is not helpful for us to improve current programs. Instead, a more useful definition is <em>behavioral equivalence</em>.</p>

<p>Two programs are said to be <em>behaviorally equivalent</em> if they evaluate to the same result from every state.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">cequiv</span><span class="w"> </span><span class="o">(</span><span class="no">c1</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">st</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">),</span><span class="w">
    </span><span class="o">(</span><span class="no">st</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st'</span><span class="o">)</span><span class="w"> </span><span class="o">&lt;-&gt;</span><span class="w"> </span><span class="o">(</span><span class="no">st</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st'</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>(The language we are working on is called “imp”, which is a simple language that has the most basic and representative features as general purpose imperative languages. see <a href="https://softwarefoundations.cis.upenn.edu/lf-current/Imp.html">imp</a>  .)</p>

<p>We can prove that adding a <code class="language-plaintext highlighter-rouge">skip</code> results in an equivalent program.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">skip_right</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">c</span><span class="o">,</span><span class="w">
  </span><span class="no">cequiv</span><span class="w">
    </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="no">skip</span><span class="w"> </span><span class="o">}&gt;</span><span class="w">
    </span><span class="no">c</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="pi">.</span><span class="w"> 
  </span><span class="kp">split</span><span class="p">;</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H5</span><span class="pi">.</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_Seq</span><span class="w"> </span><span class="kp">with</span><span class="w"> </span><span class="o">(</span><span class="no">st'</span><span class="p">:</span><span class="o">=</span><span class="no">st'</span><span class="o">).</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_Skip</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">  
</span></code></pre></div></div>

<p>This definition implies an important concerns: if the program would terminate.</p>

<p>Programmers also often say that program c1 <em>refines</em> c2. It is an asymmetric variant of equivalence - c1 produces the same final states when it terminates - and perhaps c1 is better in readability or  efficiency. But it is not guaranteed that c1 terminates on some initial states if c2 does.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">refines</span><span class="w"> </span><span class="o">(</span><span class="no">c1</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">st</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">),</span><span class="w">
    </span><span class="o">(</span><span class="no">st</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st'</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">(</span><span class="no">st</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st'</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<h3 id="conditions">Conditions</h3>

<p>if the predicate is always false, it’s safe remove the truth branch.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">if_false</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="no">c2</span><span class="o">,</span><span class="w">
  </span><span class="no">bequiv</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">&lt;{</span><span class="no">false</span><span class="o">}&gt;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="no">cequiv</span><span class="w">
    </span><span class="o">&lt;{</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">}&gt;</span><span class="w">
    </span><span class="no">c2</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="pi">.</span><span class="w">
  </span><span class="kp">split</span><span class="p">;</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="no">H1</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H1</span><span class="p">;</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">unfold</span><span class="w"> </span><span class="no">bequiv</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">simpl</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w">
      </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H6</span><span class="pi">.</span><span class="w"> </span><span class="no">discriminate</span><span class="w"> </span><span class="no">H6</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_IfFalse</span><span class="p">;</span><span class="w"> </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="ne">assumption</span><span class="o">).</span><span class="w"> 
    </span><span class="kp">unfold</span><span class="w"> </span><span class="no">bequiv</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">simpl</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="no">trivial</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h3 id="loops">Loops</h3>

<p>In a loop, if a predicate is always true, the program would never terminate.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Lemma</span><span class="w"> </span><span class="no">while_true_nonterm</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">st'</span><span class="o">,</span><span class="w">
  </span><span class="no">bequiv</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">&lt;{</span><span class="no">true</span><span class="o">}&gt;</span><span class="w"> </span><span class="p">→</span><span class="w">
  </span><span class="o">~(</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>(This is not halting problem if you are thinking about that because it doesn’t decide every input.)</p>

<p>Thus, two programs are equivalent if the are both infinite loops, regardless their body.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">while_true</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">c</span><span class="o">,</span><span class="w">
  </span><span class="no">bequiv</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">&lt;{</span><span class="no">true</span><span class="o">}&gt;</span><span class="w">  </span><span class="o">-&gt;</span><span class="w">
  </span><span class="no">cequiv</span><span class="w">
    </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">}&gt;</span><span class="w">
    </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">skip</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">}&gt;.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="pi">.</span><span class="w"> 
  </span><span class="kp">split</span><span class="p">;</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="no">H0</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H0</span><span class="p">;</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">unfold</span><span class="w"> </span><span class="no">bequiv</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H5</span><span class="pi">.</span><span class="w"> </span><span class="no">discriminate</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="o">(</span><span class="no">while_true_nonterm</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">st'</span><span class="o">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="no">contradiction</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">exfalso</span><span class="pi">.</span><span class="w"> 
    </span><span class="kp">apply</span><span class="w"> </span><span class="o">(</span><span class="no">while_true_nonterm</span><span class="w"> </span><span class="o">&lt;{</span><span class="no">true</span><span class="o">}&gt;</span><span class="w"> </span><span class="o">&lt;{</span><span class="no">skip</span><span class="o">}&gt;</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">st'</span><span class="o">)</span><span class="p">;</span><span class="w"> 
    </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">unfold</span><span class="w"> </span><span class="no">bequiv</span><span class="o">)</span><span class="p">;</span><span class="w">
    </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">auto</span><span class="o">).</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>Conversely, if the predicate is always false, it’s safe to optimize the program by removing the surrounding while.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">if_false</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="no">c2</span><span class="o">,</span><span class="w">
  </span><span class="no">bequiv</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">&lt;{</span><span class="no">false</span><span class="o">}&gt;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="no">cequiv</span><span class="w">
    </span><span class="o">&lt;{</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">}&gt;</span><span class="w">
    </span><span class="no">c2</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="pi">.</span><span class="w">
  </span><span class="kp">split</span><span class="p">;</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="no">H1</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H1</span><span class="p">;</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">unfold</span><span class="w"> </span><span class="no">bequiv</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">simpl</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w">
      </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H6</span><span class="pi">.</span><span class="w"> </span><span class="no">discriminate</span><span class="w"> </span><span class="no">H6</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_IfFalse</span><span class="p">;</span><span class="w"> </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="ne">assumption</span><span class="o">).</span><span class="w"> 
    </span><span class="kp">unfold</span><span class="w"> </span><span class="no">bequiv</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">simpl</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="no">trivial</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h3 id="assignments">Assignments</h3>

<p>An assignment is redundant is assign to the same value that the variable currently holds.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">assign_aequiv</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">aexp</span><span class="o">),</span><span class="w">
  </span><span class="no">aequiv</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="no">cequiv</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">skip</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">}&gt;.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">unfold</span><span class="w"> </span><span class="no">aequiv</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="pi">.</span><span class="w"> </span><span class="kp">split</span><span class="p">;</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="no">H0</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H0</span><span class="p">;</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w">
    </span><span class="no">assert</span><span class="w"> </span><span class="o">(</span><span class="no">Hx</span><span class="p">:</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">X</span><span class="p">:</span><span class="o">=</span><span class="no">a</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="no">X</span><span class="p">;</span><span class="w"> </span><span class="no">st'</span><span class="o">)).</span><span class="w">
      </span><span class="o">{</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_Asgn</span><span class="pi">.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="o">}</span><span class="w">
    </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">t_update_same</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">Hx</span><span class="pi">.</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H0</span><span class="p">;</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w">
    </span><span class="no">assert</span><span class="w"> </span><span class="o">(</span><span class="no">Hxa</span><span class="p">:</span><span class="w"> </span><span class="o">(</span><span class="no">X</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="no">aeval</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">a</span><span class="p">;</span><span class="w"> </span><span class="no">st</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">X</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="no">aeval</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">X</span><span class="p">;</span><span class="w"> </span><span class="no">st</span><span class="o">)).</span><span class="w">
      </span><span class="o">{</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="o">}</span><span class="w">
    </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">Hxa</span><span class="pi">.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">t_update_same</span><span class="pi">.</span><span class="w"> </span><span class="kp">auto</span><span class="w"> </span><span class="no">using</span><span class="w"> </span><span class="o">(</span><span class="no">E_Skip</span><span class="o">).</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h2 id="behavioral-equivalence-is-congruence">Behavioral Equivalence is Congruence</h2>

<p>The behavior equivalence is also a <em>congruence</em>. Informally, it is a congruence in the sense that two subprograms implies the equivalence of the larger programs. For example:</p>

\[c_1 = c_1' \implies c2 = c2' \implies (c_1;c_2) = (c_1';c_2')\]

<p>This fact is important in the sense that it allows us to replace a small part of a large program by an equivalent subprogram without proving those parts that didn’t change.</p>

<p>Formalize the idea of congruence into Coq needs some work. The most basic one is the sequence commands.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">CSeq_congruence</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="no">c1'</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="no">c2'</span><span class="o">,</span><span class="w">
  </span><span class="no">cequiv</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="no">c1'</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">cequiv</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="no">c2'</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="no">cequiv</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">c1</span><span class="p">;</span><span class="no">c2</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">c1'</span><span class="p">;</span><span class="no">c2'</span><span class="w"> </span><span class="o">}&gt;.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
    </span><span class="kp">intros</span><span class="pi">.</span><span class="w"> </span><span class="kp">unfold</span><span class="w"> </span><span class="no">cequiv</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="o">*.</span><span class="w"> </span><span class="kp">split</span><span class="p">;</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="no">Hequiv</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">Hequiv</span><span class="p">;</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w">
      </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="o">*.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H0</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="o">*.</span><span class="w">
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_Seq</span><span class="w"> </span><span class="kp">with</span><span class="w"> </span><span class="o">(</span><span class="no">st'0</span><span class="o">)</span><span class="p">;</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">Hequiv</span><span class="p">;</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w">
      </span><span class="kp">rewrite</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="no">H</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="o">*.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="no">H0</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="o">*.</span><span class="w">
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_Seq</span><span class="w"> </span><span class="kp">with</span><span class="w"> </span><span class="o">(</span><span class="no">st'0</span><span class="o">)</span><span class="p">;</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>There are some equivalence relations that are not congruence.</p>

<p>Define equivalence: two programs are said to be equivalent if after applying to an empty state (that is, no variables in record), the numbers of variables are the same. It is easy to see this relation is reflective, symmetric and transitive. But the relation is not congruence. Proof:</p>

<p>Consider two programs: (x:=0) = (y:=1)</p>

<p>It is not a congruence because</p>

<ol>
  <li>(x:=0) = (y:=1)</li>
  <li>(x:=1) = (x:=1)</li>
</ol>

<p>but</p>

<ol>
  <li>(x:=0;x:=1) != (y:=1;x:=1)</li>
</ol>

<p>QED.</p>

<h2 id="program-transformation">Program Transformation</h2>

<p>A program transformation is a function that takes one program as input and produces a modified program. Compilers are the most popular kind of transformation. <a href="https://en.wikipedia.org/wiki/Minification_(programming)">Minifiers</a>and <a href="https://en.wikipedia.org/wiki/Obfuscation_(software)">obfuscator</a> are also useful in many areas.</p>

<p>A practical application for equivalence relation is to show that ana transformation is <em>sound</em>, that is, the input and output program are equivalent. It is important to do so if some optimization are applied to the transformation.</p>

<p>Soundness is formalize as a property on a transformation:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">ctrans_sound</span><span class="w"> </span><span class="o">(</span><span class="no">ctrans</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">com</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">c</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="o">),</span><span class="w">
    </span><span class="no">cequiv</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="o">(</span><span class="no">ctrans</span><span class="w"> </span><span class="no">c</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>For instance, there is a common optimization in compilers called <a href="https://en.wikipedia.org/wiki/Constant_folding">constant-folding</a>. (the implementation of constant-folding can be found in the programming language foundation book, see reference <sup id="fnref:1:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>).</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">fold_constants_com_sound</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="no">ctrans_sound</span><span class="w"> </span><span class="no">fold_constants_com</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">unfold</span><span class="w"> </span><span class="no">ctrans_sound</span><span class="pi">.</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="no">c</span><span class="pi">.</span><span class="w">
  </span><span class="kp">induction</span><span class="w"> </span><span class="no">c</span><span class="p">;</span><span class="w"> </span><span class="kp">simpl</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* skip *)</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">refl_cequiv</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* := *)</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">CAsgn_congruence</span><span class="pi">.</span><span class="w">
              </span><span class="kp">apply</span><span class="w"> </span><span class="no">fold_constants_aexp_sound</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* ; *)</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">CSeq_congruence</span><span class="p">;</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* if *)</span><span class="w">
    </span><span class="no">assert</span><span class="w"> </span><span class="o">(</span><span class="no">bequiv</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">(</span><span class="no">fold_constants_bexp</span><span class="w"> </span><span class="no">b</span><span class="o">)).</span><span class="w"> </span><span class="o">{</span><span class="w">
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">fold_constants_bexp_sound</span><span class="pi">.</span><span class="w"> </span><span class="o">}</span><span class="w">
    </span><span class="kp">destruct</span><span class="w"> </span><span class="o">(</span><span class="no">fold_constants_bexp</span><span class="w"> </span><span class="no">b</span><span class="o">)</span><span class="w"> </span><span class="no">eqn</span><span class="p">:</span><span class="no">Heqb</span><span class="p">;</span><span class="w">
      </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">apply</span><span class="w"> </span><span class="no">CIf_congruence</span><span class="p">;</span><span class="w"> </span><span class="ne">assumption</span><span class="o">).</span><span class="w">
      </span><span class="c">(* (If the optimization doesn't eliminate the if, then the
          result is easy to prove from the IH and
          [fold_constants_bexp_sound].) *)</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="c">(* b always true *)</span><span class="w">
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">trans_cequiv</span><span class="w"> </span><span class="kp">with</span><span class="w"> </span><span class="no">c1</span><span class="p">;</span><span class="w"> </span><span class="kp">try</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">if_true</span><span class="p">;</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="c">(* b always false *)</span><span class="w">
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">trans_cequiv</span><span class="w"> </span><span class="kp">with</span><span class="w"> </span><span class="no">c2</span><span class="p">;</span><span class="w"> </span><span class="kp">try</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">if_false</span><span class="p">;</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="no">assert</span><span class="w"> </span><span class="o">(</span><span class="no">bequiv</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">(</span><span class="no">fold_constants_bexp</span><span class="w"> </span><span class="no">b</span><span class="o">)).</span><span class="w">
    </span><span class="o">{</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">fold_constants_bexp_sound</span><span class="pi">.</span><span class="w"> </span><span class="o">}</span><span class="w">
    </span><span class="kp">destruct</span><span class="w"> </span><span class="o">(</span><span class="no">fold_constants_bexp</span><span class="w"> </span><span class="no">b</span><span class="o">)</span><span class="p">;</span><span class="w">
    </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">apply</span><span class="w"> </span><span class="no">CWhile_congruence</span><span class="p">;</span><span class="w"> </span><span class="ne">assumption</span><span class="o">).</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">while_true</span><span class="pi">.</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">while_false</span><span class="pi">.</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h2 id="references">References</h2>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>“Program Equivalence.” 2024. <em>Equiv: Program Equivalence</em>. Accessed January 25. https://softwarefoundations.cis.upenn.edu/plf-current/Equiv.html. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:1:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
  </ol>
</div>]]></content><author><name>Chew Y. Feng</name></author><category term="Software-Foundations" /><category term="Coq" /><category term="PLT" /><summary type="html"><![CDATA[Formalize equivalence relations.]]></summary></entry></feed>