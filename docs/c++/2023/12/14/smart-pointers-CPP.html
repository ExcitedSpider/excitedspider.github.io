<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Smart Pointers | Chew’s Everyday Blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Smart Pointers" />
<meta name="author" content="Chew Y. Feng" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="With great flexibility comes great responsibility." />
<meta property="og:description" content="With great flexibility comes great responsibility." />
<link rel="canonical" href="/c++/2023/12/14/smart-pointers-CPP.html" />
<meta property="og:url" content="/c++/2023/12/14/smart-pointers-CPP.html" />
<meta property="og:site_name" content="Chew’s Everyday Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-12-14T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Smart Pointers" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Chew Y. Feng"},"dateModified":"2023-12-14T07:50:23+00:00","datePublished":"2023-12-14T00:00:00+00:00","description":"With great flexibility comes great responsibility.","headline":"Smart Pointers","mainEntityOfPage":{"@type":"WebPage","@id":"/c++/2023/12/14/smart-pointers-CPP.html"},"url":"/c++/2023/12/14/smart-pointers-CPP.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Chew&apos;s Everyday Blog" /><script>
    // for MathJax inline
    window.MathJax = {
      tex: {
        inlineMath: [['_', '_'], ['$', '$'], ['\\(', '\\)']]
      }
    };
  </script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/css-doodle/0.37.4/css-doodle.min.js"></script>
  <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Teko">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-4TZZDRT6JY"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-4TZZDRT6JY');
  </script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Chew&#39;s Everyday Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="page-content-background">
        <css-doodle click-to-update>
          <style>
            @grid: 1 / 100vw 100vh / #0a0c27;
            background-size: 200px 200px;
            background-image: @doodle(
              @grid: 6 / 100%;
              @size: 4px;
              font-size: 4px;
              color: hsl(@r240, 30%, 50%);
              box-shadow: @m3x5(
                calc(4em - @nx * 1em) calc(@ny * 1em)
                  @p(@m3(currentColor), @m2(transparent)),
                calc(2em + @nx * 1em) calc(@ny * 1em)
                  @lp
              );
            );
          </style>
        </css-doodle>
      </div>
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Smart Pointers</h1>
    <p class="post-meta"><span class="tags">
        
      </span><time class="dt-published" datetime="2023-12-14T00:00:00+00:00" itemprop="datePublished">
        Posted At: Dec 14, 2023
      </time><time>
        Modified At: Dec 14, 2023
      </time><span class="dt-tags">
        Category:
        
          <span>C++</span>
        
      </span></p>
  </header>


  <div class="post-content e-content" itemprop="articleBody">
    <ul id="markdown-toc">
  <li><a href="#motivation" id="markdown-toc-motivation">Motivation</a></li>
  <li><a href="#ownership-models" id="markdown-toc-ownership-models">Ownership Models</a></li>
  <li><a href="#scoped-pointers" id="markdown-toc-scoped-pointers">Scoped Pointers</a></li>
  <li><a href="#unique-pointers" id="markdown-toc-unique-pointers">Unique Pointers</a>    <ul>
      <li><a href="#deleters" id="markdown-toc-deleters">Deleters</a></li>
    </ul>
  </li>
  <li><a href="#shared-pointers" id="markdown-toc-shared-pointers">Shared Pointers</a>    <ul>
      <li><a href="#control-blocks" id="markdown-toc-control-blocks">Control Blocks</a></li>
      <li><a href="#allocator" id="markdown-toc-allocator">Allocator</a></li>
    </ul>
  </li>
  <li><a href="#weak-pointers" id="markdown-toc-weak-pointers">Weak Pointers</a></li>
  <li><a href="#intrusive-pointers" id="markdown-toc-intrusive-pointers">Intrusive Pointers</a></li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
</ul>

<h2 id="motivation">Motivation</h2>
<blockquote>
  <p>With great flexibility comes great responsibility.</p>
</blockquote>

<p>Dynamic objects are the key feature of C++ that makes the language distinct with almost no lifetime rules are applied. That is to say, programs can achieve the most flexibility. But it is the programmers’ responsibilities to make sure each dynamic object gets destructed <strong>exactly</strong> once. This might be daunting with large programs. Smart pointers, if they are used appropriately, can be a remedy for this problem.</p>

<h2 id="ownership-models">Ownership Models</h2>
<p>Each smart pointer has it’s <em>ownership</em> model, which specifies the relationship with a dynamic allocated object. Informally, ownerships are, by the principle of RAII <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, one can rest assured that the point-to objects are alive if there is an owner (a smart pointer pointing to that object).</p>

<h2 id="scoped-pointers">Scoped Pointers</h2>
<p>A <em>scoped pointer</em> expresses an <em>non-transferable</em>, <em>exclusive ownership</em> model. In addition, the lifetime of the a pointer is <em>within the nearest scope</em>.</p>
<ul>
  <li>non-transferable: The move and copy operations are not supported.</li>
  <li>exclusive ownership: For a dynamic object, there is at most one pointer pointing to it.</li>
  <li>scoped lifetime: destructed when the runtime is outside the scope.</li>
</ul>

<p>Notice that there is no scoped pointers in <em>stdlib</em>. Until now we can find it in <em>boost</em> only. To use it, one needs to include the header of boost.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;boost/smart_ptr/scoped_ptr.hpp&gt;</span><span class="cp">
</span></code></pre></div></div>

<p>To illustrate, it’s better to have a sample class, which tracks the number of instantiated objects.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Kingdom</span> <span class="p">{</span>
    <span class="n">Kingdom</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">m</span> <span class="o">=</span> <span class="s">""</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">message</span><span class="p">{</span> <span class="n">m</span> <span class="p">}</span> <span class="p">{</span>
        <span class="n">number_of_kindom</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">Kingdom</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">number_of_kindom</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">message</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">number_of_kindom</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">Kingdom</span><span class="o">::</span><span class="n">number_of_kindom</span><span class="p">{};</span>
<span class="k">using</span> <span class="n">ScopedKingdom</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Kingdom</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<p>The unit test expresses the main features of a scoped pointer.</p>
<ul>
  <li>The scoped pointer provides a constructor taking a raw pointer.</li>
  <li>A kingdom <code class="language-plaintext highlighter-rouge">legolas</code> is destructed immediately after the scoped code block is finished.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">ScopedKindom</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Kingdom</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">TEST_METHOD</span><span class="p">(</span><span class="n">Scope_Pointer</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Assert</span><span class="o">::</span><span class="n">IsTrue</span><span class="p">(</span><span class="n">Kingdom</span><span class="o">::</span><span class="n">number_of_kindom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">ScopedKingdom</span> <span class="n">aragorn</span><span class="p">{</span> <span class="k">new</span> <span class="n">Kingdom</span> <span class="p">};</span>
    <span class="n">Assert</span><span class="o">::</span><span class="n">IsTrue</span><span class="p">(</span><span class="n">Kingdom</span><span class="o">::</span><span class="n">number_of_kindom</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">{</span>
        <span class="n">ScopedKingdom</span> <span class="n">legolas</span><span class="p">{</span> <span class="k">new</span> <span class="n">Kingdom</span> <span class="p">};</span>
        <span class="n">Assert</span><span class="o">::</span><span class="n">IsTrue</span><span class="p">(</span><span class="n">Kingdom</span><span class="o">::</span><span class="n">number_of_kindom</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Assert</span><span class="o">::</span><span class="n">IsTrue</span><span class="p">(</span><span class="n">Kingdom</span><span class="o">::</span><span class="n">number_of_kindom</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This example illustrates the ownership model:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">by_ref</span><span class="p">(</span><span class="k">const</span> <span class="n">ScopedKingdom</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="kt">void</span> <span class="n">by_val</span><span class="p">(</span><span class="n">ScopedKingdom</span><span class="p">)</span> <span class="p">{}</span>

<span class="n">TEST_METHOD</span><span class="p">(</span><span class="n">Scope_Pointer_Nontransferable</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">ScopedKingdom</span> <span class="n">aragorn</span><span class="p">{</span> <span class="k">new</span> <span class="n">Kingdom</span><span class="p">(</span><span class="s">"aragorn"</span><span class="p">)</span> <span class="p">};</span>

   <span class="n">by_ref</span><span class="p">(</span><span class="n">aragorn</span><span class="p">);</span>
   <span class="n">Assert</span><span class="o">::</span><span class="n">IsTrue</span><span class="p">(</span><span class="n">Kingdom</span><span class="o">::</span><span class="n">number_of_kindom</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

   <span class="c1">// DOES NOT COMPILE</span>
   <span class="n">by_val</span><span class="p">(</span><span class="n">aragorn</span><span class="p">);</span>
   <span class="n">by_val</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">aragorn</span><span class="p">));</span>
   <span class="k">auto</span> <span class="n">son_of_arathorn</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">aragorn</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote class="note">
  <p>The unit test framework using in this post is MS CppUnitTestFramework <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p>
</blockquote>

<p>All smart pointers, including scoped pointers, have two states: <em>empty</em> and <em>full</em>. A smart pointer owning no object is said to be empty, and can be converted to <code class="language-plaintext highlighter-rouge">false</code>. Conversely, a smart pointer can be converted to <code class="language-plaintext highlighter-rouge">true</code> if it owns something.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Assert</span><span class="o">::</span><span class="n">IsTrue</span><span class="p">(</span><span class="n">aragorn</span><span class="p">.</span><span class="k">operator</span> <span class="nf">bool</span><span class="p">());</span>
</code></pre></div></div>

<p>Most pointers,  including scoped pointers, have implemented the dereference <code class="language-plaintext highlighter-rouge">operator*</code> and the member dereference <code class="language-plaintext highlighter-rouge">operator-&gt;</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ScopedKingdom</span> <span class="n">aragorn</span><span class="p">{</span> <span class="k">new</span> <span class="n">Kingdom</span><span class="p">(</span><span class="s">"aragorn"</span><span class="p">)};</span>
<span class="n">Assert</span><span class="o">::</span><span class="n">AreEqual</span><span class="p">(</span><span class="n">aragorn</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">,</span> <span class="s">"aragorn"</span><span class="p">);</span>
</code></pre></div></div>

<p>The scoped pointers support compare with <code class="language-plaintext highlighter-rouge">nullptr</code>, which is yet another way to know whether it is empty.</p>

<p>Although move and copy are not supported, it does support a <code class="language-plaintext highlighter-rouge">swap</code> operation. By the name, it swaps the point-to objects of two scoped pointers.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_METHOD</span><span class="p">(</span><span class="n">Scope_Pointer_Supports_Swap</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ScopedKingdom</span> <span class="n">aragorn</span><span class="p">{</span> <span class="k">new</span> <span class="n">Kingdom</span><span class="p">(</span><span class="s">"aragorn"</span><span class="p">)</span> <span class="p">};</span>
    <span class="n">Assert</span><span class="o">::</span><span class="n">AreEqual</span><span class="p">(</span><span class="n">aragorn</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">,</span> <span class="s">"aragorn"</span><span class="p">);</span>

    <span class="n">ScopedKingdom</span> <span class="n">legolas</span><span class="p">{</span> <span class="k">new</span> <span class="n">Kingdom</span><span class="p">(</span><span class="s">"legolas"</span><span class="p">)</span> <span class="p">};</span>
    <span class="n">Assert</span><span class="o">::</span><span class="n">AreEqual</span><span class="p">(</span><span class="n">legolas</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">,</span> <span class="s">"legolas"</span><span class="p">);</span>

    <span class="n">aragorn</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">legolas</span><span class="p">);</span>
    <span class="n">Assert</span><span class="o">::</span><span class="n">AreEqual</span><span class="p">(</span><span class="n">aragorn</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">,</span> <span class="s">"legolas"</span><span class="p">);</span> 
    <span class="n">Assert</span><span class="o">::</span><span class="n">AreEqual</span><span class="p">(</span><span class="n">legolas</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">,</span> <span class="s">"aragorn"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Rarely used, operation <code class="language-plaintext highlighter-rouge">reset</code> can immediately destroy the owned objects.</p>

<p>Finally, for some historical reasons, it is required to use <code class="language-plaintext highlighter-rouge">boost::scoped_array</code> for dynamic arrays.</p>

<h2 id="unique-pointers">Unique Pointers</h2>
<p>A unique pointer has transferable, exclusive ownership over a single dynamic object. In other words, you can move unique pointers, which makes them transferable. But you cannot copy a unique pointer as well. The stdlib has a <code class="language-plaintext highlighter-rouge">unique_ptr</code> available in the <code class="language-plaintext highlighter-rouge">&lt;memory&gt;</code> header. Unique pointers are arguably the most commonly used smart pointers in the family.</p>

<p>In addition to constructors, the unique pointer has a factory function, which is more recommended:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">int_ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">808</span><span class="p">);</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">make_unique</code> function forwards all the arguments to the appropriate constructors specified by the template parameter. I like this approach because it avoids explicitly using <code class="language-plaintext highlighter-rouge">new</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="n">UniqueKingdom</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Kingdom</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">TEST_METHOD</span><span class="p">(</span><span class="n">Unique_Ptrs_Can_Move</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">auto</span> <span class="n">aragorn</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Kingdom</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"aragorn"</span><span class="p">);</span>
	<span class="n">Assert</span><span class="o">::</span><span class="n">IsTrue</span><span class="p">(</span><span class="n">Kingdom</span><span class="o">::</span><span class="n">number_of_kindom</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">auto</span> <span class="n">son_of_arathorn</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">aragorn</span><span class="p">)</span> <span class="p">};</span>
	<span class="n">Assert</span><span class="o">::</span><span class="n">IsTrue</span><span class="p">(</span><span class="n">Kingdom</span><span class="o">::</span><span class="n">number_of_kindom</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	
	<span class="n">by_val</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">son_of_arathorn</span><span class="p">));</span>
	<span class="n">Assert</span><span class="o">::</span><span class="n">IsTrue</span><span class="p">(</span><span class="n">Kingdom</span><span class="o">::</span><span class="n">number_of_kindom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The unique pointers have built-in support for dynamic arrays, so you can</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">unique_array</span> <span class="p">{</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span> <span class="p">};</span>
</code></pre></div></div>

<p>But it is very important that you don’t initialize a <code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;T&gt;</code> with a dynamic array <code class="language-plaintext highlighter-rouge">T[]</code>. Doing so will lead to undefined behavior.</p>

<h3 id="deleters">Deleters</h3>
<p>The <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> has an optional template parameter called deleter, which get called when the pointer needs to destroy its owned object.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">my_deleter</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">my_deleter</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">my_up</span><span class="p">{</span> <span class="k">new</span> <span class="kt">int</span><span class="p">,</span> <span class="n">my_deleter</span> <span class="p">};</span>
</code></pre></div></div>

<p>By default, the deleter is <code class="language-plaintext highlighter-rouge">std::default_delete&lt;T&gt;</code>, which simply calls <code class="language-plaintext highlighter-rouge">delete</code> or <code class="language-plaintext highlighter-rouge">delete[]</code> on the object. Thus, it is extremely useful when the controlled resources are more than dynamic memory.</p>

<p>A good example to illustrate this is the management of <code class="language-plaintext highlighter-rouge">FILE</code> objects. The <code class="language-plaintext highlighter-rouge">File</code> is the file handle referencing to a file the OS manages. The OS requires programs to invoke <code class="language-plaintext highlighter-rouge">fclose</code> after using it, otherwise it would lead to a <em>resource leakage</em>. It is recommended to use <code class="language-plaintext highlighter-rouge">fclose</code> as the deleter as it is a function-like object.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="n">FileGuard</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">FILE</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">say_hello</span><span class="p">(</span><span class="n">FileGuard</span> <span class="n">file</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="s">"HELLO DAVE"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"HAL9000"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">errno</span><span class="p">;</span>
  <span class="c1">// use `fclose` as the deleter</span>
  <span class="n">FileGuard</span> <span class="n">file_guard</span><span class="p">{</span> <span class="n">file</span><span class="p">,</span> <span class="n">fclose</span> <span class="p">};</span> 
  <span class="c1">// File open here</span>
  <span class="n">say_hello</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">file_guard</span><span class="p">));</span>
  <span class="c1">// File closed here</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="shared-pointers">Shared Pointers</h2>
<p>A shared pointer has transferable, non-exclusive ownership over a single dynamic object. <strong>When a single object has been owned by multiple shared pointers, the last owner is the one to release it.</strong></p>

<p>The stdlib has a <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> available in the <code class="language-plaintext highlighter-rouge">&lt;memory&gt;</code> header.</p>

<blockquote class="note">
  <p>Boost also has a <code class="language-plaintext highlighter-rouge">boost::shared_ptr</code> and it is essentially identical to <code class="language-plaintext highlighter-rouge">std::shared_ptr</code>. But the implementation in boost does not support arrays, so you should generally use the stdlib shared pointer.</p>
</blockquote>

<p>The API designs of shared pointers are almost identical to those in unique pointers. Thus, it would be pedantic to give elaborated examples here. Some frequent APIs are:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">make_shared&lt;T&gt;</code>: forwards argument to construct a shared pointer and a dynamic object.</li>
  <li>Dereference Operators <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">-&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">reset()</code>: Give up ownership or replace by a new object.</li>
  <li><code class="language-plaintext highlighter-rouge">use_count()</code>:  count how many shared pointers own it.</li>
</ul>

<h3 id="control-blocks">Control Blocks</h3>
<p>Shared pointers require a <em>control block</em>, which is a dynamically-allocated object that keeps track of several quantities. For example:</p>
<ul>
  <li>the number of <code class="language-plaintext highlighter-rouge">shared_ptr</code>s that own the managed object;</li>
  <li>the number of <code class="language-plaintext highlighter-rouge">weak_ptr</code>s that refer to the managed object.</li>
</ul>

<p>The functionality of shared pointers relied on the correctness of the control block. When <code class="language-plaintext highlighter-rouge">shared_ptr</code> is created by calling <code class="language-plaintext highlighter-rouge">std::make_shared</code> or <code class="language-plaintext highlighter-rouge">std::allocate_shared</code>, the memory for both the control block and the managed object is <strong>created with a single allocation</strong><sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>. For this sack, you should generally use <code class="language-plaintext highlighter-rouge">make_shared</code> or <code class="language-plaintext highlighter-rouge">allocate_shared</code> instead of constructors to create shared pointers.</p>

<h3 id="allocator">Allocator</h3>
<p>In addition to the deleter, it is possible to configure the <em>allocator</em> of a <code class="language-plaintext highlighter-rouge">std::shared_ptr</code>. The default allocator <code class="language-plaintext highlighter-rouge">std::allocator</code> allocates memory from the dynamic storage. But for some historical reason, you can’t use custom deleter or custom allocators in <code class="language-plaintext highlighter-rouge">make_share</code>. Instead, you are supposed to use <code class="language-plaintext highlighter-rouge">std::allocate_shared</code> for this purpose.</p>

<p>This example illustrates the usage of allocator.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">size_t</span> <span class="n">n_allocated</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="n">n_deallocated</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">MyAllocator</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

    <span class="n">MyAllocator</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">U</span><span class="p">&gt;</span>
    <span class="n">MyAllocator</span><span class="p">(</span><span class="k">const</span> <span class="n">MyAllocator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{}</span>

    <span class="n">T</span><span class="o">*</span> <span class="n">allocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
        <span class="o">++</span><span class="n">n_allocated</span><span class="p">;</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">deallocate</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="o">++</span><span class="n">n_deallocated</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">TEST_CLASS</span><span class="p">(</span><span class="n">SharedPtrs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">TEST_METHOD</span><span class="p">(</span><span class="n">Shared_Ptrs_Support_Allocators</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">MyAllocator</span><span class="o">&lt;</span><span class="n">Kingdom</span><span class="o">&gt;</span> <span class="n">my_alloc</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">aragorn</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocate_shared</span><span class="o">&lt;</span><span class="n">Kingdom</span><span class="o">&gt;</span><span class="p">(</span><span class="n">my_alloc</span><span class="p">,</span> <span class="s">"aragorn"</span><span class="p">);</span>

        <span class="n">by_val</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">aragorn</span><span class="p">));</span>
        <span class="n">Assert</span><span class="o">::</span><span class="n">IsTrue</span><span class="p">(</span><span class="n">Kingdom</span><span class="o">::</span><span class="n">number_of_kindom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

        <span class="n">Assert</span><span class="o">::</span><span class="n">IsTrue</span><span class="p">(</span><span class="n">n_allocated</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">Assert</span><span class="o">::</span><span class="n">IsTrue</span><span class="p">(</span><span class="n">n_deallocated</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>By the way, the deleters work the same way for shared pointers as they do for unique pointers.</p>

<h2 id="weak-pointers">Weak Pointers</h2>
<p>A weak pointer is a special kind of smart pointer that has ownership. It can be “promoted” to a shared pointer when necessary. In general, weak pointers allow you to track object and convert to a shared pointer <em>only if the tracked object is still alive</em>.</p>

<p>A common usage for weak pointers is <em>cache</em>, which is often temporary and programmers should provide a appropriate fallbacks when the cache is failed.</p>

<p>The stdlib has a <code class="language-plaintext highlighter-rouge">std::weak_ptr</code>, and Boost also has a <code class="language-plaintext highlighter-rouge">boost::weak_ptr</code>. They are used with their respective shared pointers.</p>

<p>The constructor of a weak pointer takes a shared pointer. To convert it to a shared pointer, invoke the <code class="language-plaintext highlighter-rouge">lock()</code> method.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_METHOD</span><span class="p">(</span><span class="n">Weak_Ptrs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">aragorn</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Kingdom</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"aragorn"</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">weak_refer</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Kingdom</span><span class="o">&gt;</span><span class="p">{</span> <span class="n">aragorn</span> <span class="p">};</span>

    <span class="n">Assert</span><span class="o">::</span><span class="n">IsTrue</span><span class="p">(</span><span class="n">aragorn</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">shared_refer</span> <span class="o">=</span> <span class="n">weak_refer</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>

    <span class="n">Assert</span><span class="o">::</span><span class="n">IsTrue</span><span class="p">(</span><span class="n">aragorn</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="intrusive-pointers">Intrusive Pointers</h2>

<blockquote class="info">
  <p>This section is here only for reminding that “there is such a pointer”.</p>
</blockquote>

<p>A intrusive pointer is a shared pointer to an object with an embedded reference count. For the <code class="language-plaintext highlighter-rouge">boost::intrusive_ptr</code>, every new <code class="language-plaintext highlighter-rouge">intrusive_ptr</code> instance increments the reference count by using an unqualified call to the function <code class="language-plaintext highlighter-rouge">intrusive_ptr_add_ref</code>, passing it the pointer as an argument. Similarly, when an <code class="language-plaintext highlighter-rouge">intrusive_ptr</code> is destroyed, it calls <code class="language-plaintext highlighter-rouge">intrusive_ptr_release</code>; this function is responsible for destroying the object when its reference count drops to zero.</p>

<p>It’s rare to use an intrusive pointer. Plus, there is no standard “interface” mechanism in C++, making it even more hard to use and maintain. Unless there is a strong reason, for example, some existing frameworks or OSes provide objects with embedded reference counts, you should not consider intrusive pointers.</p>

<h2 id="references">References</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Resource acquisition is initialization. (2023). Retrieved from <code class="language-plaintext highlighter-rouge">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</code> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>TylerMSFT. (2023). Microsoft.VisualStudio.TestTools.CppUnitTestFramework API - Visual Studio (Windows). Retrieved from https://learn.microsoft.com/en-us/visualstudio/test/microsoft-visualstudio-testtools-cppunittestframework-api-reference?view=vs-2022 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">std::shared_ptr</code>. (2023). Retrieved from https://en.cppreference.com/w/cpp/memory/shared_ptr <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div><a class="u-url" href="/c++/2023/12/14/smart-pointers-CPP.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    
    <div class="footer-col-wrapper">
      <div class="footer-col">
        <h2 class="footer-heading">Chew&#39;s Everyday Blog</h2>By wisdom a house is built, and through understanding it is established.</div>
      <div class="footer-col">
        <ul class="contact-list">
          <li class="p-name">Author: Chew Y. Feng</li><li>
              <span>
                Mail: 
              </span>
            <a class="u-email" href="mailto:chew.y.feng@outlook.com">chew.y.feng@outlook.com</a></li><div>
              Find me:<ul class="social-media-list"><li><a href="https://github.com/excitedspider"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">excitedspider</span></a></li><li><a href="https://www.linkedin.com/in/qiuyi-feng-348968287"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">qiuyi-feng-348968287</span></a></li></ul>
</div>
            <div class="footer-col-rss">
              <p class="rss-subscribe">subscribe <a href="/feed.xml">via RSS</a></p>
            </div>
        </ul>
      </div>

    </div>

  </div>

</footer>
</body>

</html>
