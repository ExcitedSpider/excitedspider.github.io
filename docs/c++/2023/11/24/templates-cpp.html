<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Templates in CPP | Chew’s Everyday Blog</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Templates in CPP" />
<meta name="author" content="Chew Y. Feng" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Templates, Concepts and Polymorphism" />
<meta property="og:description" content="Templates, Concepts and Polymorphism" />
<link rel="canonical" href="/c++/2023/11/24/templates-cpp.html" />
<meta property="og:url" content="/c++/2023/11/24/templates-cpp.html" />
<meta property="og:site_name" content="Chew’s Everyday Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-24T00:00:00+11:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Templates in CPP" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Chew Y. Feng"},"dateModified":"2023-11-24T17:43:22+11:00","datePublished":"2023-11-24T00:00:00+11:00","description":"Templates, Concepts and Polymorphism","headline":"Templates in CPP","mainEntityOfPage":{"@type":"WebPage","@id":"/c++/2023/11/24/templates-cpp.html"},"url":"/c++/2023/11/24/templates-cpp.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Chew&apos;s Everyday Blog" /><script>
    // for MathJax inline
    window.MathJax = {
      tex: {
        inlineMath: [['_', '_'], ['$', '$'], ['\\(', '\\)']]
      }
    };
  </script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/css-doodle/0.37.4/css-doodle.min.js"></script>
  <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Teko">
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Chew&#39;s Everyday Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="page-content-background">
        <css-doodle click-to-update>
          <style>
            @grid: 1 / 100vw 100vh / #0a0c27;
            background-size: 200px 200px;
            background-image: @doodle(
              @grid: 6 / 100%;
              @size: 4px;
              font-size: 4px;
              color: hsl(@r240, 30%, 50%);
              box-shadow: @m3x5(
                calc(4em - @nx * 1em) calc(@ny * 1em)
                  @p(@m3(currentColor), @m2(transparent)),
                calc(2em + @nx * 1em) calc(@ny * 1em)
                  @lp
              );
            );
          </style>
        </css-doodle>
      </div>
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Templates in CPP</h1>
    <p class="post-meta"><span class="tags">
        
      </span><time class="dt-published" datetime="2023-11-24T00:00:00+11:00" itemprop="datePublished">
        Posted At: Nov 24, 2023
      </time><time>
        Modified At: Nov 24, 2023
      </time><span class="dt-tags">
        Category:
        
          <span>C++</span>
        
      </span></p>
  </header>


  <div class="post-content e-content" itemprop="articleBody">
    <ul id="markdown-toc">
  <li><a href="#basic-usage-of-templates" id="markdown-toc-basic-usage-of-templates">Basic Usage of Templates</a>    <ul>
      <li><a href="#template-functions" id="markdown-toc-template-functions">Template Functions</a></li>
      <li><a href="#template-classes" id="markdown-toc-template-classes">Template Classes</a></li>
      <li><a href="#type-deduction" id="markdown-toc-type-deduction">Type Deduction</a></li>
    </ul>
  </li>
  <li><a href="#concepts" id="markdown-toc-concepts">Concepts</a>    <ul>
      <li><a href="#preconcepts-makeshift" id="markdown-toc-preconcepts-makeshift">Preconcepts Makeshift</a></li>
    </ul>
  </li>
  <li><a href="#non-type-parameters" id="markdown-toc-non-type-parameters">Non-type parameters</a></li>
  <li><a href="#templates-as-template-parameters" id="markdown-toc-templates-as-template-parameters">Templates as template parameters</a></li>
  <li><a href="#polymorphism-at-runtime-vs-compile-time" id="markdown-toc-polymorphism-at-runtime-vs-compile-time">Polymorphism at Runtime vs Compile Time</a></li>
  <li><a href="#example-function-mode" id="markdown-toc-example-function-mode">Example: function <code class="language-plaintext highlighter-rouge">mode</code></a></li>
</ul>

<p>If name only one most distinctive feature of CPP, I would probably say <strong>Compile-time Polymorphism</strong>, that is, the use of <strong>templates</strong>. Although there are many junks in the language, but the designers of CPP did a great job devising templates.</p>

<h2 id="basic-usage-of-templates">Basic Usage of Templates</h2>
<p>A template is a <strong>class</strong> or <strong>function</strong> with <strong>template parameters</strong>, which can stand in for any types. The basic idea of template is that, rather than copy and paste similar classes and functions, you just need to write a single template, and the <strong>compiler generates new instances</strong> when it encounters a new combination of types. Therefore, the process of <strong>instantiations</strong> are executed in the <strong>compiling stage</strong>, instead of runtime stage.</p>

<h3 id="template-functions">Template Functions</h3>
<p>The function <code class="language-plaintext highlighter-rouge">mean</code> compute the average value of an array of items. To accommodate different types (int, long, double…), it employs a template parameter <code class="language-plaintext highlighter-rouge">T</code>.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">mean</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">values</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">T</span> <span class="n">result</span><span class="p">{};</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">{};</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span> <span class="o">/</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The usage of <code class="language-plaintext highlighter-rouge">mean</code>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">nums_d</span><span class="p">[]{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span> <span class="p">};</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">mean</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nums_d</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"double: %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result1</span><span class="p">);</span>

  <span class="k">const</span> <span class="kt">float</span> <span class="n">nums_f</span><span class="p">[]{</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">2.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">3.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">4.0</span><span class="n">f</span> <span class="p">};</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">mean</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nums_f</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"float: %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result2</span><span class="p">);</span>

  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">nums_c</span><span class="p">[]{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">mean</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nums_c</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"size_t: %zd</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result3</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>We can see that the template parameter is applied <code class="language-plaintext highlighter-rouge">double</code>, <code class="language-plaintext highlighter-rouge">float</code> and <code class="language-plaintext highlighter-rouge">size_t</code> correspondingly to accommodate different types of arrays. In compiling stage, the compiler would generate 3 overloading <code class="language-plaintext highlighter-rouge">mean</code> functions.</p>

<h3 id="template-classes">Template Classes</h3>
<p>The <code class="language-plaintext highlighter-rouge">SimpleUniquePointer</code> is an RAII wrapper for objects which use storage, which is a “prototype” of the stdlib’s <code class="language-plaintext highlighter-rouge">std::unique_ptr</code>.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">SimpleUniquePointer</span> <span class="p">{</span>
  <span class="n">SimpleUniquePointer</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">SimpleUniquePointer</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">pointer</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">pointer</span><span class="p">{</span> <span class="n">pointer</span> <span class="p">}</span> <span class="p">{}</span>
  <span class="o">~</span><span class="n">SimpleUniquePointer</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pointer</span><span class="p">)</span> <span class="k">delete</span> <span class="n">pointer</span><span class="p">;</span> <span class="c1">// 1</span>
  <span class="p">}</span>
  <span class="n">SimpleUniquePointer</span><span class="p">(</span><span class="k">const</span> <span class="n">SimpleUniquePointer</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 2</span>
  <span class="n">SimpleUniquePointer</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">SimpleUniquePointer</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 3</span>
  <span class="n">SimpleUniquePointer</span><span class="p">(</span><span class="n">SimpleUniquePointer</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="c1">// 4</span>
      <span class="o">:</span> <span class="n">pointer</span><span class="p">{</span> <span class="n">other</span><span class="p">.</span><span class="n">pointer</span> <span class="p">}</span> <span class="p">{</span>
    <span class="n">other</span><span class="p">.</span><span class="n">pointer</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">SimpleUniquePointer</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">SimpleUniquePointer</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="c1">// 5</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pointer</span><span class="p">)</span>
      <span class="k">delete</span> <span class="n">pointer</span><span class="p">;</span>
    <span class="n">pointer</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">pointer</span><span class="p">;</span>
    <span class="n">other</span><span class="p">.</span><span class="n">pointer</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">pointer</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nl">private:</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">pointer</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>In 1, it makes sure that when <code class="language-plaintext highlighter-rouge">SimpleUniquePointer</code> object is destructed, the resource is recycled. Marks 2 and 3 explicitly declare that <code class="language-plaintext highlighter-rouge">SimpleUniquePointer</code> do not support copy construction and copy assignments, which is a good practice to force a single ownership of the point-to object. Marks 4 5 implement the move constructor and move assignments.</p>

<p>With <code class="language-plaintext highlighter-rouge">SimpleUniquePointer</code>, it is more easy to handle free-store-allocated objects:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">ptr_numbers</span> <span class="o">=</span> <span class="n">SimpleUniquePointer</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">36</span><span class="p">]);</span>
<span class="k">auto</span> <span class="n">ptr_string</span> <span class="o">=</span> <span class="n">SimpleUniquePointer</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">15</span><span class="p">]);</span>
</code></pre></div></div>

<p>Another concrete example by tracing the life cycle of objects:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Tracer</span> <span class="p">{</span>
  <span class="n">Tracer</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">name</span><span class="p">{</span> <span class="n">name</span> <span class="p">}</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s constructed.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="o">~</span><span class="n">Tracer</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s destructed.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nl">private:</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">SimpleUniquePointer</span><span class="o">&lt;</span><span class="n">Tracer</span><span class="o">&gt;</span> <span class="n">consumer_ptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"(cons) consumer_ptr: 0x%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">consumer_ptr</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">ptr_a</span> <span class="o">=</span> <span class="n">SimpleUniquePointer</span><span class="o">&lt;</span><span class="n">Tracer</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Tracer</span><span class="p">{</span> <span class="s">"ptr_a"</span> <span class="p">});</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"(main) ptr_a: 0x%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr_a</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
  <span class="n">consumer</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ptr_a</span><span class="p">));</span> <span class="c1">// 1</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"(main) ptr_a: 0x%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr_a</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
<p>With output:</p>
<pre><code class="language-plain">ptr_a constructed.
(main) ptr_a: 0x0000020E8F422190
(cons) consumer_ptr: 0x0000020E8F422190
ptr_a destructed.
(main) ptr_a: 0x0000000000000000
</code></pre>
<p>In 1, the <code class="language-plaintext highlighter-rouge">ptr_a</code> is moved to the argument <code class="language-plaintext highlighter-rouge">consumer_ptr</code> of consumer. After the execution of <code class="language-plaintext highlighter-rouge">consumer</code>, <code class="language-plaintext highlighter-rouge">consumer_ptr</code> is out of scope thus be recycled, where we observe the value <code class="language-plaintext highlighter-rouge">ptr_a</code> be reset to 0.</p>
<h3 id="type-deduction">Type Deduction</h3>
<p>You are not always require to provide the type parameters if the compiler can guess it from the context.  For example, the previous usage of <code class="language-plaintext highlighter-rouge">mean</code> can be simplified to</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">double</span> <span class="n">nums_d</span><span class="p">[]{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span> <span class="p">};</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">nums_d</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// no need to give &lt;double&gt; parameter</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"double: %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result1</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="concepts">Concepts</h2>
<p>Technically, for the <code class="language-plaintext highlighter-rouge">mean</code> function discussed in the previous section, it cannot accept <em>any type</em>. There are a few silent requirement for <code class="language-plaintext highlighter-rouge">T</code>:</p>
<ul>
  <li>It is default constructable.</li>
  <li>It should supports <code class="language-plaintext highlighter-rouge">+</code> (plus operator)</li>
  <li>It should supports <code class="language-plaintext highlighter-rouge">/</code> (divide by integers)
CPP don’t perform these type checking by default. If wrong type is feed to <code class="language-plaintext highlighter-rouge">mean</code>, for example, a <code class="language-plaintext highlighter-rouge">char</code>, templates might blow up until very late in the compilation process, given extremely notorious error message. And <strong>you cannot know whether the compilation can be successful until you compile it</strong>.</li>
</ul>

<p>There are many makeshift for this problem, but all of them are not really satisfactory. It was until very recently (C++20) that the <em>concepts</em> come on the stage. <em>Concepts</em> provides a formal way to constrain template parameters.</p>

<p>Before delving into the example, it is worth noticing that concepts feature is new to C++ standard specification, and different compilers can have different implementation progress. This post mainly discusses the MSVC compilers according to <a href="https://devblogs.microsoft.com/cppblog/c20-concepts-are-here-in-visual-studio-2019-version-16-3/">this article</a> from MS C++ team.</p>

<p>This concept find out if <code class="language-plaintext highlighter-rouge">T::value</code> can be implicitly convert to bool</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;concepts&gt;
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">has_bool_value_member</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">{</span> <span class="p">{</span> <span class="n">T</span><span class="o">::</span><span class="n">value</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">convertible_to</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">;</span> <span class="p">};</span>

<span class="k">struct</span> <span class="nc">S3</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nc">S4</span> <span class="p">{</span> <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">S5</span> <span class="p">{</span> <span class="k">static</span> <span class="k">constexpr</span> <span class="n">S3</span> <span class="n">value</span><span class="p">{};</span> <span class="p">};</span>

<span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">has_bool_value_member</span><span class="o">&lt;</span><span class="n">S3</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">has_bool_value_member</span><span class="o">&lt;</span><span class="n">S4</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">has_bool_value_member</span><span class="o">&lt;</span><span class="n">S5</span><span class="o">&gt;</span><span class="p">);</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">std::convertible_to</code> is a standard concept in <code class="language-plaintext highlighter-rouge">&lt;concept&gt;</code> header. There are many other standard library concepts as well: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf">&lt;concept&gt;</a>. We can also make use of [Standard library header <type_traits>](https://en.cppreference.com/w/cpp/header/type_traits) as concepts as well:</type_traits></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;type_traits&gt;
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="n">concept</span> <span class="n">Averagable</span> <span class="o">=</span> 
	<span class="n">is_add_supported</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_default_constructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="c1">// is_default_constructible is from &lt;type_traits&gt;</span>
</code></pre></div></div>

<p>As we can see, <strong>a concept is also a template</strong>. It is more easy to think <strong>concept as a <em>predicate</em>:</strong> if a set of template parameters meets the criteria of a given concept, the concept evaluates to <code class="language-plaintext highlighter-rouge">true</code> at compile time.</p>

<p>The <code class="language-plaintext highlighter-rouge">requires</code> keyword forms a requirement expression, which is a predicate. It is acceptable to combine multiple predicates:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="n">concept</span> <span class="n">is_numeral</span> <span class="o">=</span>
	<span class="n">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span> <span class="o">&amp;&amp;</span> <span class="c1">// T must support add operator</span>
	<span class="n">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="o">/</span> <span class="kt">size_t</span><span class="p">{</span> <span class="mi">1</span> <span class="p">};</span> <span class="p">};</span> <span class="c1">// T must support divide (by integer) operator</span>
</code></pre></div></div>

<p>To use a concept in functions, add an requirement expression in the signature of the function:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This concept tests whether 't + u' is a valid expression</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">U</span><span class="p">&gt;</span>
<span class="n">concept</span> <span class="n">can_add</span> <span class="o">=</span> <span class="n">requires</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span> <span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">;</span> <span class="p">};</span>

<span class="c1">// The function is only a viable candidate if 't + u' is a valid expression</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">U</span><span class="p">&gt;</span> <span class="n">requires</span> <span class="n">can_add</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="preconcepts-makeshift">Preconcepts Makeshift</h3>
<p>Before C++20, concepts aren’t a part of the standard. Programmers often make use of  <code class="language-plaintext highlighter-rouge">static_assert</code> as makeshifts.</p>

<p>A <code class="language-plaintext highlighter-rouge">static_assert</code> make an assertion that evaluates at compile time. If an assertion fails, the compiler will issue an error and stop compiling.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;type_traits&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">mean</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">values</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_default_constructible</span><span class="p">(),</span> 
		<span class="s">"Type must be default constructible."</span><span class="p">);</span>
	<span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>It is ugly though, but it is a legit makeshift for those working on old version of compilers.</p>

<h2 id="non-type-parameters">Non-type parameters</h2>
<p>Apart from template type parameters, C++ templates support <em>non-type parameters</em> as well, also called value parameters.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">Index</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">Length</span><span class="p">&gt;</span>
<span class="n">T</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">(</span><span class="n">T</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">)[</span><span class="n">Length</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">Index</span> <span class="o">&lt;</span> <span class="n">Length</span><span class="p">,</span> <span class="s">"Out of bounds access"</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">Index</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">Length</code> parameter is a non-type parameters, which can be used to initialize different <code class="language-plaintext highlighter-rouge">get</code> functions:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int fib[]{ 1, 1, 2, 0 };
printf("%d %d %d ", get&lt;0&gt;(fib), get&lt;1&gt;(fib), get&lt;2&gt;(fib)); // 1 1 2
</code></pre></div></div>

<h2 id="templates-as-template-parameters">Templates as template parameters</h2>
<p>A template can be a template parameter.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Arr</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">MyClass2</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">t</span><span class="p">;</span> <span class="c1">//OK</span>
    <span class="n">Arr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="polymorphism-at-runtime-vs-compile-time">Polymorphism at Runtime vs Compile Time</h2>
<p>Compile time polymorphism has more advantages: higher performance, more predictable and more readable. It is generally commended to use runtime polymorphism (templates). But sometimes you won’t know the types used with your code until runtime. In such cases, use runtime polymorphism instead.</p>

<p>For more information about runtime polymorphism, check my another post:<a href="/c++/2023/11/18/Runtime-Polymorphism-CPP.html">Runtime-Polymorphism-CPP</a></p>

<h2 id="example-function-mode">Example: function <code class="language-plaintext highlighter-rouge">mode</code></h2>
<p>The mode of a series of values is the value that appears most commonly. The implementation follows:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;map&gt;
#include &lt;type_traits&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">mode</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">values</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span> <span class="n">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">countMap</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">countMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">countMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="n">countMap</span><span class="p">[</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;*</span> <span class="n">maxpair</span><span class="p">{</span><span class="nb">nullptr</span><span class="p">};</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">countMap</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maxpair</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">pair</span><span class="p">.</span><span class="n">second</span> <span class="o">&gt;</span> <span class="n">maxpair</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">)</span>
			<span class="n">maxpair</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pair</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">maxpair</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">?</span> <span class="n">maxpair</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="err">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">x1</span><span class="p">[]{</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">5123</span> <span class="p">};</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"The mode of x1 is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mode</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="mi">6</span><span class="p">));</span>

	<span class="kt">short</span> <span class="n">x2</span><span class="p">[]{</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">5123</span> <span class="p">};</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"The mode of x2 is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mode</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">6</span><span class="p">));</span>

	<span class="c1">// will indeed fail because the associated constraints are not satisfied</span>
	<span class="c1">//double x3[]{ 30.0, 0, 100, 400, 30, 5123 };</span>
	<span class="c1">//printf("The mode of x3 is %f\n", mode(x3, 6));</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>Use template to accommodate both <code class="language-plaintext highlighter-rouge">int[]</code>  and <code class="language-plaintext highlighter-rouge">short[]</code>.</li>
  <li>Use concepts to check type - The requirement expression examines if the supplied type is an integer.</li>
</ul>

  </div><a class="u-url" href="/c++/2023/11/24/templates-cpp.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    
    <div class="footer-col-wrapper">
      <div class="footer-col">
        <h2 class="footer-heading">Chew&#39;s Everyday Blog</h2>By wisdom a house is built, and through understanding it is established.</div>
      <div class="footer-col">
        <ul class="contact-list">
          <li class="p-name">Author: Chew Y. Feng</li><li>
              <span>
                Mail: 
              </span>
            <a class="u-email" href="mailto:chew.y.feng@outlook.com">chew.y.feng@outlook.com</a></li><div>
              Find me:<ul class="social-media-list"><li><a href="https://github.com/excitedspider"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">excitedspider</span></a></li></ul>
</div>
            <div class="footer-col-rss">
              <p class="rss-subscribe">subscribe <a href="/feed.xml">via RSS</a></p>
            </div>
        </ul>
      </div>

    </div>

  </div>

</footer>
</body>

</html>
