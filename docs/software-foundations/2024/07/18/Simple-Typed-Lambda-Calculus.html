<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Simply Typed Lambda-Calculus | Chew’s Everyday Blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Simply Typed Lambda-Calculus" />
<meta name="author" content="Chew Y. Feng" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A small yet powerful language" />
<meta property="og:description" content="A small yet powerful language" />
<link rel="canonical" href="/software-foundations/2024/07/18/Simple-Typed-Lambda-Calculus.html" />
<meta property="og:url" content="/software-foundations/2024/07/18/Simple-Typed-Lambda-Calculus.html" />
<meta property="og:site_name" content="Chew’s Everyday Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-07-18T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Simply Typed Lambda-Calculus" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Chew Y. Feng"},"dateModified":"2024-07-18T07:28:57+00:00","datePublished":"2024-07-18T00:00:00+00:00","description":"A small yet powerful language","headline":"Simply Typed Lambda-Calculus","mainEntityOfPage":{"@type":"WebPage","@id":"/software-foundations/2024/07/18/Simple-Typed-Lambda-Calculus.html"},"url":"/software-foundations/2024/07/18/Simple-Typed-Lambda-Calculus.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Chew&apos;s Everyday Blog" /><script>
    // for MathJax inline
    window.MathJax = {
      tex: {
        inlineMath: [['_', '_'], ['$', '$'], ['\\(', '\\)']]
      }
    };
  </script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/css-doodle/0.37.4/css-doodle.min.js"></script>
  <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Teko">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-4TZZDRT6JY"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-4TZZDRT6JY');
  </script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Chew&#39;s Everyday Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="page-content-background">
        <css-doodle click-to-update>
          <style>
            @grid: 1 / 100vw 100vh / #0a0c27;
            background-size: 200px 200px;
            background-image: @doodle(
              @grid: 6 / 100%;
              @size: 4px;
              font-size: 4px;
              color: hsl(@r240, 30%, 50%);
              box-shadow: @m3x5(
                calc(4em - @nx * 1em) calc(@ny * 1em)
                  @p(@m3(currentColor), @m2(transparent)),
                calc(2em + @nx * 1em) calc(@ny * 1em)
                  @lp
              );
            );
          </style>
        </css-doodle>
      </div>
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Simply Typed Lambda-Calculus</h1>
    <p class="post-meta"><span class="tags">
        
          <span>Coq</span>
        
          <span>PLT</span>
        
      </span><time class="dt-published" datetime="2024-07-18T00:00:00+00:00" itemprop="datePublished">
        Posted At: Jul 18, 2024
      </time><time>
        Modified At: Jul 18, 2024
      </time><span class="dt-tags">
        Category:
        
          <span>Software-Foundations</span>
        
      </span></p>
  </header>


  <div class="post-content e-content" itemprop="articleBody">
    <p>This article is a study note of <a href="https://softwarefoundations.cis.upenn.edu/plf-current/Stlc.html">Programming Language Foundation</a></p>

<h2 id="overview">Overview</h2>

<p>The simply typed lambda calculus (STLC) is a wonderful study target which represents many intriguing language features among modern programming language.</p>

<p>Lambda calculus (also written as λ-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution (From Wikipedia).</p>

<p>Consider a lambda-calculus system that only contains Boolean values, which can be expressed by following BNF notation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>t ::= x                      (variable)
 | \x:T,t                    (abstraction)
 | t t                       (application)
 | true                      (constant true)
 | false                     (constant false)
 | if t then t else t        (conditional)
</code></pre></div></div>

<p>Examples:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">\</span><span class="n">x</span><span class="o">:</span> <span class="n">Bool</span><span class="p">,</span> <span class="n">x</span> <span class="c1">// identity function</span>
<span class="p">(</span><span class="err">\</span><span class="n">x</span><span class="o">:</span> <span class="n">Bool</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="nb">true</span> <span class="c1">// apply the identity function to value true</span>
<span class="err">\</span><span class="n">x</span><span class="o">:</span><span class="n">Bool</span><span class="p">,</span><span class="err"> </span><span class="k">if</span><span class="err"> </span><span class="n">x</span><span class="err"> </span><span class="n">then</span><span class="err"> </span><span class="nb">false</span><span class="err"> </span><span class="k">else</span><span class="err"> </span><span class="nb">true</span> <span class="c1">// function 'not'</span>
<span class="err">\</span><span class="n">f</span><span class="o">:</span><span class="n">Bool</span><span class="err">→</span><span class="n">Bool</span><span class="p">,</span><span class="err"> </span><span class="n">f</span><span class="err"> </span><span class="p">(</span><span class="n">f</span><span class="err"> </span><span class="nb">true</span><span class="p">)</span> <span class="c1">// a higher order function</span>
</code></pre></div></div>

<p>Although it only contains Boolean values, it processes the computation ability that equivalent any modern programming languages. It even supports higher order function that some “modern” languages don’t support well, like C and C++.</p>

<p>Note that there are variables involved in the definition. A <em>complete</em> program is a program that never refer to any undefined variables. In most time, we want the program to be complete and we can simply fail there are free variables (which doesn’t bind to any terms and types).</p>
<h2 id="operational-semantics">Operational Semantics</h2>

<h3 id="values">Values</h3>

<p>To decide what are the <em>values</em> of STLC, a little discussion is needed on the case of abstraction. An abstraction (similar to a “function” in imperative programming language) is of such form</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\x:T, t
</code></pre></div></div>

<p>There are two choices:</p>
<ol>
  <li>An abstraction is always a value</li>
  <li>An abstraction is a value if <code class="language-plaintext highlighter-rouge">t</code> is a value</li>
</ol>

<p>I would say I prefer option 1, and that is the choice in the textbook, because it makes things a lot easier. But option 2 is also the choice for some language, for some reasons like compile-time optimization.</p>

<h3 id="substitution">Substitution</h3>

<p>The heart of lambda calculus is substitution. For example, we reduce</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> (\x:Bool, if x then true else x) false
</code></pre></div></div>

<p>to</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if false then true else false
</code></pre></div></div>

<p>The application works by substitute <code class="language-plaintext highlighter-rouge">\x</code> into the bind value <code class="language-plaintext highlighter-rouge">false</code>. We mark the substitution as <code class="language-plaintext highlighter-rouge">[x:=s]t</code>, which literally says “substitute all occurrences of <code class="language-plaintext highlighter-rouge">x</code> into <code class="language-plaintext highlighter-rouge">s</code> in the term <code class="language-plaintext highlighter-rouge">t</code>”.</p>

<p>More example:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">[x:=true] (if x then x else y)</code> yields <code class="language-plaintext highlighter-rouge">if true then true else y</code></li>
  <li><code class="language-plaintext highlighter-rouge">[x:=true](\y:Bool,x)</code> yields <code class="language-plaintext highlighter-rouge">\y:Bool,true</code></li>
</ul>

<p>Substitution is a deterministic and easy problem (i.e. not a NP-hard one). So the textbook simply encoded substitution into a fixpoint function <code class="language-plaintext highlighter-rouge">subst</code>. It’s very interesting to think how a powerful computation model is just such a small substitution machine.</p>

<p>Exercise: 3 stars, standard (substi_correct)
This Exercise asks us to define substitution as a inductive relation <code class="language-plaintext highlighter-rouge">substi</code> , and prove the relation is equivalent to the fixpoint version.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">substi</span><span class="w"> </span><span class="o">(</span><span class="no">s</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">tm</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kr">Prop</span><span class="w">

</span><span class="k">Theorem</span><span class="w"> </span><span class="no">substi_correct</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="no">t'</span><span class="o">,</span><span class="w">
  </span><span class="o">&lt;{</span><span class="w"> </span><span class="o">[</span><span class="no">x</span><span class="p">:</span><span class="o">=</span><span class="no">s</span><span class="o">]</span><span class="no">t</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">t'</span><span class="w"> </span><span class="o">&lt;-&gt;</span><span class="w"> </span><span class="no">substi</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="no">t'</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>For direction <code class="language-plaintext highlighter-rouge">-&gt;</code>, it can be proved by induction on term <code class="language-plaintext highlighter-rouge">t</code></li>
  <li>For direction <code class="language-plaintext highlighter-rouge">&lt;-</code>, it can be proved by induction on relation <code class="language-plaintext highlighter-rouge">substi</code></li>
</ul>

<h3 id="reduction">Reduction</h3>

<p>Based on substitution, we can define how an expression is <em>reduced</em> to value. The core of reduction is the application rule, which says</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(\x:T,t) v --&gt; [x:=v] t
</code></pre></div></div>

<p>To make the process of reduction to be deterministic, we made a design: 
<strong>Apply reduction of application expression only if both the left-hand side (the abstraction) and the right-hand side (the argument) is a value.</strong></p>

<h2 id="typing">Typing</h2>

<p>The STLC has a powerful feature – typing, which becomes more and more important in programming language design. For some reasons, computer scientists write typing relation as following form:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|-- t \in T
</code></pre></div></div>

<p>which says that “term t has type T”.</p>

<p>An obvious problem is typing abstractions. Consider such abstraction:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\x:T1, t2
</code></pre></div></div>

<p>which has type <code class="language-plaintext highlighter-rouge">T1 -&gt; T2</code>. If we want to typecheck it, we need to make sure term <code class="language-plaintext highlighter-rouge">t2</code> has type <code class="language-plaintext highlighter-rouge">T2</code> <strong>under the context that <code class="language-plaintext highlighter-rouge">x</code> has type <code class="language-plaintext highlighter-rouge">T1</code>.</strong></p>

<p>Context can be represented as a single global information, which adds to the typing relation. A map (partial-map) is capable of representing such information, which we name it <em>Gamma</em>. The new typing judgment is written <code class="language-plaintext highlighter-rouge">Gamma |-- t \in T</code> and informally read as “term t has type T, given the types of free variables in t as specified by Gamma”.</p>

<p>Examples:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Example</span><span class="w"> </span><span class="no">typing_example_1</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="no">empty</span><span class="w"> </span><span class="o">|--</span><span class="w"> </span><span class="err">\</span><span class="no">x</span><span class="p">:</span><span class="no">Bool</span><span class="o">,</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="err">\</span><span class="kr">in</span><span class="w"> </span><span class="o">(</span><span class="no">Bool</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">Bool</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>Finally, we present the typing rule of abstraction:</p>

<p>\(\frac{x \mapsto T2 ; \Gamma \vdash t1 \in T1}{
\Gamma \vdash \backslash x:T2,t1 \in T2\to T1
}\)
Other rules can be found in the textbook as well.</p>

<p>Talking about variables, a term is <em>closed</em> if all variables in it are well typed (contain no free variables).</p>

<h2 id="properties-of-stlc">Properties of STLC</h2>

<p>We discuss what makes the language to be “well and sound”.</p>

<h3 id="canonical-form">Canonical Form</h3>

<p>We can establish the relation between well-typed values (canonical form)  and their type. For example, if a value has type <code class="language-plaintext highlighter-rouge">Bool</code>, it must be a <code class="language-plaintext highlighter-rouge">false</code> or <code class="language-plaintext highlighter-rouge">true</code>.</p>
<h3 id="progress">Progress</h3>

<p>The progress theorem tells us that closed, well-typed terms are not stuck: either a well-typed term is a value, or it can take a reduction step.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">progress</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="no">T</span><span class="o">,</span><span class="w">
  </span><span class="no">empty</span><span class="w"> </span><span class="o">|--</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="err">\</span><span class="kr">in</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="p">→</span><span class="w">
  </span><span class="no">value</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="o">\/</span><span class="w"> </span><span class="p">∃</span><span class="w"> </span><span class="no">t'</span><span class="o">,</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="no">t'</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>Exercise: 3 stars, advanced (progress_from_term_ind).</p>

<p>It asks us to prove theorem <code class="language-plaintext highlighter-rouge">progess</code> by induction on terms. The proof is a bit long but not complicated. Just follow the reduction rules to see if it can make a step, or it is a value, or there is a contradiction in hypothesis.</p>

<h3 id="preservation">Preservation</h3>

<p>The preservation theorem says reduction doesn’t change the type of a term (so it <em>preserves</em> the type). This property shows our typing is indeed sound and well-fitted into the operational semantics.</p>

<p>To establish the preservation property on STLC, we take a few steps:</p>
<ol>
  <li>The Weakening Lemma, which says if <code class="language-plaintext highlighter-rouge">t</code> has type <code class="language-plaintext highlighter-rouge">T</code> in some context <code class="language-plaintext highlighter-rouge">Gamma</code>and  <code class="language-plaintext highlighter-rouge">Gamma</code> is included in a bigger context <code class="language-plaintext highlighter-rouge">Gamma'</code>, t also has type <code class="language-plaintext highlighter-rouge">T</code> in <code class="language-plaintext highlighter-rouge">Gamma'</code>.
 To prove this, one need to consider what “a context is included in other context” means. But it’s fairly straightforward.</li>
  <li>The Substitution Lemma, which says substitution preserves the type.</li>
  <li>The main theorem. With the help of substitution lemma, it can be proved with ease.</li>
</ol>

<p>Exercise: 3 stars, advanced (substitution_preserves_typing_from_typing_ind)
It asks us to prove the substitution lemma, which lies at the heart of this proof chain. A few tips:</p>
<ul>
  <li>Read carefully about the informal proof provided by the author.</li>
  <li>When encounter <code class="language-plaintext highlighter-rouge">(x =? y)%string</code> (string equality), use <code class="language-plaintext highlighter-rouge">destruct eqb_spec</code> to perform case analysis.</li>
  <li>When the goal is the form <code class="language-plaintext highlighter-rouge">Gamma |-- t \in T</code>, you can use the weakening lemma to transform it to <code class="language-plaintext highlighter-rouge">empty |-- t \in t</code>.</li>
</ul>

<p>Exercise: 2 stars, standard, especially useful (subject_expansion_stlc)
Show that the reverse to preservation theorem does not hold. That is, if <code class="language-plaintext highlighter-rouge">t --&gt; t'</code> and <code class="language-plaintext highlighter-rouge">t' \in T</code>, we can not make sure <code class="language-plaintext highlighter-rouge">t \in T</code>.
I exploit the fact that reduction doesn’t type check.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(* t *) exists &lt;{ (\x: Bool -&gt; Bool, x) true }&gt;.
(* t'*) exists &lt;{ true }&gt;.
(* T *) exists &lt;{ Bool }&gt;.
</code></pre></div></div>
<p>It’s a little bit cheating, I admit. But I can’t find a better one.</p>
<h3 id="type-soundness">Type Soundness</h3>

<p>Put progress and preservation together, we can show that a well-typed term can <em>never</em> reach a stuck state.</p>

<p>Exercise: 2 stars, standard, optional (type_soundness)
Type soundness can be proved by induction on Hmulti (<code class="language-plaintext highlighter-rouge">t --&gt;* t'</code>).</p>

<h3 id="uniqueness-of-types">Uniqueness of Types</h3>

<p>Another nice property of the STLC is that types are unique: a given term (in a given context) has at most one type.</p>

<p>Exercise: 3 stars, standard (unique_types)
This exercise can be solved by induction on term <code class="language-plaintext highlighter-rouge">e</code>. The whole proof heavily use inversion to do case analysis.</p>

<h2 id="extension-to-stlc">Extension to STLC</h2>

<p>One might argue that the current STLC is still too simple and cannot match a real modern programming language. Well, there are a lot of extensions to STLC in the textbook to show the possibility of the language.</p>

<ul>
  <li>Numbers.</li>
  <li>Let bindings, which adds the let expression like those in Haskell.</li>
  <li>Pairs, which are popular in many languages. For example, I can have a pair of <code class="language-plaintext highlighter-rouge">(1, false)</code> of type <code class="language-plaintext highlighter-rouge">(Nat, Bool)</code></li>
  <li>Unit. A unit type is a type that only has one value. It can be quite helpful to express things like <code class="language-plaintext highlighter-rouge">null</code>, <code class="language-plaintext highlighter-rouge">nullptr</code></li>
  <li>Sums. A sum is like the <code class="language-plaintext highlighter-rouge">Either</code> monads In Haskell.</li>
  <li>Lists.</li>
  <li>Recursion (Recursive Abstraction)</li>
  <li>Records. Like dictionary in python.</li>
</ul>

<p>The exercises in this chapter is to formalize these features, including the substitution, reduction and typing. I would say it is quite straightforward to follow the informal definition given by the author, and satisfying to see how it works.</p>

  </div><a class="u-url" href="/software-foundations/2024/07/18/Simple-Typed-Lambda-Calculus.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    
    <div class="footer-col-wrapper">
      <div class="footer-col">
        <h2 class="footer-heading">Chew&#39;s Everyday Blog</h2>By wisdom a house is built, and through understanding it is established.</div>
      <div class="footer-col">
        <ul class="contact-list">
          <li class="p-name">Author: Chew Y. Feng</li><li>
              <span>
                Mail: 
              </span>
            <a class="u-email" href="mailto:chew.y.feng@outlook.com">chew.y.feng@outlook.com</a></li><div>
              Find me:<ul class="social-media-list"><li><a href="https://github.com/excitedspider"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">excitedspider</span></a></li><li><a href="https://www.linkedin.com/in/qiuyi-feng-348968287"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">qiuyi-feng-348968287</span></a></li></ul>
</div>
            <div class="footer-col-rss">
              <p class="rss-subscribe">subscribe <a href="/feed.xml">via RSS</a></p>
            </div>
        </ul>
      </div>

    </div>

  </div>

</footer>
</body>

</html>
