<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>FP in Haskell - Practical Concerns | Chew’s Everyday Blog</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="FP in Haskell - Practical Concerns" />
<meta name="author" content="Chew Y. Feng" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Partial Functions, Folds and as-pattern" />
<meta property="og:description" content="Partial Functions, Folds and as-pattern" />
<link rel="canonical" href="/software-foundations/2024/01/17/Haskell-FP.html" />
<meta property="og:url" content="/software-foundations/2024/01/17/Haskell-FP.html" />
<meta property="og:site_name" content="Chew’s Everyday Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-01-17T00:00:00+11:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="FP in Haskell - Practical Concerns" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Chew Y. Feng"},"dateModified":"2024-01-19T22:18:29+11:00","datePublished":"2024-01-17T00:00:00+11:00","description":"Partial Functions, Folds and as-pattern","headline":"FP in Haskell - Practical Concerns","mainEntityOfPage":{"@type":"WebPage","@id":"/software-foundations/2024/01/17/Haskell-FP.html"},"url":"/software-foundations/2024/01/17/Haskell-FP.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Chew&apos;s Everyday Blog" /><script>
    // for MathJax inline
    window.MathJax = {
      tex: {
        inlineMath: [['_', '_'], ['$', '$'], ['\\(', '\\)']]
      }
    };
  </script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/css-doodle/0.37.4/css-doodle.min.js"></script>
  <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Teko">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-4TZZDRT6JY"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-4TZZDRT6JY');
  </script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Chew&#39;s Everyday Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="page-content-background">
        <css-doodle click-to-update>
          <style>
            @grid: 1 / 100vw 100vh / #0a0c27;
            background-size: 200px 200px;
            background-image: @doodle(
              @grid: 6 / 100%;
              @size: 4px;
              font-size: 4px;
              color: hsl(@r240, 30%, 50%);
              box-shadow: @m3x5(
                calc(4em - @nx * 1em) calc(@ny * 1em)
                  @p(@m3(currentColor), @m2(transparent)),
                calc(2em + @nx * 1em) calc(@ny * 1em)
                  @lp
              );
            );
          </style>
        </css-doodle>
      </div>
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">FP in Haskell - Practical Concerns</h1>
    <p class="post-meta"><span class="tags">
        
          <span>Haskell</span>
        
          <span>Functional Programming</span>
        
      </span><time class="dt-published" datetime="2024-01-17T00:00:00+11:00" itemprop="datePublished">
        Posted At: Jan 17, 2024
      </time><time>
        Modified At: Jan 19, 2024
      </time><span class="dt-tags">
        Category:
        
          <span>Software-Foundations</span>
        
      </span></p>
  </header>


  <div class="post-content e-content" itemprop="articleBody">
    <p>Shout out to <a href="https://book.realworldhaskell.org/">Real World Haskell</a>.</p>
<h2 id="partial-and-total-functions">Partial and Total functions</h2>
<p>Following mathematics jargons, functions that works on all possible inputs are <em>total functions</em>. Correspondingly, functions that are not total are <em>partial</em> functions.</p>

<p>For example, function <code class="language-plaintext highlighter-rouge">head</code> is partial-defined, because it refuses to work on empty array.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ghci&gt; head []
*** Exception: Prelude.head: empty list
</code></pre></div></div>

<p>Haskell makes no difference treating partial and total functions. For example, it’s easy to reproduce function <code class="language-plaintext highlighter-rouge">head</code>. Haskell happily accept the definition in the beginning, but only cries on invalid input when running.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ghci&gt; let myHead (x:xs) = x
ghci&gt; myHead "hello"
'h'
ghci&gt; myHead []
*** Exception: &lt;interactive&gt;:7:5-21: Non-exhaustive patterns in function myHead
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Non-exhaustive patterns</code> error is a common mistakes programmers would do.</p>

<p>Some functional programing languages do require functions to be total.  For example, Coq guarantees that functions are total and decidable. So why Haskell doesn’t force it? My explanation is that it takes more efforts to make a total function, and verify an alleged total function is indeed total is not trivial. So as a general purpose programming language, it is understandable for Haskell to choose this relatively “unsafe” approach.</p>

<p>It requires some efforts to find out if the functions you are using are total and it’s arguably some controversy that prelude includes partial functions.</p>

<p>Some programmers would like to add <code class="language-plaintext highlighter-rouge">unsafe</code> prefix to partial functions they make. A more functional approach is using <code class="language-plaintext highlighter-rouge">Maybe</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">safeHead</span><span class="o">::</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="n">safeHead</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Just</span> <span class="n">x</span>
<span class="n">safeHead</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<p>Thanks to pattern matching, adding a “otherwise” pattern is so easy that wrap a partial function to a total function with <code class="language-plaintext highlighter-rouge">Maybe</code> is straightforward.</p>

<h2 id="folding-things">Folding Things</h2>
<p>Folds are the most useful and common functions in Haskell. But it takes some time to think about which variant of folds do you want.</p>

<p>Usually the choice is between <code class="language-plaintext highlighter-rouge">foldr</code> and <code class="language-plaintext highlighter-rouge">foldl'</code>.</p>

<p><code class="language-plaintext highlighter-rouge">foldr</code> should be the most common one to use. Think it not “folding from the right”, but “folding with right associativity”. Following example shows the idea:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foldr</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">3</span><span class="o">:</span><span class="kt">[]</span><span class="p">)</span>
<span class="c1">--          == 1 +           foldr (+) 0 (2:3:[])</span>
<span class="c1">--          == 1 + (2 +      foldr (+) 0 (3:[])</span>
<span class="c1">--          == 1 + (2 + (3 + foldr (+) 0 []))</span>
<span class="c1">--          == 1 + (2 + (3 + 0))</span>
</code></pre></div></div>

<p>What benefits can right associativity brings?</p>
<ol>
  <li>Build a new list with the same order
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">ghci</span><span class="o">&gt;</span> <span class="n">mapMult</span> <span class="o">=</span> <span class="n">foldr</span> <span class="n">step</span> <span class="kt">[]</span> <span class="kr">where</span> <span class="n">step</span> <span class="n">x</span> <span class="n">acc</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span><span class="n">acc</span>
 <span class="n">ghci</span><span class="o">&gt;</span> <span class="n">mapMult</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
  <li>Handle infinite list
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">3</span> <span class="p">(</span><span class="n">mapMult</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">..</span><span class="p">])</span>
 <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>In fact, there is another interpretation of <code class="language-plaintext highlighter-rouge">foldr</code>: It acts as a <a href="https://en.wikipedia.org/wiki/Finite-state_transducer">transducer</a> - It transforms or filter the input in the same order.</p>

<p>On the other hand, <code class="language-plaintext highlighter-rouge">foldl'</code> is more efficient in some ways. But lets talk about why <code class="language-plaintext highlighter-rouge">foldl</code> is not a good choice for most situations.</p>

<blockquote>
  <p>Due to <code class="language-plaintext highlighter-rouge">foldl</code>’s thunking behavior, it is wise to avoid this function in real programs, even if it doesn’t fail outright. Instead, import <code class="language-plaintext highlighter-rouge">Data.List</code> and use <code class="language-plaintext highlighter-rouge">foldl'</code></p>
</blockquote>

<p>In Haskell, expressions are evaluated lazily. <code class="language-plaintext highlighter-rouge">foldl</code> creates huge thunk.  Instead, <code class="language-plaintext highlighter-rouge">foldl'</code> is a good choice because it evaluate strictly at every step. Although <code class="language-plaintext highlighter-rouge">foldr</code> also  evaluated lazily, but it is more efficient with the construction of thunks. And if the operator or function it takes the second argument lazily, <code class="language-plaintext highlighter-rouge">foldr</code> can still be efficient. For example, the operator <code class="language-plaintext highlighter-rouge">:</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  foldr (:) [] [1, 2, 3, 4]
-- = 1 : ⟨foldr (:) [] [2, 3, 4]⟩
</code></pre></div></div>

<p>In conclusion, if we want to choose a “transducer” which produce the result in the same order, consider <code class="language-plaintext highlighter-rouge">foldr</code>. If we want to “produce an answer from a list”, then use <code class="language-plaintext highlighter-rouge">foldl'</code>. Never do <code class="language-plaintext highlighter-rouge">foldl</code>.</p>

<h2 id="as-pattern">As-Pattern</h2>

<p>The keyword <code class="language-plaintext highlighter-rouge">@</code> is called the “as pattern”</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">suffixes</span> <span class="n">xs</span><span class="o">@</span><span class="p">(</span><span class="kr">_</span><span class="o">:</span><span class="n">xs'</span><span class="p">)</span> <span class="o">=</span> <span class="n">xs</span><span class="o">:</span> <span class="n">suffixes</span> <span class="n">xs'</span>
<span class="n">suffixes</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">[]</span>

<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">suffixes</span> <span class="s">"hello"</span>
<span class="p">[</span><span class="s">"hello"</span><span class="p">,</span><span class="s">"ello"</span><span class="p">,</span><span class="s">"llo"</span><span class="p">,</span><span class="s">"lo"</span><span class="p">,</span><span class="s">"o"</span><span class="p">]</span>
</code></pre></div></div>

<p>Of course we can use conventional pattern match to achieve the same result:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">noAsPattern</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[[</span><span class="n">a</span><span class="p">]]</span>
<span class="n">noAsPattern</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">:</span> <span class="n">noAsPattern</span> <span class="n">xs</span>
<span class="n">noAsPattern</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">[]</span>                 
</code></pre></div></div>

<p>But compared to as-pattern, we actually did one redundant destruction, which causes extra space allocation. It may be cheap, but it isn’t free. So use the as-pattern wisely.</p>
<h2 id="references">References</h2>

<p>Foldr Foldl Foldl’. (n.d.). Retrieved from <a href="https://wiki.haskell.org/Foldr_Foldl_Foldl'">wiki.haskell.org</a>
Fixing foldl. (n.d.). Retrieved from https://www.well-typed.com/blog/90/
Real World Haskellby Bryan O’Sullivan, Don Stewart, and John Goerzen. (n.d.). Retrieved from https://book.realworldhaskell.org/</p>

  </div><a class="u-url" href="/software-foundations/2024/01/17/Haskell-FP.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    
    <div class="footer-col-wrapper">
      <div class="footer-col">
        <h2 class="footer-heading">Chew&#39;s Everyday Blog</h2>By wisdom a house is built, and through understanding it is established.</div>
      <div class="footer-col">
        <ul class="contact-list">
          <li class="p-name">Author: Chew Y. Feng</li><li>
              <span>
                Mail: 
              </span>
            <a class="u-email" href="mailto:chew.y.feng@outlook.com">chew.y.feng@outlook.com</a></li><div>
              Find me:<ul class="social-media-list"><li><a href="https://github.com/excitedspider"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">excitedspider</span></a></li><li><a href="https://www.linkedin.com/in/qiuyi-feng-348968287"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">qiuyi-feng-348968287</span></a></li></ul>
</div>
            <div class="footer-col-rss">
              <p class="rss-subscribe">subscribe <a href="/feed.xml">via RSS</a></p>
            </div>
        </ul>
      </div>

    </div>

  </div>

</footer>
</body>

</html>
