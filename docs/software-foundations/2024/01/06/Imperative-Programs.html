<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Simple Imperative Program | Chew’s Everyday Blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Simple Imperative Program" />
<meta name="author" content="Chew Y. Feng" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Define, evaluate, reasoning about a toy imperative program." />
<meta property="og:description" content="Define, evaluate, reasoning about a toy imperative program." />
<link rel="canonical" href="/software-foundations/2024/01/06/Imperative-Programs.html" />
<meta property="og:url" content="/software-foundations/2024/01/06/Imperative-Programs.html" />
<meta property="og:site_name" content="Chew’s Everyday Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-01-06T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Simple Imperative Program" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Chew Y. Feng"},"dateModified":"2024-01-08T06:35:09+00:00","datePublished":"2024-01-06T00:00:00+00:00","description":"Define, evaluate, reasoning about a toy imperative program.","headline":"Simple Imperative Program","mainEntityOfPage":{"@type":"WebPage","@id":"/software-foundations/2024/01/06/Imperative-Programs.html"},"url":"/software-foundations/2024/01/06/Imperative-Programs.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Chew&apos;s Everyday Blog" /><script>
    // for MathJax inline
    window.MathJax = {
      tex: {
        inlineMath: [['_', '_'], ['$', '$'], ['\\(', '\\)']]
      }
    };
  </script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/css-doodle/0.37.4/css-doodle.min.js"></script>
  <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Teko">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-4TZZDRT6JY"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-4TZZDRT6JY');
  </script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Chew&#39;s Everyday Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="page-content-background">
        <css-doodle click-to-update>
          <style>
            @grid: 1 / 100vw 100vh / #0a0c27;
            background-size: 200px 200px;
            background-image: @doodle(
              @grid: 6 / 100%;
              @size: 4px;
              font-size: 4px;
              color: hsl(@r240, 30%, 50%);
              box-shadow: @m3x5(
                calc(4em - @nx * 1em) calc(@ny * 1em)
                  @p(@m3(currentColor), @m2(transparent)),
                calc(2em + @nx * 1em) calc(@ny * 1em)
                  @lp
              );
            );
          </style>
        </css-doodle>
      </div>
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Simple Imperative Program</h1>
    <p class="post-meta"><span class="tags">
        
          <span>Coq</span>
        
          <span>Programming Languages</span>
        
      </span><time class="dt-published" datetime="2024-01-06T00:00:00+00:00" itemprop="datePublished">
        Posted At: Jan 6, 2024
      </time><time>
        Modified At: Jan 8, 2024
      </time><span class="dt-tags">
        Category:
        
          <span>Software-Foundations</span>
        
      </span></p>
  </header>


  <div class="post-content e-content" itemprop="articleBody">
    <ul id="markdown-toc">
  <li><a href="#define-expressions" id="markdown-toc-define-expressions">Define Expressions</a></li>
  <li><a href="#evaluating-expressions" id="markdown-toc-evaluating-expressions">Evaluating Expressions</a>    <ul>
      <li><a href="#aside-basic-automated-proofs" id="markdown-toc-aside-basic-automated-proofs">Aside: Basic Automated Proofs</a></li>
      <li><a href="#optimization" id="markdown-toc-optimization">Optimization</a></li>
      <li><a href="#computational-vs-relational-definitions" id="markdown-toc-computational-vs-relational-definitions">Computational vs Relational Definitions</a></li>
    </ul>
  </li>
  <li><a href="#commands-definition" id="markdown-toc-commands-definition">Commands Definition</a></li>
  <li><a href="#evaluating-commands" id="markdown-toc-evaluating-commands">Evaluating Commands</a></li>
  <li><a href="#reasoning-about-programing-languages" id="markdown-toc-reasoning-about-programing-languages">Reasoning about Programing Languages</a></li>
  <li><a href="#a-step-indexed-evaluator" id="markdown-toc-a-step-indexed-evaluator">A Step-Indexed Evaluator</a></li>
  <li><a href="#extraction" id="markdown-toc-extraction">Extraction</a></li>
  <li><a href="#reference" id="markdown-toc-reference">Reference</a></li>
</ul>

<p>This post is a note based on Software Foundation series <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, covering topics:</p>
<ul>
  <li>Implementation of a simple imperative language in Coq</li>
  <li>Examples about how to use Coq to study other things</li>
  <li>Basic automated proofs
The original chapter in the Software Foundation series is extremely long (29 sheets of A4). So I’ll try hard to compact and summarize all important ideas (or at least I think important) in this post. It could be a good material to revive the knowledge in the future.</li>
</ul>

<p>Out target language is a small one while basic statements, variables, boolean and arithmetic expressions, which looks this this:</p>

<pre><code class="language-plain">Z := X;
   Y := 1;
   while Z ≠ 0 do
	 Y := Y × Z;
	 Z := Z - 1
   end
</code></pre>
<h2 id="define-expressions">Define Expressions</h2>

<blockquote>
  <p>[!Info] Caveat
We only focus on the <em>syntax</em> and <em>semantics</em> (evaluation) parts of the language. If you are looking for something related to lexing and parsing, there is another optional chapter for those: <a href="https://softwarefoundations.cis.upenn.edu/lf-current/ImpParser.html">LEXING AND PARSING IN COQ</a>.</p>
</blockquote>

<p>It is straightforward and explicit to define syntax in Coq using inductive defined data types, which almost resembles the Chomsky Normal Form <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>.</p>

<p>Expressions are the part of program that always evaluate to values. There are two types of expressions in our language: arithmetic expressions and boolean expressions.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">aexp</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">ANum</span><span class="w"> </span><span class="o">(</span><span class="no">n</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">APlus</span><span class="w"> </span><span class="o">(</span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">aexp</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">AMinus</span><span class="w"> </span><span class="o">(</span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">aexp</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">AMult</span><span class="w"> </span><span class="o">(</span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">aexp</span><span class="o">).</span><span class="w">
  
</span><span class="k">Inductive</span><span class="w"> </span><span class="no">bexp</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BTrue</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BFalse</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BEq</span><span class="w"> </span><span class="o">(</span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">aexp</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BNeq</span><span class="w"> </span><span class="o">(</span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">aexp</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BLe</span><span class="w"> </span><span class="o">(</span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">aexp</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BGt</span><span class="w"> </span><span class="o">(</span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">aexp</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BNot</span><span class="w"> </span><span class="o">(</span><span class="no">b</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bexp</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BAnd</span><span class="w"> </span><span class="o">(</span><span class="no">b1</span><span class="w"> </span><span class="no">b2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bexp</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>
<h2 id="evaluating-expressions">Evaluating Expressions</h2>

<p>There are two ways to evaluate in Coq: <strong>by functions</strong> or by <strong>relations</strong>.</p>

<p>For example, the calculation of boolean evaluation  is perfect to define in a function</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Fixpoint</span><span class="w"> </span><span class="no">beval</span><span class="w"> </span><span class="o">(</span><span class="no">b</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bexp</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BTrue</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BFalse</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">false</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BEq</span><span class="w"> </span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="o">(</span><span class="no">aeval</span><span class="w"> </span><span class="no">a1</span><span class="o">)</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="o">(</span><span class="no">aeval</span><span class="w"> </span><span class="no">a2</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BNeq</span><span class="w"> </span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">negb</span><span class="w"> </span><span class="o">((</span><span class="no">aeval</span><span class="w"> </span><span class="no">a1</span><span class="o">)</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="o">(</span><span class="no">aeval</span><span class="w"> </span><span class="no">a2</span><span class="o">))</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BLe</span><span class="w"> </span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="o">(</span><span class="no">aeval</span><span class="w"> </span><span class="no">a1</span><span class="o">)</span><span class="w"> </span><span class="o">&lt;=?</span><span class="w"> </span><span class="o">(</span><span class="no">aeval</span><span class="w"> </span><span class="no">a2</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BGt</span><span class="w"> </span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">negb</span><span class="w"> </span><span class="o">((</span><span class="no">aeval</span><span class="w"> </span><span class="no">a1</span><span class="o">)</span><span class="w"> </span><span class="o">&lt;=?</span><span class="w"> </span><span class="o">(</span><span class="no">aeval</span><span class="w"> </span><span class="no">a2</span><span class="o">))</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BNot</span><span class="w"> </span><span class="no">b1</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">negb</span><span class="w"> </span><span class="o">(</span><span class="no">beval</span><span class="w"> </span><span class="no">b1</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BAnd</span><span class="w"> </span><span class="no">b1</span><span class="w"> </span><span class="no">b2</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">andb</span><span class="w"> </span><span class="o">(</span><span class="no">beval</span><span class="w"> </span><span class="no">b1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">beval</span><span class="w"> </span><span class="no">b2</span><span class="o">)</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>On the other hand, as it might be bizarre at first glance, define evaluation as a relation between domain and range is also straightforward.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* Exercise: (bevalR) *)</span><span class="w">

</span><span class="no">Reserved</span><span class="w"> </span><span class="k">Notation</span><span class="w"> </span><span class="s2">"e '==&gt;b' b"</span><span class="w"> </span><span class="o">(</span><span class="kp">at</span><span class="w"> </span><span class="no">level</span><span class="w"> </span><span class="mi">90</span><span class="o">,</span><span class="w"> </span><span class="no">left</span><span class="w"> </span><span class="no">associativity</span><span class="o">).</span><span class="w">
</span><span class="k">Inductive</span><span class="w"> </span><span class="no">bevalR</span><span class="p">:</span><span class="w"> </span><span class="no">bexp</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">R_BTrue</span><span class="p">:</span><span class="w"> </span><span class="no">BTrue</span><span class="w"> </span><span class="o">==&gt;</span><span class="no">b</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">R_BFalse</span><span class="p">:</span><span class="w"> </span><span class="no">BFalse</span><span class="w"> </span><span class="o">==&gt;</span><span class="no">b</span><span class="w"> </span><span class="no">false</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">R_BEq</span><span class="w"> </span><span class="o">(</span><span class="no">n1</span><span class="w"> </span><span class="no">n2</span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="p">:</span><span class="w"> </span><span class="no">aexp</span><span class="o">)</span><span class="p">:</span><span class="w"> 
      </span><span class="no">a1</span><span class="w"> </span><span class="o">==&gt;</span><span class="w"> </span><span class="no">n1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> 
      </span><span class="no">a2</span><span class="w"> </span><span class="o">==&gt;</span><span class="w"> </span><span class="no">n2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> 
      </span><span class="o">(</span><span class="no">BEq</span><span class="w"> </span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="o">)</span><span class="w"> </span><span class="o">==&gt;</span><span class="no">b</span><span class="w"> </span><span class="no">n1</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">n2</span><span class="w"> 
  </span><span class="o">|</span><span class="w"> </span><span class="no">R_BNeg</span><span class="w"> </span><span class="o">(</span><span class="no">n1</span><span class="w"> </span><span class="no">n2</span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="p">:</span><span class="w"> </span><span class="no">aexp</span><span class="o">)</span><span class="p">:</span><span class="w">
      </span><span class="no">a1</span><span class="w"> </span><span class="o">==&gt;</span><span class="w"> </span><span class="no">n1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="no">a2</span><span class="w"> </span><span class="o">==&gt;</span><span class="w"> </span><span class="no">n2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="o">(</span><span class="no">BNeq</span><span class="w"> </span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="o">)</span><span class="w"> </span><span class="o">==&gt;</span><span class="no">b</span><span class="w"> </span><span class="no">negb</span><span class="w"> </span><span class="o">(</span><span class="no">n1</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">n2</span><span class="o">)</span><span class="w"> 
  </span><span class="o">|</span><span class="w"> </span><span class="no">R_BLe</span><span class="w"> </span><span class="o">(</span><span class="no">n1</span><span class="w"> </span><span class="no">n2</span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="p">:</span><span class="w"> </span><span class="no">aexp</span><span class="o">)</span><span class="p">:</span><span class="w">
      </span><span class="no">a1</span><span class="w"> </span><span class="o">==&gt;</span><span class="w"> </span><span class="no">n1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="no">a2</span><span class="w"> </span><span class="o">==&gt;</span><span class="w"> </span><span class="no">n2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="o">(</span><span class="no">BLe</span><span class="w"> </span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="o">)</span><span class="w"> </span><span class="o">==&gt;</span><span class="no">b</span><span class="w"> </span><span class="no">n1</span><span class="w"> </span><span class="o">&lt;=?</span><span class="w"> </span><span class="no">n2</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">R_BGt</span><span class="w"> </span><span class="o">(</span><span class="no">n1</span><span class="w"> </span><span class="no">n2</span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="p">:</span><span class="w"> </span><span class="no">aexp</span><span class="o">)</span><span class="p">:</span><span class="w">
      </span><span class="no">a1</span><span class="w"> </span><span class="o">==&gt;</span><span class="w"> </span><span class="no">n1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="no">a2</span><span class="w"> </span><span class="o">==&gt;</span><span class="w"> </span><span class="no">n2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="o">(</span><span class="no">BGt</span><span class="w"> </span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="o">)</span><span class="w"> </span><span class="o">==&gt;</span><span class="no">b</span><span class="w"> </span><span class="no">negb</span><span class="w"> </span><span class="o">(</span><span class="no">n1</span><span class="w"> </span><span class="o">&lt;=?</span><span class="w"> </span><span class="no">n2</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">R_BNot</span><span class="w"> </span><span class="o">(</span><span class="no">e</span><span class="p">:</span><span class="w"> </span><span class="no">bexp</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">b</span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="o">)</span><span class="p">:</span><span class="w">
      </span><span class="no">e</span><span class="w"> </span><span class="o">==&gt;</span><span class="no">b</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> 
      </span><span class="o">(</span><span class="no">BNot</span><span class="w"> </span><span class="no">e</span><span class="o">)</span><span class="w"> </span><span class="o">==&gt;</span><span class="no">b</span><span class="w"> </span><span class="o">(</span><span class="no">negb</span><span class="w"> </span><span class="no">b</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">R_BAnd</span><span class="w"> </span><span class="o">(</span><span class="no">e1</span><span class="w"> </span><span class="no">e2</span><span class="p">:</span><span class="w"> </span><span class="no">bexp</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">b1</span><span class="w"> </span><span class="no">b2</span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="o">)</span><span class="p">:</span><span class="w">
      </span><span class="no">e1</span><span class="w"> </span><span class="o">==&gt;</span><span class="no">b</span><span class="w"> </span><span class="no">b1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="no">e2</span><span class="w"> </span><span class="o">==&gt;</span><span class="no">b</span><span class="w"> </span><span class="no">b2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="o">(</span><span class="no">BAnd</span><span class="w"> </span><span class="no">e1</span><span class="w"> </span><span class="no">e2</span><span class="o">)</span><span class="w"> </span><span class="o">==&gt;</span><span class="no">b</span><span class="w"> </span><span class="no">andb</span><span class="w"> </span><span class="no">b1</span><span class="w"> </span><span class="no">b2</span><span class="w">
</span><span class="no">where</span><span class="w"> </span><span class="s2">"e '==&gt;b' b"</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">bevalR</span><span class="w"> </span><span class="no">e</span><span class="w"> </span><span class="no">b</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">type_scope</span><span class="w">
</span><span class="o">.</span><span class="w">
</span></code></pre></div></div>

<p>Think Curry–Howard Correspondence: a program is, in its nature, a proof<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>. It’s not formidable to acknowledge that both styles are identical. In fact, it is provable that these two definitions are equivalent.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* Exercise: (bevalR) *)</span><span class="w">

</span><span class="k">Lemma</span><span class="w"> </span><span class="no">beval_iff_bevalR</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">bv</span><span class="o">,</span><span class="w">
  </span><span class="no">b</span><span class="w"> </span><span class="o">==&gt;</span><span class="no">b</span><span class="w"> </span><span class="no">bv</span><span class="w"> </span><span class="o">&lt;-&gt;</span><span class="w"> </span><span class="no">beval</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">bv</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">split</span><span class="pi">.</span><span class="w">
  </span><span class="c">(* -&gt; *)</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w">
    </span><span class="kp">induction</span><span class="w"> </span><span class="no">H</span><span class="p">;</span><span class="w">
    </span><span class="c">(* trivial cases *)</span><span class="w">
    </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">simpl</span><span class="p">;</span><span class="w"> </span><span class="kp">subst</span><span class="p">;</span><span class="w"> </span><span class="ne">reflexivity</span><span class="o">)</span><span class="p">;</span><span class="w">
    </span><span class="c">(* cases be resolved by apply aeval_iff_aevalR *)</span><span class="w">
    </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">simpl</span><span class="p">;</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">aeval_iff_aevalR</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="o">,</span><span class="w"> </span><span class="no">H0</span><span class="p">;</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="o">,</span><span class="w"> </span><span class="no">H0</span><span class="p">;</span><span class="w"> </span><span class="ne">reflexivity</span><span class="o">).</span><span class="w">
  </span><span class="c">(* &lt;- *)</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">generalize</span><span class="w"> </span><span class="kp">dependent</span><span class="w"> </span><span class="no">bv</span><span class="pi">.</span><span class="w"> </span><span class="kp">induction</span><span class="w"> </span><span class="no">b</span><span class="p">;</span><span class="w">
    </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">intros</span><span class="p">;</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="no">H</span><span class="p">;</span><span class="w"> </span><span class="kp">simpl</span><span class="p">;</span><span class="w"> </span><span class="kp">constructor</span><span class="o">)</span><span class="p">;</span><span class="w">
    </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">apply</span><span class="w"> </span><span class="no">aeval_iff_aevalR</span><span class="p">;</span><span class="w"> </span><span class="ne">reflexivity</span><span class="o">).</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">IHb</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">IHb1</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">IHb2</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h3 id="aside-basic-automated-proofs">Aside: Basic Automated Proofs</h3>

<p>In the proof of lemma <code class="language-plaintext highlighter-rouge">beval_iff_bevalR</code> above, there are several <em>tacticals</em> involved, that is,  tactics that takes another tactic as arguments. Tacticals used in the post include:</p>
<ul>
  <li>Tactical <code class="language-plaintext highlighter-rouge">try T</code>: try to apply <code class="language-plaintext highlighter-rouge">T</code>. If fails, <code class="language-plaintext highlighter-rouge">try T</code> does nothing at all</li>
  <li>Tactical <code class="language-plaintext highlighter-rouge">T;T'</code> combines two tactic and applies  <code class="language-plaintext highlighter-rouge">T'</code> them on each subgoal generated by <code class="language-plaintext highlighter-rouge">T</code>.</li>
  <li>Tactical <code class="language-plaintext highlighter-rouge">repeat T</code>: repeatedly apply <code class="language-plaintext highlighter-rouge">T</code> until fails or no change in the goal or context.</li>
</ul>

<p>Sometimes it is handy to define new tactic using <code class="language-plaintext highlighter-rouge">Ltac</code>.</p>

<p>Other powerful and general tactics are:</p>
<ul>
  <li>Tactic <code class="language-plaintext highlighter-rouge">Lia</code> solves linear integer arithmetic</li>
  <li>Tactic <code class="language-plaintext highlighter-rouge">subst</code> substitutes all assumptions of the form <code class="language-plaintext highlighter-rouge">x=e</code> or <code class="language-plaintext highlighter-rouge">e=x</code> to reduce the number of variables</li>
  <li>Tactic <code class="language-plaintext highlighter-rouge">assumption</code> tries to find an exact hypothesis to solve the goal</li>
  <li>Tactic <code class="language-plaintext highlighter-rouge">contradiction</code> tries to find a contradiction hypothesis to solve the goal</li>
  <li>Tactic <code class="language-plaintext highlighter-rouge">constructor</code> tries to find a constructor to solve the goal</li>
</ul>

<h3 id="optimization">Optimization</h3>

<p>If we define a function to optimize the evaluation of an expression, we can use Coq to examine that the optimization we perform will not change the result. A silly example is: changing every occurrence of <code class="language-plaintext highlighter-rouge">0+e</code> to <code class="language-plaintext highlighter-rouge">e</code>.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Fixpoint</span><span class="w"> </span><span class="no">optimize_0plus</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="p">:</span><span class="no">aexp</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">aexp</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">ANum</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">ANum</span><span class="w"> </span><span class="no">n</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">APlus</span><span class="w"> </span><span class="o">(</span><span class="no">ANum</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w"> </span><span class="no">e2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">optimize_0plus</span><span class="w"> </span><span class="no">e2</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">APlus</span><span class="w">  </span><span class="no">e1</span><span class="w"> </span><span class="no">e2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">APlus</span><span class="w">  </span><span class="o">(</span><span class="no">optimize_0plus</span><span class="w"> </span><span class="no">e1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">optimize_0plus</span><span class="w"> </span><span class="no">e2</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">AMinus</span><span class="w"> </span><span class="no">e1</span><span class="w"> </span><span class="no">e2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">AMinus</span><span class="w"> </span><span class="o">(</span><span class="no">optimize_0plus</span><span class="w"> </span><span class="no">e1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">optimize_0plus</span><span class="w"> </span><span class="no">e2</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">AMult</span><span class="w">  </span><span class="no">e1</span><span class="w"> </span><span class="no">e2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">AMult</span><span class="w">  </span><span class="o">(</span><span class="no">optimize_0plus</span><span class="w"> </span><span class="no">e1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">optimize_0plus</span><span class="w"> </span><span class="no">e2</span><span class="o">)</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">

</span><span class="c">(* Exercise (optimize_0plus_b_sound) *)</span><span class="w">

</span><span class="k">Fixpoint</span><span class="w"> </span><span class="no">optimize_0plus_b</span><span class="w"> </span><span class="o">(</span><span class="no">b</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bexp</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bexp</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BTrue</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">BTrue</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BFalse</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">BFalse</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BEq</span><span class="w"> </span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">BEq</span><span class="w"> </span><span class="o">(</span><span class="no">optimize_0plus</span><span class="w"> </span><span class="no">a1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">optimize_0plus</span><span class="w"> </span><span class="no">a2</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BNeq</span><span class="w"> </span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">BNeq</span><span class="w"> </span><span class="o">(</span><span class="no">optimize_0plus</span><span class="w"> </span><span class="no">a1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">optimize_0plus</span><span class="w"> </span><span class="no">a2</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BLe</span><span class="w"> </span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">BLe</span><span class="w"> </span><span class="o">(</span><span class="no">optimize_0plus</span><span class="w"> </span><span class="no">a1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">optimize_0plus</span><span class="w"> </span><span class="no">a2</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BGt</span><span class="w"> </span><span class="no">a1</span><span class="w"> </span><span class="no">a2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">BGt</span><span class="w"> </span><span class="o">(</span><span class="no">optimize_0plus</span><span class="w"> </span><span class="no">a1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">optimize_0plus</span><span class="w"> </span><span class="no">a2</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BNot</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">BNot</span><span class="w"> </span><span class="no">b</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">BAnd</span><span class="w"> </span><span class="no">b1</span><span class="w"> </span><span class="no">b2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">BAnd</span><span class="w"> </span><span class="no">b1</span><span class="w"> </span><span class="no">b2</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>Proof of the optimization does not affect the results of evaluations (for boolean expression)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* Exercise (optimize_0plus_b_sound) *)</span><span class="w">

</span><span class="k">Theorem</span><span class="w"> </span><span class="no">optimize_0plus_b_sound</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">b</span><span class="o">,</span><span class="w">
  </span><span class="no">beval</span><span class="w"> </span><span class="o">(</span><span class="no">optimize_0plus_b</span><span class="w"> </span><span class="no">b</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">beval</span><span class="w"> </span><span class="no">b</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">b</span><span class="pi">.</span><span class="w">
  </span><span class="kp">induction</span><span class="w"> </span><span class="no">b</span><span class="p">;</span><span class="w">
  </span><span class="c">(* branches that does not involve optimization are trivial*)</span><span class="w">
  </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">simpl</span><span class="p">;</span><span class="w"> </span><span class="ne">reflexivity</span><span class="o">)</span><span class="p">;</span><span class="w">
  </span><span class="c">(* branches that involve optimization are proved by repeatly unfold and apply [optimize_0plus_sound] *)</span><span class="w">
  </span><span class="kp">repeat</span><span class="w"> </span><span class="o">(</span><span class="kp">simpl</span><span class="p">;</span><span class="w"> </span><span class="o">(</span><span class="kp">rewrite</span><span class="w"> </span><span class="no">optimize_0plus_sound</span><span class="p">;</span><span class="w"> </span><span class="kp">try</span><span class="w"> </span><span class="ne">reflexivity</span><span class="o">)).</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
  
</span></code></pre></div></div>

<h3 id="computational-vs-relational-definitions">Computational vs Relational Definitions</h3>
<p>In most situations, the choice of computational definitions or relational definitions are just a matter of taste. But sometimes using one over another gives more mileage.</p>

<p>Computational definitions are <em>total</em>, which means they are fully defined on all the possible inputs<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">4</a></sup>. Thanks to the strict rules of Coq, evaluation by computational definitions is as simple as run a function. It is bound to halt, after all.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Example</span><span class="w"> </span><span class="no">test_optimize_0plus</span><span class="p">:</span><span class="w">
  </span><span class="no">optimize_0plus</span><span class="w"> </span><span class="o">(</span><span class="no">APlus</span><span class="w"> </span><span class="o">(</span><span class="no">ANum</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w">
                        </span><span class="o">(</span><span class="no">APlus</span><span class="w"> </span><span class="o">(</span><span class="no">ANum</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w">
                               </span><span class="o">(</span><span class="no">APlus</span><span class="w"> </span><span class="o">(</span><span class="no">ANum</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">ANum</span><span class="w"> </span><span class="mi">1</span><span class="o">))))</span><span class="w">
  </span><span class="o">=</span><span class="w"> </span><span class="no">APlus</span><span class="w"> </span><span class="o">(</span><span class="no">ANum</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">ANum</span><span class="w"> </span><span class="mi">1</span><span class="o">).</span><span class="w">

</span><span class="c">(* Coq knows how to calculate this expression *)</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>On the other hand, there are some situations that relational definitions work better. To be more specific, partial functions and nondeterminism are allowed in relational definitions. For example, it is easy to define the evaluation of loops in relation, we’ll see more about this in the next section</p>

<h2 id="commands-definition">Commands Definition</h2>

<p>In the world of imperative languages, <em>commands</em> or <em>statements</em> are the part that express some actions like assignments, loops and conditions. We shall find that relational definitions are more powerful to express commands than computations.</p>

<p>Informally, the commands in this language are (in BNF):</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">c</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">skip</span><span class="w">
	</span><span class="o">|</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">a</span><span class="w">
	</span><span class="o">|</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="no">c</span><span class="w">
	</span><span class="o">|</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kr">end</span><span class="w">
	</span><span class="o">|</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kr">end</span><span class="w">
</span></code></pre></div></div>

<p>which corresponds to following definition.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">com</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">CSkip</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">CAsgn</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">aexp</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">CSeq</span><span class="w"> </span><span class="o">(</span><span class="no">c1</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">CIf</span><span class="w"> </span><span class="o">(</span><span class="no">b</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bexp</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">c1</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">CWhile</span><span class="w"> </span><span class="o">(</span><span class="no">b</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bexp</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">c</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>Note that there are some notations defined in the chapter of Software Foundation series, which makes the program more readable.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* assign *)</span><span class="w">
</span><span class="k">Definition</span><span class="w"> </span><span class="no">plus2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">}&gt;.</span><span class="w">

</span><span class="c">(* loop *)</span><span class="w">
</span><span class="k">Definition</span><span class="w"> </span><span class="no">subtract_slowly</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">do</span><span class="w">
	    </span><span class="no">Z</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">Z</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">;</span><span class="w">
		</span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w">
     </span><span class="kr">end</span><span class="w"> </span><span class="o">}&gt;.</span><span class="w">
</span></code></pre></div></div>

<p>I choose to leave out the definitions of these notations as they are not the core of what we want to do. If you want to see the details of the notations, you can refer to the original chapter.<sup id="fnref:1:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<h2 id="evaluating-commands">Evaluating Commands</h2>

<p>First we need to introduce a concept of <em>program state</em>, or simply <em>state</em>. A state is designed to remember preceding evaluation. Typically, a state stores the values of variables <sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">5</a></sup>. For convenience, we use a total map (a key-value dictionary with a default value) to be a state.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">state</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">total_map</span><span class="w"> </span><span class="no">nat</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>Remember that Coq only accept functions that are guaranteed to terminate. This rule is employed to ensure functions in Coq are indeed total. If you try to evaluating commands as functions, the function would be “takes the current state and a command and then produces a new state”. there is one huge obstacle in the way: how to define loops?</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Fixpoint</span><span class="w"> </span><span class="no">ceval_fun_no_while</span><span class="w"> </span><span class="o">(</span><span class="no">st</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">c</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kp">with</span><span class="w">
    </span><span class="c">(* ... *)</span><span class="w">
    </span><span class="c">(* omit other easy cases *)</span><span class="w">
    
    </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
        </span><span class="no">st</span><span class="w">  </span><span class="c">(* bogus *)</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>Then what you might do is trying to decide if the loop would eventually terminate. It is , again, a horrible attempt because it is actually the halting problem, which is proved to be undecidable<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup>.</p>

<p>On the other hand, define loops in term of relations is easy. Informally,</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">beval</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">false</span><span class="w">
</span><span class="o">-----------------------------(</span><span class="no">E_WhileFalse</span><span class="o">)</span><span class="w">
</span><span class="no">st</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st</span><span class="w">

</span><span class="no">beval</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="no">st</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st'</span><span class="w">
</span><span class="no">st'</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st''</span><span class="w">
</span><span class="o">--------------------------------(</span><span class="no">E_WhileTrue</span><span class="o">)</span><span class="w">
</span><span class="no">st</span><span class="w">  </span><span class="o">=[</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st''</span><span class="w">
</span></code></pre></div></div>

<p>Formally,</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">ceval</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">state</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">state</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
 </span><span class="c">(* Omit other easy branches *)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">E_WhileFalse</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">c</span><span class="o">,</span><span class="w">
      </span><span class="no">beval</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">false</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="no">st</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">E_WhileTrue</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="no">st''</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">c</span><span class="o">,</span><span class="w">
      </span><span class="no">beval</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="no">st</span><span class="w">  </span><span class="o">=[</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="no">st'</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st''</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="no">st</span><span class="w">  </span><span class="o">=[</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st''</span><span class="w">
</span><span class="no">where</span><span class="w"> </span><span class="s2">"st =[ c ]=&gt; st'"</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">ceval</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">st'</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>The cost of defining evaluation as relations is that we need to construct a proof to evaluate a program.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(** Exercise (ceval_example2) *)</span><span class="w">
</span><span class="k">Example</span><span class="w"> </span><span class="no">ceval_example2</span><span class="p">:</span><span class="w">
  </span><span class="no">empty_st</span><span class="w"> </span><span class="o">=[</span><span class="w">
    </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
    </span><span class="no">Y</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
    </span><span class="no">Z</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w">
  </span><span class="o">]=&gt;</span><span class="w"> </span><span class="o">(</span><span class="no">Z</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="no">Y</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="mi">0</span><span class="o">).</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_Seq</span><span class="w"> </span><span class="kp">with</span><span class="w"> </span><span class="o">(</span><span class="no">X</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="mi">0</span><span class="o">).</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_Asgn</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_Seq</span><span class="w"> </span><span class="kp">with</span><span class="w"> </span><span class="o">(</span><span class="no">Y</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="p">;</span><span class="w">
    </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_Asgn</span><span class="p">;</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>The nature behind the problem why we can define loops as relations but not as functions is that we can’t give a total function of loop: what if the input causes an infinite loop?</p>

<p>Up to this time, we have fully defined our tiny little programming languages.</p>
<h2 id="reasoning-about-programing-languages">Reasoning about Programing Languages</h2>

<p>We can reason about some properties of the programming languages we just defined.</p>

<p>First, we show that a infinite loops indeed never stops.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(** Exercise (loop_never_stops) *)</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">loop</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">skip</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">}&gt;.</span><span class="w">

</span><span class="k">Theorem</span><span class="w"> </span><span class="no">loop_never_stops</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">st'</span><span class="o">,</span><span class="w">
  </span><span class="o">~(</span><span class="no">st</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">loop</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st'</span><span class="o">).</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="no">contra</span><span class="pi">.</span><span class="w"> </span><span class="kp">unfold</span><span class="w"> </span><span class="no">loop</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">contra</span><span class="pi">.</span><span class="w">
  </span><span class="no">remember</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">skip</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="no">loopdef</span><span class="w">
           </span><span class="no">eqn</span><span class="p">:</span><span class="no">Heqloopdef</span><span class="pi">.</span><span class="w">
  </span><span class="kp">induction</span><span class="w"> </span><span class="no">contra</span><span class="p">;</span><span class="w"> </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="no">discriminate</span><span class="o">).</span><span class="w">
  </span><span class="c">(* while false do skip  = loopdef *)</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">Heqloopdef</span><span class="pi">.</span><span class="w">
    </span><span class="kp">subst</span><span class="pi">.</span><span class="w"> </span><span class="no">discriminate</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w">
  </span><span class="c">(* while false do something not skip = loopdef *)</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">Heqloopdef</span><span class="pi">.</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">IHcontra2</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w"> 
</span></code></pre></div></div>

<p>We can also show that if a program does not contain <code class="language-plaintext highlighter-rouge">while</code>, it indeed terminates. We give both function and relational definition of the predicate - “no <code class="language-plaintext highlighter-rouge">while</code> in the program” and establish their equivalence.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(** Exercise (no_whiles_eqv) **)</span><span class="w">

</span><span class="k">Inductive</span><span class="w"> </span><span class="no">no_whilesR</span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">NW_Skip</span><span class="p">:</span><span class="w"> </span><span class="no">no_whilesR</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">skip</span><span class="w"> </span><span class="o">}&gt;</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">NW_Asgn</span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">a</span><span class="o">,</span><span class="w"> </span><span class="no">no_whilesR</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">a</span><span class="o">}&gt;</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">NW_Seq</span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="no">c2</span><span class="o">,</span><span class="w"> 
      </span><span class="no">no_whilesR</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> 
      </span><span class="no">no_whilesR</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> 
      </span><span class="no">no_whilesR</span><span class="w"> </span><span class="o">&lt;{</span><span class="no">c1</span><span class="p">;</span><span class="w"> </span><span class="no">c2</span><span class="o">}&gt;</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">NW_IF</span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="no">c2</span><span class="o">,</span><span class="w">  
      </span><span class="no">no_whilesR</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> 
      </span><span class="no">no_whilesR</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> 
      </span><span class="no">no_whilesR</span><span class="w"> </span><span class="o">&lt;{</span><span class="kr">if</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="kr">end</span><span class="o">}&gt;</span><span class="w">
  </span><span class="o">.</span><span class="w">

</span><span class="k">Fixpoint</span><span class="w"> </span><span class="no">no_whiles</span><span class="w"> </span><span class="o">(</span><span class="no">c</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">skip</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
      </span><span class="no">true</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
      </span><span class="no">true</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
      </span><span class="no">andb</span><span class="w"> </span><span class="o">(</span><span class="no">no_whiles</span><span class="w"> </span><span class="no">c1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">no_whiles</span><span class="w"> </span><span class="no">c2</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">ct</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="no">cf</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
      </span><span class="no">andb</span><span class="w"> </span><span class="o">(</span><span class="no">no_whiles</span><span class="w"> </span><span class="no">ct</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">no_whiles</span><span class="w"> </span><span class="no">cf</span><span class="o">)</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">}&gt;</span><span class="w">  </span><span class="o">=&gt;</span><span class="w">
      </span><span class="no">false</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">

</span><span class="k">Theorem</span><span class="w"> </span><span class="no">no_whiles_eqv</span><span class="p">:</span><span class="w">
  </span><span class="kr">forall</span><span class="w"> </span><span class="no">c</span><span class="o">,</span><span class="w"> </span><span class="no">no_whiles</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="o">&lt;-&gt;</span><span class="w"> </span><span class="no">no_whilesR</span><span class="w"> </span><span class="no">c</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">split</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">intros</span><span class="pi">.</span><span class="w"> </span><span class="kp">induction</span><span class="w"> </span><span class="no">c</span><span class="p">;</span><span class="w"> </span><span class="kp">try</span><span class="o">(</span><span class="kp">constructor</span><span class="o">)</span><span class="p">;</span><span class="w">
    </span><span class="kp">try</span><span class="o">(</span><span class="w">
      </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H</span><span class="p">;</span><span class="w">
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">andb_true_iff</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H1</span><span class="p">;</span><span class="w"> </span><span class="kp">destruct</span><span class="w"> </span><span class="no">H1</span><span class="p">;</span><span class="w"> 
      </span><span class="c">(* for c1 branch *)</span><span class="w">
      </span><span class="kp">try</span><span class="o">(</span><span class="kp">apply</span><span class="w"> </span><span class="no">IHc1</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H0</span><span class="p">;</span><span class="w"> </span><span class="ne">exact</span><span class="w"> </span><span class="no">H0</span><span class="o">)</span><span class="p">;</span><span class="w">
      </span><span class="c">(* for c12branch *)</span><span class="w">
      </span><span class="kp">try</span><span class="o">(</span><span class="kp">apply</span><span class="w"> </span><span class="no">IHc2</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H1</span><span class="p">;</span><span class="w"> </span><span class="ne">exact</span><span class="w"> </span><span class="no">H1</span><span class="o">)</span><span class="w">
    </span><span class="o">).</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">intros</span><span class="pi">.</span><span class="w"> </span><span class="kp">induction</span><span class="w"> </span><span class="no">c</span><span class="p">;</span><span class="w"> </span><span class="kp">try</span><span class="o">(</span><span class="kp">constructor</span><span class="o">)</span><span class="p">;</span><span class="w">
    </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">simpl</span><span class="p">;</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H</span><span class="p">;</span><span class="w"> </span><span class="kp">subst</span><span class="p">;</span><span class="w"> 
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">andb_true_intro</span><span class="p">;</span><span class="w"> </span><span class="kp">split</span><span class="p">;</span><span class="w">
      </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">apply</span><span class="w"> </span><span class="no">IHc1</span><span class="o">)</span><span class="p">;</span><span class="w"> </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">apply</span><span class="w"> </span><span class="no">IHc2</span><span class="o">)</span><span class="p">;</span><span class="w"> 
      </span><span class="no">trivial</span><span class="o">).</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>Then it’s easy to approach the theorem</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">no_whiles_terminating</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="no">st</span><span class="o">,</span><span class="w">
  </span><span class="no">no_whilesR</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kp">exists</span><span class="w"> </span><span class="no">st'</span><span class="o">,</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st'</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="pi">.</span><span class="w"> </span><span class="kp">induction</span><span class="w"> </span><span class="no">c</span><span class="pi">.</span><span class="w">
  </span><span class="o">+</span><span class="w"> </span><span class="c">(* skip *)</span><span class="w"> </span><span class="kp">exists</span><span class="w"> </span><span class="no">st</span><span class="pi">.</span><span class="w"> </span><span class="kp">constructor</span><span class="pi">.</span><span class="w">
  </span><span class="o">+</span><span class="w"> </span><span class="c">(* assign *)</span><span class="w"> </span><span class="kp">exists</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="o">(</span><span class="no">aeval</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">a</span><span class="o">)</span><span class="p">;</span><span class="w"> </span><span class="no">st</span><span class="o">).</span><span class="w"> </span><span class="kp">constructor</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
  
  </span><span class="c">(* The proof is not hard, albeit tedious.
	 You need to deal with all branches. *)</span><span class="w">
  </span><span class="c">(* Let's save the page*)</span><span class="w"> 
  </span><span class="no">Admitted</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h2 id="a-step-indexed-evaluator">A Step-Indexed Evaluator</h2>

<p>We can’t define a evaluation function in Coq that might fall in a indefinite loop, because Coq is not just a general purpose programming language, but it is, more importantly, a consistent logic. A simple makeshift is that we can add a number as a parameter that decreases after every step and terminates after its value hits 0.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Fixpoint</span><span class="w"> </span><span class="no">ceval_step2</span><span class="w"> </span><span class="o">(</span><span class="no">st</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">c</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">i</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">i</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">O</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">empty_st</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">S</span><span class="w"> </span><span class="no">i'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="c">(* decrease 1 on each step *)</span><span class="w">
    </span><span class="kr">match</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kp">with</span><span class="w">
      </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">skip</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
          </span><span class="no">st</span><span class="w">
      </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">a1</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
          </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="no">aeval</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">a1</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="no">st</span><span class="o">)</span><span class="w">
      </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
          </span><span class="kr">let</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">ceval_step2</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="no">i'</span><span class="w"> </span><span class="kr">in</span><span class="w">
          </span><span class="no">ceval_step2</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="no">i'</span><span class="w">
      </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
          </span><span class="kr">if</span><span class="w"> </span><span class="o">(</span><span class="no">beval</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">b</span><span class="o">)</span><span class="w">
            </span><span class="kr">then</span><span class="w"> </span><span class="no">ceval_step2</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="no">i'</span><span class="w">
            </span><span class="kr">else</span><span class="w"> </span><span class="no">ceval_step2</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="no">i'</span><span class="w">
      </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">b1</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
          </span><span class="kr">if</span><span class="w"> </span><span class="o">(</span><span class="no">beval</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">b1</span><span class="o">)</span><span class="w">
          </span><span class="kr">then</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">ceval_step2</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="no">i'</span><span class="w"> </span><span class="kr">in</span><span class="w">
               </span><span class="no">ceval_step2</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="no">i'</span><span class="w">
          </span><span class="kr">else</span><span class="w"> </span><span class="no">st</span><span class="w">
    </span><span class="kr">end</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>Furthermore, we can use <code class="language-plaintext highlighter-rouge">option</code>to suggests whether the program halts after a success evaluation or reaching the step limitation.</p>

<h2 id="extraction">Extraction</h2>

<p>Extraction is to generate an efficient program in other language, such as Haskell. It’s straightforward to do so.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Extraction</span><span class="w"> </span><span class="no">Language</span><span class="w"> </span><span class="no">Haskell</span><span class="pi">.</span><span class="w">
</span><span class="no">Extraction</span><span class="w"> </span><span class="s2">"imp1.hs"</span><span class="w"> </span><span class="no">ceval_step</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>A extracted program can be viewed as a <em>certified</em> interpreter. More controlled extraction can be found on the chapter <a href="https://softwarefoundations.cis.upenn.edu/lf-current/Extraction.html">EXTRACTING OCAML FROM COQ</a>.</p>

<h2 id="reference">Reference</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>https://softwarefoundations.cis.upenn.edu/lf-current/toc.html <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:1:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Chomsky normal form. (2023). Retrieved from https://en.wikipedia.org/wiki/Chomsky_normal_form <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p><a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence#Related_proofs-as-programs_correspondences">Curry–Howard correspondence.</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/Partial_function <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p><a href="https://en.wikipedia.org/wiki/State_(computer_science)">State (computer science)</a> <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/Halting_problem <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div><a class="u-url" href="/software-foundations/2024/01/06/Imperative-Programs.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    
    <div class="footer-col-wrapper">
      <div class="footer-col">
        <h2 class="footer-heading">Chew&#39;s Everyday Blog</h2>By wisdom a house is built, and through understanding it is established.</div>
      <div class="footer-col">
        <ul class="contact-list">
          <li class="p-name">Author: Chew Y. Feng</li><li>
              <span>
                Mail: 
              </span>
            <a class="u-email" href="mailto:chew.y.feng@outlook.com">chew.y.feng@outlook.com</a></li><div>
              Find me:<ul class="social-media-list"><li><a href="https://github.com/excitedspider"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">excitedspider</span></a></li><li><a href="https://www.linkedin.com/in/qiuyi-feng-348968287"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">qiuyi-feng-348968287</span></a></li></ul>
</div>
            <div class="footer-col-rss">
              <p class="rss-subscribe">subscribe <a href="/feed.xml">via RSS</a></p>
            </div>
        </ul>
      </div>

    </div>

  </div>

</footer>
</body>

</html>
