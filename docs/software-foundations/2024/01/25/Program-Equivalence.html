<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Program Equivalence | Chew’s Everyday Blog</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Program Equivalence" />
<meta name="author" content="Chew Y. Feng" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Formalize equivalence relations." />
<meta property="og:description" content="Formalize equivalence relations." />
<link rel="canonical" href="/software-foundations/2024/01/25/Program-Equivalence.html" />
<meta property="og:url" content="/software-foundations/2024/01/25/Program-Equivalence.html" />
<meta property="og:site_name" content="Chew’s Everyday Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-01-25T00:00:00+11:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Program Equivalence" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Chew Y. Feng"},"dateModified":"2024-01-25T18:36:38+11:00","datePublished":"2024-01-25T00:00:00+11:00","description":"Formalize equivalence relations.","headline":"Program Equivalence","mainEntityOfPage":{"@type":"WebPage","@id":"/software-foundations/2024/01/25/Program-Equivalence.html"},"url":"/software-foundations/2024/01/25/Program-Equivalence.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Chew&apos;s Everyday Blog" /><script>
    // for MathJax inline
    window.MathJax = {
      tex: {
        inlineMath: [['_', '_'], ['$', '$'], ['\\(', '\\)']]
      }
    };
  </script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/css-doodle/0.37.4/css-doodle.min.js"></script>
  <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Teko">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-4TZZDRT6JY"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-4TZZDRT6JY');
  </script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Chew&#39;s Everyday Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="page-content-background">
        <css-doodle click-to-update>
          <style>
            @grid: 1 / 100vw 100vh / #0a0c27;
            background-size: 200px 200px;
            background-image: @doodle(
              @grid: 6 / 100%;
              @size: 4px;
              font-size: 4px;
              color: hsl(@r240, 30%, 50%);
              box-shadow: @m3x5(
                calc(4em - @nx * 1em) calc(@ny * 1em)
                  @p(@m3(currentColor), @m2(transparent)),
                calc(2em + @nx * 1em) calc(@ny * 1em)
                  @lp
              );
            );
          </style>
        </css-doodle>
      </div>
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Program Equivalence</h1>
    <p class="post-meta"><span class="tags">
        
          <span>Coq</span>
        
          <span>PLT</span>
        
      </span><time class="dt-published" datetime="2024-01-25T00:00:00+11:00" itemprop="datePublished">
        Posted At: Jan 25, 2024
      </time><time>
        Modified At: Jan 25, 2024
      </time><span class="dt-tags">
        Category:
        
          <span>Software-Foundations</span>
        
      </span></p>
  </header>


  <div class="post-content e-content" itemprop="articleBody">
    <ul id="markdown-toc">
  <li><a href="#behavioral-equivalence" id="markdown-toc-behavioral-equivalence">Behavioral Equivalence</a>    <ul>
      <li><a href="#conditions" id="markdown-toc-conditions">Conditions</a></li>
      <li><a href="#loops" id="markdown-toc-loops">Loops</a></li>
      <li><a href="#assignments" id="markdown-toc-assignments">Assignments</a></li>
    </ul>
  </li>
  <li><a href="#behavioral-equivalence-is-congruence" id="markdown-toc-behavioral-equivalence-is-congruence">Behavioral Equivalence is Congruence</a></li>
  <li><a href="#program-transformation" id="markdown-toc-program-transformation">Program Transformation</a></li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
</ul>

<p>This is a summary for the programming language foundation, chapter “Program Equivalence”  <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</p>

<h2 id="behavioral-equivalence">Behavioral Equivalence</h2>
<p>The concept of <strong><em>equivalence</em></strong> is crucial to understand what is a correct program. For an example, if  program $A$ is correct and $B$ is equivalent to $A$, then it is guaranteed that $B$ is correct.</p>

<p>Generally, an equivalence is a relation that is <em>reflective</em>, <em>symmetric</em> and <em>transitive</em>. So there are many ways to define equivalence. I could define an equivalence relation as two programs are identical as two strings after remove whitespaces. But this definition is not so interesting because it is not helpful for us to improve current programs. Instead, a more useful definition is <em>behavioral equivalence</em>.</p>

<p>Two programs are said to be <em>behaviorally equivalent</em> if they evaluate to the same result from every state.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">cequiv</span><span class="w"> </span><span class="o">(</span><span class="no">c1</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">st</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">),</span><span class="w">
    </span><span class="o">(</span><span class="no">st</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st'</span><span class="o">)</span><span class="w"> </span><span class="o">&lt;-&gt;</span><span class="w"> </span><span class="o">(</span><span class="no">st</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st'</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>(The language we are working on is called “imp”, which is a simple language that has the most basic and representative features as general purpose imperative languages. see <a href="https://softwarefoundations.cis.upenn.edu/lf-current/Imp.html">imp</a>  .)</p>

<p>We can prove that adding a <code class="language-plaintext highlighter-rouge">skip</code> results in an equivalent program.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">skip_right</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">c</span><span class="o">,</span><span class="w">
  </span><span class="no">cequiv</span><span class="w">
    </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="no">skip</span><span class="w"> </span><span class="o">}&gt;</span><span class="w">
    </span><span class="no">c</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="pi">.</span><span class="w"> 
  </span><span class="kp">split</span><span class="p">;</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H5</span><span class="pi">.</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_Seq</span><span class="w"> </span><span class="kp">with</span><span class="w"> </span><span class="o">(</span><span class="no">st'</span><span class="p">:</span><span class="o">=</span><span class="no">st'</span><span class="o">).</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_Skip</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">  
</span></code></pre></div></div>

<p>This definition implies an important concerns: if the program would terminate.</p>

<p>Programmers also often say that program c1 <em>refines</em> c2. It is an asymmetric variant of equivalence - c1 produces the same final states when it terminates - and perhaps c1 is better in readability or  efficiency. But it is not guaranteed that c1 terminates on some initial states if c2 does.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">refines</span><span class="w"> </span><span class="o">(</span><span class="no">c1</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">st</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">),</span><span class="w">
    </span><span class="o">(</span><span class="no">st</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st'</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">(</span><span class="no">st</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st'</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<h3 id="conditions">Conditions</h3>

<p>if the predicate is always false, it’s safe remove the truth branch.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">if_false</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="no">c2</span><span class="o">,</span><span class="w">
  </span><span class="no">bequiv</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">&lt;{</span><span class="no">false</span><span class="o">}&gt;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="no">cequiv</span><span class="w">
    </span><span class="o">&lt;{</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">}&gt;</span><span class="w">
    </span><span class="no">c2</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="pi">.</span><span class="w">
  </span><span class="kp">split</span><span class="p">;</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="no">H1</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H1</span><span class="p">;</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">unfold</span><span class="w"> </span><span class="no">bequiv</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">simpl</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w">
      </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H6</span><span class="pi">.</span><span class="w"> </span><span class="no">discriminate</span><span class="w"> </span><span class="no">H6</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_IfFalse</span><span class="p">;</span><span class="w"> </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="ne">assumption</span><span class="o">).</span><span class="w"> 
    </span><span class="kp">unfold</span><span class="w"> </span><span class="no">bequiv</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">simpl</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="no">trivial</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h3 id="loops">Loops</h3>

<p>In a loop, if a predicate is always true, the program would never terminate.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Lemma</span><span class="w"> </span><span class="no">while_true_nonterm</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">st'</span><span class="o">,</span><span class="w">
  </span><span class="no">bequiv</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">&lt;{</span><span class="no">true</span><span class="o">}&gt;</span><span class="w"> </span><span class="p">→</span><span class="w">
  </span><span class="o">~(</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>(This is not halting problem if you are thinking about that because it doesn’t decide every input.)</p>

<p>Thus, two programs are equivalent if the are both infinite loops, regardless their body.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">while_true</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">c</span><span class="o">,</span><span class="w">
  </span><span class="no">bequiv</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">&lt;{</span><span class="no">true</span><span class="o">}&gt;</span><span class="w">  </span><span class="o">-&gt;</span><span class="w">
  </span><span class="no">cequiv</span><span class="w">
    </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">}&gt;</span><span class="w">
    </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">skip</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">}&gt;.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="pi">.</span><span class="w"> 
  </span><span class="kp">split</span><span class="p">;</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="no">H0</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H0</span><span class="p">;</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">unfold</span><span class="w"> </span><span class="no">bequiv</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H5</span><span class="pi">.</span><span class="w"> </span><span class="no">discriminate</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="o">(</span><span class="no">while_true_nonterm</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">st'</span><span class="o">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="no">contradiction</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">exfalso</span><span class="pi">.</span><span class="w"> 
    </span><span class="kp">apply</span><span class="w"> </span><span class="o">(</span><span class="no">while_true_nonterm</span><span class="w"> </span><span class="o">&lt;{</span><span class="no">true</span><span class="o">}&gt;</span><span class="w"> </span><span class="o">&lt;{</span><span class="no">skip</span><span class="o">}&gt;</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">st'</span><span class="o">)</span><span class="p">;</span><span class="w"> 
    </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">unfold</span><span class="w"> </span><span class="no">bequiv</span><span class="o">)</span><span class="p">;</span><span class="w">
    </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">auto</span><span class="o">).</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>Conversely, if the predicate is always false, it’s safe to optimize the program by removing the surrounding while.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">if_false</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="no">c2</span><span class="o">,</span><span class="w">
  </span><span class="no">bequiv</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">&lt;{</span><span class="no">false</span><span class="o">}&gt;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="no">cequiv</span><span class="w">
    </span><span class="o">&lt;{</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">}&gt;</span><span class="w">
    </span><span class="no">c2</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="pi">.</span><span class="w">
  </span><span class="kp">split</span><span class="p">;</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="no">H1</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H1</span><span class="p">;</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">unfold</span><span class="w"> </span><span class="no">bequiv</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">simpl</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w">
      </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H6</span><span class="pi">.</span><span class="w"> </span><span class="no">discriminate</span><span class="w"> </span><span class="no">H6</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_IfFalse</span><span class="p">;</span><span class="w"> </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="ne">assumption</span><span class="o">).</span><span class="w"> 
    </span><span class="kp">unfold</span><span class="w"> </span><span class="no">bequiv</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">simpl</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="no">trivial</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h3 id="assignments">Assignments</h3>

<p>An assignment is redundant is assign to the same value that the variable currently holds.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">assign_aequiv</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">aexp</span><span class="o">),</span><span class="w">
  </span><span class="no">aequiv</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="no">cequiv</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">skip</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">}&gt;.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">unfold</span><span class="w"> </span><span class="no">aequiv</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="pi">.</span><span class="w"> </span><span class="kp">split</span><span class="p">;</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="no">H0</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H0</span><span class="p">;</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w">
    </span><span class="no">assert</span><span class="w"> </span><span class="o">(</span><span class="no">Hx</span><span class="p">:</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">X</span><span class="p">:</span><span class="o">=</span><span class="no">a</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="no">X</span><span class="p">;</span><span class="w"> </span><span class="no">st'</span><span class="o">)).</span><span class="w">
      </span><span class="o">{</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_Asgn</span><span class="pi">.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="o">}</span><span class="w">
    </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">t_update_same</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">Hx</span><span class="pi">.</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H0</span><span class="p">;</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w">
    </span><span class="no">assert</span><span class="w"> </span><span class="o">(</span><span class="no">Hxa</span><span class="p">:</span><span class="w"> </span><span class="o">(</span><span class="no">X</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="no">aeval</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">a</span><span class="p">;</span><span class="w"> </span><span class="no">st</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">X</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="no">aeval</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">X</span><span class="p">;</span><span class="w"> </span><span class="no">st</span><span class="o">)).</span><span class="w">
      </span><span class="o">{</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="o">}</span><span class="w">
    </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">Hxa</span><span class="pi">.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">t_update_same</span><span class="pi">.</span><span class="w"> </span><span class="kp">auto</span><span class="w"> </span><span class="no">using</span><span class="w"> </span><span class="o">(</span><span class="no">E_Skip</span><span class="o">).</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h2 id="behavioral-equivalence-is-congruence">Behavioral Equivalence is Congruence</h2>

<p>The behavior equivalence is also a <em>congruence</em>. Informally, it is a congruence in the sense that two subprograms implies the equivalence of the larger programs. For example:</p>

\[c_1 = c_1' \implies c2 = c2' \implies (c_1;c_2) = (c_1';c_2')\]

<p>This fact is important in the sense that it allows us to replace a small part of a large program by an equivalent subprogram without proving those parts that didn’t change.</p>

<p>Formalize the idea of congruence into Coq needs some work. The most basic one is the sequence commands.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">CSeq_congruence</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="no">c1'</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="no">c2'</span><span class="o">,</span><span class="w">
  </span><span class="no">cequiv</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="no">c1'</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">cequiv</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="no">c2'</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="no">cequiv</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">c1</span><span class="p">;</span><span class="no">c2</span><span class="w"> </span><span class="o">}&gt;</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">c1'</span><span class="p">;</span><span class="no">c2'</span><span class="w"> </span><span class="o">}&gt;.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
    </span><span class="kp">intros</span><span class="pi">.</span><span class="w"> </span><span class="kp">unfold</span><span class="w"> </span><span class="no">cequiv</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="o">*.</span><span class="w"> </span><span class="kp">split</span><span class="p">;</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="no">Hequiv</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">Hequiv</span><span class="p">;</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w">
      </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="o">*.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H0</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="o">*.</span><span class="w">
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_Seq</span><span class="w"> </span><span class="kp">with</span><span class="w"> </span><span class="o">(</span><span class="no">st'0</span><span class="o">)</span><span class="p">;</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">Hequiv</span><span class="p">;</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w">
      </span><span class="kp">rewrite</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="no">H</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="o">*.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="no">H0</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="o">*.</span><span class="w">
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_Seq</span><span class="w"> </span><span class="kp">with</span><span class="w"> </span><span class="o">(</span><span class="no">st'0</span><span class="o">)</span><span class="p">;</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>There are some equivalence relations that are not congruence.</p>

<p>Define equivalence: two programs are said to be equivalent if after applying to an empty state (that is, no variables in record), the numbers of variables are the same. It is easy to see this relation is reflective, symmetric and transitive. But the relation is not congruence. Proof:</p>

<p>Consider two programs: (x:=0) = (y:=1)</p>

<p>It is not a congruence because</p>

<ol>
  <li>(x:=0) = (y:=1)</li>
  <li>(x:=1) = (x:=1)</li>
</ol>

<p>but</p>

<ol>
  <li>(x:=0;x:=1) != (y:=1;x:=1)</li>
</ol>

<p>QED.</p>

<h2 id="program-transformation">Program Transformation</h2>

<p>A program transformation is a function that takes one program as input and produces a modified program. Compilers are the most popular kind of transformation. <a href="https://en.wikipedia.org/wiki/Minification_(programming)">Minifiers</a>and <a href="https://en.wikipedia.org/wiki/Obfuscation_(software)">obfuscator</a> are also useful in many areas.</p>

<p>A practical application for equivalence relation is to show that ana transformation is <em>sound</em>, that is, the input and output program are equivalent. It is important to do so if some optimization are applied to the transformation.</p>

<p>Soundness is formalize as a property on a transformation:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">ctrans_sound</span><span class="w"> </span><span class="o">(</span><span class="no">ctrans</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">com</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">c</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="o">),</span><span class="w">
    </span><span class="no">cequiv</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="o">(</span><span class="no">ctrans</span><span class="w"> </span><span class="no">c</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>For instance, there is a common optimization in compilers called <a href="https://en.wikipedia.org/wiki/Constant_folding">constant-folding</a>. (the implementation of constant-folding can be found in the programming language foundation book, see reference <sup id="fnref:1:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>).</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">fold_constants_com_sound</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="no">ctrans_sound</span><span class="w"> </span><span class="no">fold_constants_com</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">unfold</span><span class="w"> </span><span class="no">ctrans_sound</span><span class="pi">.</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="no">c</span><span class="pi">.</span><span class="w">
  </span><span class="kp">induction</span><span class="w"> </span><span class="no">c</span><span class="p">;</span><span class="w"> </span><span class="kp">simpl</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* skip *)</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">refl_cequiv</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* := *)</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">CAsgn_congruence</span><span class="pi">.</span><span class="w">
              </span><span class="kp">apply</span><span class="w"> </span><span class="no">fold_constants_aexp_sound</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* ; *)</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">CSeq_congruence</span><span class="p">;</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* if *)</span><span class="w">
    </span><span class="no">assert</span><span class="w"> </span><span class="o">(</span><span class="no">bequiv</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">(</span><span class="no">fold_constants_bexp</span><span class="w"> </span><span class="no">b</span><span class="o">)).</span><span class="w"> </span><span class="o">{</span><span class="w">
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">fold_constants_bexp_sound</span><span class="pi">.</span><span class="w"> </span><span class="o">}</span><span class="w">
    </span><span class="kp">destruct</span><span class="w"> </span><span class="o">(</span><span class="no">fold_constants_bexp</span><span class="w"> </span><span class="no">b</span><span class="o">)</span><span class="w"> </span><span class="no">eqn</span><span class="p">:</span><span class="no">Heqb</span><span class="p">;</span><span class="w">
      </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">apply</span><span class="w"> </span><span class="no">CIf_congruence</span><span class="p">;</span><span class="w"> </span><span class="ne">assumption</span><span class="o">).</span><span class="w">
      </span><span class="c">(* (If the optimization doesn't eliminate the if, then the
          result is easy to prove from the IH and
          [fold_constants_bexp_sound].) *)</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="c">(* b always true *)</span><span class="w">
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">trans_cequiv</span><span class="w"> </span><span class="kp">with</span><span class="w"> </span><span class="no">c1</span><span class="p">;</span><span class="w"> </span><span class="kp">try</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">if_true</span><span class="p">;</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="c">(* b always false *)</span><span class="w">
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">trans_cequiv</span><span class="w"> </span><span class="kp">with</span><span class="w"> </span><span class="no">c2</span><span class="p">;</span><span class="w"> </span><span class="kp">try</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">if_false</span><span class="p">;</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="no">assert</span><span class="w"> </span><span class="o">(</span><span class="no">bequiv</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">(</span><span class="no">fold_constants_bexp</span><span class="w"> </span><span class="no">b</span><span class="o">)).</span><span class="w">
    </span><span class="o">{</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">fold_constants_bexp_sound</span><span class="pi">.</span><span class="w"> </span><span class="o">}</span><span class="w">
    </span><span class="kp">destruct</span><span class="w"> </span><span class="o">(</span><span class="no">fold_constants_bexp</span><span class="w"> </span><span class="no">b</span><span class="o">)</span><span class="p">;</span><span class="w">
    </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">apply</span><span class="w"> </span><span class="no">CWhile_congruence</span><span class="p">;</span><span class="w"> </span><span class="ne">assumption</span><span class="o">).</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">while_true</span><span class="pi">.</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">while_false</span><span class="pi">.</span><span class="w"> </span><span class="ne">assumption</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h2 id="references">References</h2>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>“Program Equivalence.” 2024. <em>Equiv: Program Equivalence</em>. Accessed January 25. https://softwarefoundations.cis.upenn.edu/plf-current/Equiv.html. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:1:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
  </ol>
</div>

  </div><a class="u-url" href="/software-foundations/2024/01/25/Program-Equivalence.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    
    <div class="footer-col-wrapper">
      <div class="footer-col">
        <h2 class="footer-heading">Chew&#39;s Everyday Blog</h2>By wisdom a house is built, and through understanding it is established.</div>
      <div class="footer-col">
        <ul class="contact-list">
          <li class="p-name">Author: Chew Y. Feng</li><li>
              <span>
                Mail: 
              </span>
            <a class="u-email" href="mailto:chew.y.feng@outlook.com">chew.y.feng@outlook.com</a></li><div>
              Find me:<ul class="social-media-list"><li><a href="https://github.com/excitedspider"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">excitedspider</span></a></li><li><a href="https://www.linkedin.com/in/qiuyi-feng-348968287"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">qiuyi-feng-348968287</span></a></li></ul>
</div>
            <div class="footer-col-rss">
              <p class="rss-subscribe">subscribe <a href="/feed.xml">via RSS</a></p>
            </div>
        </ul>
      </div>

    </div>

  </div>

</footer>
</body>

</html>
