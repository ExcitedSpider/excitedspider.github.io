<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Hoare Logic Basic | Chew’s Everyday Blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Hoare Logic Basic" />
<meta name="author" content="Chew Y. Feng" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Assertions, Hoare Triples and Proof Rules." />
<meta property="og:description" content="Assertions, Hoare Triples and Proof Rules." />
<link rel="canonical" href="/software-foundations/2024/02/02/Hoare-Logic-Basic.html" />
<meta property="og:url" content="/software-foundations/2024/02/02/Hoare-Logic-Basic.html" />
<meta property="og:site_name" content="Chew’s Everyday Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-02-02T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Hoare Logic Basic" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Chew Y. Feng"},"dateModified":"2024-02-15T10:47:25+00:00","datePublished":"2024-02-02T00:00:00+00:00","description":"Assertions, Hoare Triples and Proof Rules.","headline":"Hoare Logic Basic","mainEntityOfPage":{"@type":"WebPage","@id":"/software-foundations/2024/02/02/Hoare-Logic-Basic.html"},"url":"/software-foundations/2024/02/02/Hoare-Logic-Basic.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Chew&apos;s Everyday Blog" /><script>
    // for MathJax inline
    window.MathJax = {
      tex: {
        inlineMath: [['_', '_'], ['$', '$'], ['\\(', '\\)']]
      }
    };
  </script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/css-doodle/0.37.4/css-doodle.min.js"></script>
  <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Teko">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-4TZZDRT6JY"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-4TZZDRT6JY');
  </script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Chew&#39;s Everyday Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="page-content-background">
        <css-doodle click-to-update>
          <style>
            @grid: 1 / 100vw 100vh / #0a0c27;
            background-size: 200px 200px;
            background-image: @doodle(
              @grid: 6 / 100%;
              @size: 4px;
              font-size: 4px;
              color: hsl(@r240, 30%, 50%);
              box-shadow: @m3x5(
                calc(4em - @nx * 1em) calc(@ny * 1em)
                  @p(@m3(currentColor), @m2(transparent)),
                calc(2em + @nx * 1em) calc(@ny * 1em)
                  @lp
              );
            );
          </style>
        </css-doodle>
      </div>
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Hoare Logic Basic</h1>
    <p class="post-meta"><span class="tags">
        
          <span>Coq</span>
        
          <span>PLT</span>
        
      </span><time class="dt-published" datetime="2024-02-02T00:00:00+00:00" itemprop="datePublished">
        Posted At: Feb 2, 2024
      </time><time>
        Modified At: Feb 15, 2024
      </time><span class="dt-tags">
        Category:
        
          <span>Software-Foundations</span>
        
      </span></p>
  </header>


  <div class="post-content e-content" itemprop="articleBody">
    <ul id="markdown-toc">
  <li><a href="#assertions" id="markdown-toc-assertions">Assertions</a></li>
  <li><a href="#hoare-triple" id="markdown-toc-hoare-triple">Hoare Triple</a></li>
  <li><a href="#structured-proof-rules" id="markdown-toc-structured-proof-rules">Structured Proof Rules</a>    <ul>
      <li><a href="#sequencing" id="markdown-toc-sequencing">Sequencing</a></li>
      <li><a href="#assignment" id="markdown-toc-assignment">Assignment</a></li>
      <li><a href="#consequence" id="markdown-toc-consequence">Consequence</a></li>
      <li><a href="#conditions" id="markdown-toc-conditions">Conditions</a></li>
      <li><a href="#loops" id="markdown-toc-loops">Loops</a></li>
    </ul>
  </li>
  <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
  <li><a href="#reference" id="markdown-toc-reference">Reference</a></li>
</ul>

<p>The <em>Floyd-Hoare Logic</em>, or <em>Hoare Logic</em>, is a formal logic system which is able to reason about the correctness of computer programs <strong>rigorously</strong> and <strong>compositionally</strong>. It is rigorous in the sense that it bases on formal logics. It is compositional because it allows researchers to look at the syntactic constructs of a imperative program.</p>

<p>There are two main ideas of Hoare Logics:</p>
<ol>
  <li>writing down formal specifications of programs</li>
  <li>proof technique of programs which mirrors the structure of program</li>
</ol>

<h2 id="assertions">Assertions</h2>

<p>Assertions are logical claims about the state of programs. Intuitively, programmers want the programs to satisfy some constrains at a certain point.  For example, if I wrote such code</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">File</span> <span class="n">myObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"filename.txt"</span><span class="o">);</span>
<span class="nc">Scanner</span> <span class="n">myReader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="n">myObj</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">data</span> <span class="o">=</span> <span class="n">myReader</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span> <span class="c1">// &lt;-</span>
</code></pre></div></div>

<p>Before execution of the last line, I certainly want there are lines to read. In other words, it should be in a state that  <code class="language-plaintext highlighter-rouge">myReader</code> is valid:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">()</span> <span class="o">-&gt;</span> <span class="k">this</span><span class="o">.</span><span class="na">myReader</span><span class="o">.</span><span class="na">hasNextLine</span><span class="o">()</span>
</code></pre></div></div>

<p>Formally, an assertion is a property of states, which states the correctness of a program.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">Assertion</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">state</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="kr">Prop</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h2 id="hoare-triple">Hoare Triple</h2>
<p>The central of Hoare Logic is the <em>Hoare Triple</em>. A triple describes how the execution of a piece of code changes the state (<a href="https://en.wikipedia.org/wiki/State_(computer_science)">program state</a>). The formal notation of a triple is:</p>

\[\{P\}~c~\{Q\}\]

<p>where P and Q are assertions, c is the piece of code (commands) that being executed. P is named the <em>precondition</em> and Q the <em>postcondition</em>. This triple asserts that if the state satisfy $P$, after code $c$ was executed, the state should satisfy $Q$.</p>

<p>Reasoning about the program is (partially) equivalent to see if a triple is <em>valid</em>. For example, the triple</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">}</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">{</span><span class="no">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">}</span><span class="w">
</span></code></pre></div></div>

<p>is apparently valid. (Here I adopt the annotation of assertions from <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>)</p>

<p>We can formalize the validity of triples as a proposition</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">valid_hoare_triple</span><span class="w">
           </span><span class="o">(</span><span class="no">P</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Assertion</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">c</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">Q</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Assertion</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">forall</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">st'</span><span class="o">,</span><span class="w">
     </span><span class="no">st</span><span class="w"> </span><span class="o">=[</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="o">]=&gt;</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
     </span><span class="no">P</span><span class="w"> </span><span class="no">st</span><span class="w">  </span><span class="o">-&gt;</span><span class="w">
     </span><span class="no">Q</span><span class="w"> </span><span class="no">st'</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h2 id="structured-proof-rules">Structured Proof Rules</h2>

<p>A wonderful idea of Hoare Logic is that the proof mirrors the structure of the program itself. Let’s look at some fundamental ones based on the language imp (which defined in <sup id="fnref:1:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>).</p>

<h3 id="sequencing">Sequencing</h3>

<p>A sequence of commands can be “torn down” by look at each command.  The rule is:</p>

\[{\displaystyle {\dfrac {\{P\}S\{Q\}\quad ,\quad \{Q\}T\{R\}}{\{P\}S;T\{R\}}}}\]

<p>which can be easily translated to Coq:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">hoare_seq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">Q</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="no">c2</span><span class="o">,</span><span class="w">
     </span><span class="o">{{</span><span class="no">Q</span><span class="o">}}</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="o">{{</span><span class="no">R</span><span class="o">}}</span><span class="w"> </span><span class="p">→</span><span class="w">
     </span><span class="o">{{</span><span class="no">P</span><span class="o">}}</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="o">{{</span><span class="no">Q</span><span class="o">}}</span><span class="w"> </span><span class="p">→</span><span class="w">
     </span><span class="o">{{</span><span class="no">P</span><span class="o">}}</span><span class="w"> </span><span class="no">c1</span><span class="p">;</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="o">{{</span><span class="no">R</span><span class="o">}}.</span><span class="w">
</span></code></pre></div></div>

<p>Although it is intuitive, but one should see that it shows how Hoare Logic can <strong>compositionally</strong> reason a program - by the transitivity of triples - without taking the program as a whole.</p>
<h3 id="assignment">Assignment</h3>

<p>For imperative programs, the typical command that changes the program state is assignment. Thus, it is the most fundamental of the Hoare logic.</p>

\[{\dfrac {}{\{P[E/x]\}x:=E\{P\}}}\]

<p>where $P[E/x]$ means the assertion $P$ in which every free occurrence of x as been replaced by E.</p>

<p>For example, what the precondition could be in this triple?</p>

\[\{ ??? \}~X:= X + Y~\{X=1\}\]

<p>If we replace $X$ with $X+Y$ in the postcondition, a valid precondition is acquired.</p>

\[\{ X+Y = 1 \}~X:= X + Y~\{X=1\}\]

<p>This trick works because it exploits the definition of assignment. Besides, this trick is so mechanical that it could be implemented in Coq trivially.</p>

<p>The implementation of $P[E/x]$:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">assertion_sub</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">(</span><span class="no">P</span><span class="p">:</span><span class="no">Assertion</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Assertion</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">fun</span><span class="w"> </span><span class="o">(</span><span class="no">st</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
    </span><span class="no">P</span><span class="w"> </span><span class="o">(</span><span class="no">X</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="no">aeval</span><span class="w"> </span><span class="no">st</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="no">st</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<p>This function takes a variable <code class="language-plaintext highlighter-rouge">X</code>, an expression <code class="language-plaintext highlighter-rouge">a</code> and an assertion P, returns an assertion that replaces the evaluation of <code class="language-plaintext highlighter-rouge">st X</code> to <code class="language-plaintext highlighter-rouge">st a</code>.</p>

<p>It is also known as “backwards reasoning” because we take postconditions and commands as inputs, outputing the preconditions. Actually it is a good way to think because the postconditions are usually the most important. But it is not to say that it’s impossible to do forward reasoning - see <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> for more examples.</p>

<p>To translate this rule into Coq:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">hoare_asgn</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">Q</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="no">a</span><span class="o">,</span><span class="w">
  </span><span class="o">{{</span><span class="no">Q</span><span class="w"> </span><span class="o">[</span><span class="no">X</span><span class="w"> </span><span class="o">|-&gt;</span><span class="w"> </span><span class="no">a</span><span class="o">]}}</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">{{</span><span class="no">Q</span><span class="o">}}.</span><span class="w">

</span><span class="k">Example</span><span class="w"> </span><span class="no">hoare_asgn_examples1</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="kp">exists</span><span class="w"> </span><span class="no">P</span><span class="o">,</span><span class="w">
    </span><span class="o">{{</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="o">}}</span><span class="w">
      </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">X</span><span class="w">
    </span><span class="o">{{</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">}}.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">exists</span><span class="w"> </span><span class="o">((</span><span class="no">X</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10</span><span class="o">)</span><span class="w"> </span><span class="o">[</span><span class="no">X</span><span class="w"> </span><span class="o">|-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">X</span><span class="o">]).</span><span class="w">
  </span><span class="kp">apply</span><span class="w"> </span><span class="no">hoare_asgn</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>A common error is to use this rule in a “forward” way. In other words, this is incorrect: ${\displaystyle {P}x:=E{P[E/x]}}$</p>

<p>We give a counterexample of it to show that it is indeed incorrect:</p>

\[{\displaystyle \{\text{True}\}~x:=a~\{X = a\}}\]

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">hoare_asgn_wrong</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kp">exists</span><span class="w"> </span><span class="no">a</span><span class="p">:</span><span class="no">aexp</span><span class="o">,</span><span class="w">
  </span><span class="o">~</span><span class="w"> </span><span class="o">{{</span><span class="w"> </span><span class="no">True</span><span class="w"> </span><span class="o">}}</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">{{</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">}}.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">exists</span><span class="w"> </span><span class="o">(</span><span class="no">APlus</span><span class="w"> </span><span class="o">(</span><span class="no">AId</span><span class="w"> </span><span class="no">X</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">ANum</span><span class="w"> </span><span class="mi">1</span><span class="o">)).</span><span class="w"> </span><span class="c">(* X := X + 1 *)</span><span class="w">
  </span><span class="kp">unfold</span><span class="w"> </span><span class="no">not</span><span class="pi">.</span><span class="w">
  </span><span class="kp">unfold</span><span class="w"> </span><span class="no">valid_hoare_triple</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="pi">.</span><span class="w">
  </span><span class="no">remember</span><span class="w"> </span><span class="o">(</span><span class="no">X</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="no">st</span><span class="pi">.</span><span class="w">
  </span><span class="no">remember</span><span class="w"> </span><span class="o">(</span><span class="no">X</span><span class="w"> </span><span class="o">!-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="no">st</span><span class="o">)</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="no">st'</span><span class="pi">.</span><span class="w">
  </span><span class="kp">unfold</span><span class="w"> </span><span class="no">Aexp_of_aexp</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w">
  </span><span class="no">assert</span><span class="w"> </span><span class="o">(</span><span class="no">aeval</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">aeval</span><span class="w"> </span><span class="no">st'</span><span class="w"> </span><span class="o">&lt;{</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">}&gt;).</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="kp">apply</span><span class="w"> </span><span class="no">H</span><span class="w"> </span><span class="kp">with</span><span class="w"> </span><span class="no">st</span><span class="pi">.</span><span class="w">
    </span><span class="o">-</span><span class="w"> </span><span class="kp">subst</span><span class="pi">.</span><span class="w">
      </span><span class="kp">apply</span><span class="w"> </span><span class="no">E_Asgn</span><span class="pi">.</span><span class="w">
      </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
    </span><span class="o">-</span><span class="w"> </span><span class="kp">unfold</span><span class="w"> </span><span class="no">assert_of_Prop</span><span class="pi">.</span><span class="w"> </span><span class="no">trivial</span><span class="pi">.</span><span class="w">
  </span><span class="o">}</span><span class="w">
  </span><span class="kp">subst</span><span class="pi">.</span><span class="w"> </span><span class="kp">inversion</span><span class="w"> </span><span class="no">H0</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h3 id="consequence">Consequence</h3>

\[{\displaystyle {\dfrac {P_{1}\rightarrow P_{2}\quad ,\quad \{P_{2}\}S\{Q_{2}\}\quad ,\quad Q_{2}\rightarrow Q_{1}}{\{P_{1}\}S\{Q_{1}\}}}}\]

<p>This rule allows strengthening the precondition or(and) weaken the postconditions.</p>

<p>For example, if my precondition is ${ X &gt; 10 }$ , I can strengthen it to ${X &gt; 20}$. For most of the time, this rule is used to adjust the assertions to what we need.</p>

<h3 id="conditions">Conditions</h3>
<p>A conditional command <code class="language-plaintext highlighter-rouge">if b then s else t end</code> naturally has this form in logic:</p>

\[{\displaystyle {\dfrac {\{B\wedge P\}S\{Q\}\quad ,\quad \{\neg B\wedge P\}T\{Q\}}{\{P\}{\texttt {if}}\ B\ {\texttt {then}}\ S\ {\texttt {else}}\ T\ {\texttt {end}}\{Q\}}}}\]

<p>That is, in the <code class="language-plaintext highlighter-rouge">then</code> branch, we know $B$ is evaluated to $\text{True}$; and in the <code class="language-plaintext highlighter-rouge">else</code> branch, $B$ is evaluated to $\text{False}$.  We could use this information in reasoning. Moreover, if $B$ (or $\lnot B$) contradicts $P$, we could rule out that branch because its hypothesis contains a contradiction.</p>

<p>Formalization in coq:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">hoare_if</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">Q</span><span class="w"> </span><span class="o">(</span><span class="no">b</span><span class="p">:</span><span class="no">bexp</span><span class="o">)</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="no">c2</span><span class="o">,</span><span class="w">
  </span><span class="o">{{</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="o">/\</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">}}</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="o">{{</span><span class="no">Q</span><span class="o">}}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="o">{{</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="o">/\</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="no">b</span><span class="o">}}</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="o">{{</span><span class="no">Q</span><span class="o">}}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="o">{{</span><span class="no">P</span><span class="o">}}</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">c1</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="no">c2</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">{{</span><span class="no">Q</span><span class="o">}}.</span><span class="w">

</span><span class="c">(* example *)</span><span class="w">
</span><span class="k">Theorem</span><span class="w"> </span><span class="no">if_minus_plus</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="o">{{</span><span class="no">True</span><span class="o">}}</span><span class="w">
    </span><span class="kr">if</span><span class="w"> </span><span class="o">(</span><span class="no">X</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="no">Y</span><span class="o">)</span><span class="w">
      </span><span class="kr">then</span><span class="w"> </span><span class="no">Z</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">Y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="no">X</span><span class="w">
      </span><span class="kr">else</span><span class="w"> </span><span class="no">Y</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">Z</span><span class="w">
    </span><span class="kr">end</span><span class="w">
  </span><span class="o">{{</span><span class="no">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">Z</span><span class="o">}}.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">apply</span><span class="w"> </span><span class="no">hoare_if</span><span class="p">;</span><span class="w"> </span><span class="kp">eapply</span><span class="w"> </span><span class="no">hoare_consequence_pre</span><span class="p">;</span><span class="w">
  </span><span class="kp">try</span><span class="w"> </span><span class="o">(</span><span class="kp">apply</span><span class="w"> </span><span class="no">hoare_asgn</span><span class="o">)</span><span class="p">;</span><span class="w"> </span><span class="kp">simpl</span><span class="p">;</span><span class="w"> </span><span class="no">assertion_auto''</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h3 id="loops">Loops</h3>

\[{\displaystyle {\dfrac {\{P\wedge B\}S\{P\}}{\{P\}{\texttt {while}}\ B\ {\texttt {do}}\ S\ {\texttt {end}}\{\neg B\wedge P\}}}}\]

<p>This rule captures the most important behaviors of loops:</p>
<ul>
  <li>The loop body will be executed only if $B$ is true</li>
  <li>The loop terminates when $B$ becomes false.</li>
  <li>We call $P$ a loop invariant to $S$ if $\{P \wedge B\}S\{P\}$. This means P will be true at the end of the loop body if $B$ is true in the beginning. Otherwise, (if P contradicts B), it still holds because the precondition becomes trivial.</li>
</ul>

<p>Note that Hoare Logic only cares about loops that terminates. In other word, only partial correctness can be proven. There is a variant version of loop rule that can be formulated to prove total correctness<sup id="fnref:2:1" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>.  But as deciding if a program halts is known as undecidable, it is hard to work with total correctness, or it would require special designs of programming languages.</p>

<p>Formalize it in Coq</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">hoare_while</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="o">(</span><span class="no">b</span><span class="p">:</span><span class="no">bexp</span><span class="o">)</span><span class="w"> </span><span class="no">c</span><span class="o">,</span><span class="w">
  </span><span class="o">{{</span><span class="no">P</span><span class="w"> </span><span class="o">/\</span><span class="w"> </span><span class="no">b</span><span class="o">}}</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="o">{{</span><span class="no">P</span><span class="o">}}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="o">{{</span><span class="no">P</span><span class="o">}}</span><span class="w"> </span><span class="no">while</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kr">end</span><span class="w"> </span><span class="o">{{</span><span class="no">P</span><span class="w"> </span><span class="o">/\</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="no">b</span><span class="o">}}.</span><span class="w">
</span></code></pre></div></div>
<h2 id="summary">Summary</h2>
<ul>
  <li>Assertions are properties of program states.</li>
  <li>Hoare Triples are built on assertions.</li>
  <li>Hoare Triples can be reasoned mechanically through proof rules</li>
</ul>

<h2 id="reference">Reference</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p><a href="https://softwarefoundations.cis.upenn.edu/plf-current/index.html">PROGRAMMING LANGUAGE FOUNDATIONS</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:1:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><a href="https://en.wikipedia.org/wiki/Hoare_logic">Wikipedia: Hoare logic</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:2:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
  </ol>
</div>

  </div><a class="u-url" href="/software-foundations/2024/02/02/Hoare-Logic-Basic.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    
    <div class="footer-col-wrapper">
      <div class="footer-col">
        <h2 class="footer-heading">Chew&#39;s Everyday Blog</h2>By wisdom a house is built, and through understanding it is established.</div>
      <div class="footer-col">
        <ul class="contact-list">
          <li class="p-name">Author: Chew Y. Feng</li><li>
              <span>
                Mail: 
              </span>
            <a class="u-email" href="mailto:chew.y.feng@outlook.com">chew.y.feng@outlook.com</a></li><div>
              Find me:<ul class="social-media-list"><li><a href="https://github.com/excitedspider"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">excitedspider</span></a></li><li><a href="https://www.linkedin.com/in/qiuyi-feng-348968287"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">qiuyi-feng-348968287</span></a></li></ul>
</div>
            <div class="footer-col-rss">
              <p class="rss-subscribe">subscribe <a href="/feed.xml">via RSS</a></p>
            </div>
        </ul>
      </div>

    </div>

  </div>

</footer>
</body>

</html>
